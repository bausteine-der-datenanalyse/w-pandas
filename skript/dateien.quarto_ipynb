{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "# Dateien lesen und schreiben\n",
        "**Dieser Teil ist aus dem m-EsD**  \n",
        "Pandas bietet eine Reihe von Funktionen, um Dateien einzulesen und zu schreiben, deren Namensgebung einem einheitlichen Schema folgt. Funktionen zum Lesen von Dateien werden in der Form `pd.read_csv()` und Funktionen zum Schreiben in der Form `pd.to_csv()` aufgerufen. Mit Pandas können auch Dateien aus dem Internet abgerufen werden `pd.read_csv(URL)`.\n"
      ],
      "id": "2c5eec69"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: false\n",
        "\n",
        "import numpy as np\n",
        "import pandas as pd"
      ],
      "id": "9472f9e6",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        ":::: {.border}\n",
        "| Format Type | Data Description | Reader | Writer |\n",
        "|:---:|:---:|:---:|:---:|\n",
        "| text | CSV | read_csv | to_csv |\n",
        "| text | Fixed-Width Text File | read_fwf | NA |\n",
        "| text | JSON | read_json | to_json |\n",
        "| text | HTML | read_html | to_html |\n",
        "| text | LaTeX | Styler.to_latex | NA |\n",
        "| text | XML | read_xml | to_xml |\n",
        "| text | Local clipboard | read_clipboard | to_clipboard |\n",
        "| binary | MS Excel | read_excel | to_excel |\n",
        "| binary | OpenDocument | read_excel | NA |\n",
        "| binary | HDF5 Format | read_hdf | to_hdf |\n",
        "| binary | Feather Format | read_feather | to_feather |\n",
        "| binary | Parquet Format | read_parquet | to_parquet |\n",
        "| binary | ORC Format | read_orc | to_orc |\n",
        "| binary | Stata | read_stata | to_stata |\n",
        "| binary | SAS | read_sas | NA |\n",
        "| binary | SPSS | read_spss | NA |\n",
        "| binary | Python Pickle Format | read_pickle | to_pickle |\n",
        "| SQL | SQL | read_sql | to_sql |\n",
        "\n",
        "([Pandas Dokumentation](https://pandas.pydata.org/docs/user_guide/io.html))\n",
        "::::\n",
        "\n",
        "&nbsp;\n",
        "\n",
        "Im Folgenden wird der Datensatz palmerpenguins mit Pandas eingelesen.\n",
        "\n",
        "::: {.border}\n",
        "\n",
        "**palmerpenguins**\n",
        "\n",
        "![Pinguine des Palmer-Station-Datensatzes](00-bilder/lter_penguins_allison_horst_CC0.png)\n",
        "\n",
        "Meet the Palmer penguins von \\@allison_horst steht unter der Lizenz [CC0-1.0](https://github.com/allisonhorst/palmerpenguins?tab=CC0-1.0-1-ov-file#creative-commons) und ist auf [GitHub](https://github.com/allisonhorst/palmerpenguins?tab=readme-ov-file#meet-the-palmer-penguins) abrufbar. 2020\n",
        "\n",
        "Der Datensatz steht unter der Lizenz [CCO](https://creativecommons.org/public-domain/cc0/) und ist in R sowie auf [GitHub](https://github.com/allisonhorst/palmerpenguins?tab=readme-ov-file) verfügbar. 2020\n",
        "\n",
        "``` {.raw}\n",
        "# R Befehle, um den Datensatz zu laden\n",
        "install.packages(\"palmerpenguins\")\n",
        "library(palmerpenguins)\n",
        "```\n",
        "\n",
        "Horst AM, Hill AP und Gorman KB. 2020. palmerpenguins: Palmer Archipelago (Antarctica) penguin data. R package version 0.1.0. <https://allisonhorst.github.io/palmerpenguins/>. doi: 10.5281/zenodo.3960218.\n",
        "\n",
        ":::\n",
        "\n",
        "&nbsp;\n",
        "\n",
        "Die Funktionen zum Lesen von Dateien erwarten eine Pfadangabe, die positional oder mit einem Schlüsselwort übergeben werden kann. Das Schlüsselwort für die Pfadangabe variiert abhängig vom Dateityp und lautet für eine kommaseparierte CSV-Datei `filepath_or_buffer`.\n"
      ],
      "id": "fb025fe9"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "penguins = pd.read_csv(filepath_or_buffer = '01-daten/penguins.csv')"
      ],
      "id": "917cdce6",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Ein Blick auf die Daten mit der Methode `penguins.head()`:\n"
      ],
      "id": "31434e3f"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "print(penguins.head())"
      ],
      "id": "ba62ba62",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "::: {.border}\n",
        "\n",
        "![Schnabeldimensionen](00-bilder/culmen_depth_allison_horst_CC0.png)\n",
        "\n",
        "Bill dimensions von \\@allison_horst steht unter der Lizenz [CC0-1.0](https://github.com/allisonhorst/palmerpenguins?tab=CC0-1.0-1-ov-file#creative-commons) und ist auf [GitHub](https://github.com/allisonhorst/palmerpenguins?tab=readme-ov-file#meet-the-palmer-penguins) abrufbar. 2020\n",
        "\n",
        ":::\n",
        "\n",
        "&nbsp;\n",
        "\n",
        "Einen Überblick über den Datensatz verschafft die Methode `DataFrame.info()`."
      ],
      "id": "717f5cc4"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "print(penguins.info())"
      ],
      "id": "5a115731",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Einige Datentypen wurden nicht erkannt. Den betreffenden Spalten wurde der Sammeltyp object zugeordnet. Den Funktionen zum Einlesen von Daten kann mit dem Argument `dtype` der Datentyp übergeben werden. Für mehrere Spalten ist dies in Form eines Dictionaries in der Form `{'Spaltenname': 'dtype'}` möglich. Mit der Methode `DataFrame.astype()` ist dies auch nachträglich möglich.\n"
      ],
      "id": "3a079fa6"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "penguins = pd.read_csv(filepath_or_buffer = '01-daten/penguins.csv', dtype = {'species': 'category', 'island': 'category', 'sex': 'category'})\n",
        "\n",
        "# nachträglich\n",
        "# penguins = penguins.astype({'species': 'category', 'island': 'category', 'sex': 'category'})\n",
        "\n",
        "print(penguins.info())"
      ],
      "id": "51961866",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Einige Spalten weisen ungültige Werte auf. Die Tiere mit unvollständigen Werten sollen aus dem Datensatz entfernt werden. \n",
        "\n",
        "  - Mit der Methode `DataFrame.apply(pd.isna)` werden fehlende Werte bestimmt.\n",
        "  - Mit der Methode `DataFrame.any(axis = 1)` wird das Ergebnis zeilenweise aggregiert. any gibt True zurück, wenn mindestens ein Element True ist.\n",
        "  - Mit der Methode `sum()` wird die Anzahl der Zeilen mit fehlenden Werten bestimmt.\n",
        "  - Mit `np.where()` wird deren Indexposition bestimmt.\n",
        "  - Mit der Methode `DataFrame.drop()` werden die betreffenden Zeilen entfernt.\n"
      ],
      "id": "fb96629e"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Fehlende Werte bestimmen\n",
        "print(penguins.apply(pd.isna).head(), \"\\n\")\n",
        "\n",
        "# zeilenweise aggregieren\n",
        "print(penguins.apply(pd.isna).any(axis = 1).head(), \"\\n\")\n",
        "\n",
        "# Anzahl der Zeilen mit fehlenden Werten\n",
        "print(f\"Für {penguins.apply(pd.isna).any(axis = 1).sum()} Pinguine liegen unvollständige Werte vor.\\n\")\n",
        "\n",
        "# Indexpositionen bestimmen\n",
        "print(np.where(penguins.apply(pd.isna).any(axis = 1))[0])\n",
        "\n",
        "# Zeilen entfernen\n",
        "penguins.drop(np.where(penguins.apply(pd.isna).any(axis = 1))[0], inplace = True)"
      ],
      "id": "043a6534",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Kontrolle:"
      ],
      "id": "bf4a0c97"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "print(penguins.info())"
      ],
      "id": "b31d9ff4",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Zeitreihen einlesen\n",
        "Mit Pandas ist es leicht möglich, Zeitreihen einzulesen. Durch string parsing können beliebige Zeichenketten als datetime interpretiert werden.\n",
        "\n",
        "Wenn der innere Aufbau einer Datei bekannt ist, können die notwendigen Parameter direkt beim Einlesen beispielsweise mit `pd.read_csv()` übergeben werden. Dazu werden die Parameter `parse_dates` und `date_format` verwendet.\n",
        "\n",
        "`parse_dates` gibt an, an welcher Stelle sich datetime-Informationen befinden. Es können verschiedene Argumente übergeben werden.\n",
        "\n",
        "  - `parse_dates = True` bewirkt, dass der Index als datetime interpretiert wird.\n",
        "  - Eine Liste von Ganzzahlen oder Spaltenbeschriftungen bewirkt, dass diese Spalten jeweils als eigene Spalte in datetime übersetzt werden, bspw `parse_dates = [1, 2, 3]`.\n",
        "  - Eine von einer Liste umschlossene Liste bewirkt, dass die übergebenen Spalten in einer einzigen Spalte zusammengeführt werden, bspw. `parse_dates = [[1, 2, 3]]`. Die Werte der Spalten werden mit einem Leerzeichen getrennt und anschließend interpretiert.\n",
        "\n",
        "Pandas interpretiert die Zeichenketten nach [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) als Repräsentation eines Datums in der festgelegten Reihenfolge Jahr, Monat, Tag, Stunde, Minute, Sekunde, Millisekunde im Format `YYYY-MM-DD 12:00:00.000`. Als Zeichentrenner zwischen Datum und Uhrzeit sind ein Leerzeichen oder der Buchstabe T zulässig. Der Datentyp und die kleinste verwendete Einheit werden im Attribut `dtype` gespeichert.\n",
        "\n",
        "Andere Formate werden mit dem Parameter `date_format` spezifiziert. Mit Hilfe der [strftime-Dokumentation](https://docs.python.org/3/library/datetime.html#strftime-and-strptime-behavior) kann das Datumsformat übergeben werden.\n",
        "\n",
        "Datumsinformationen können aber auch nachträglich als solche deklariert werden. Dafür wird die Funktion `pd.to_datetime(arg, format = \" ... \")` verwendet. Mit dem Parameter `arg` wird die zu konvertierende Spalte übergeben. Mit dem Parameter `format` kann wie mit dem Parameter `date_format` ein von der ISO8601 abweichendes Datumsformat spezifiziert werden.  \n",
        "\n",
        "Unter dem Pfad '01-daten/Microsoft_Stock.csv' sind Kursdaten der Microsoft-Aktie gespeichert.\n",
        "\n",
        "::: {.border}\n",
        "\n",
        "Microsoft Stock- Time Series Analysis von Vijay V Venkitesh steht unter der Lizenz [CC0](https://creativecommons.org/publicdomain/zero/1.0/) und ist auf [kaggle](https://www.kaggle.com/datasets/vijayvvenkitesh/microsoft-stock-time-series-analysis) abrufbar. 2021\n"
      ],
      "id": "987a105b"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "stock = pd.read_csv(filepath_or_buffer = '01-daten/Microsoft_Stock.csv')\n",
        "\n",
        "print(stock.head(), \"\\n\")\n",
        "print(stock.info())"
      ],
      "id": "a096f375",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        ":::\n",
        "\n",
        "In der Spalte Date sind Datums- und Zeitinformationen in der Form 'Monat/Tag/Jahr Stunde:Minute:Sekunde' verzeichnet, die von Pandas nicht automatisch erkannt wurden. Die Spalte hat deshalb den Datentyp object erhalten.\n",
        "\n",
        "## Aufgaben Zeitreihen einlesen\n",
        "1. Übergeben Sie der Funktion `pd.read_csv()` die erforderlichen Argumente, um die Spalte Date korrekt als datetime einzulesen.\n",
        "\n",
        "2. Berechnen Sie die Höchstkurse für jede Woche (intraday).\n",
        "\n",
        "**Aufgabe 2 kann Marc testen, ob die zu schwierig ist.**\n",
        "\n",
        "::: {#tip-musterloesungzeitreihe .callout-tip collapse=\"true\"} \n",
        "## Musterlösung Zeitreihen einlesen\n",
        "\n",
        "1. Aufgabe"
      ],
      "id": "537d5917"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "stock = pd.read_csv(filepath_or_buffer = '01-daten/Microsoft_Stock.csv',\n",
        "        parse_dates = ['Date'], # alternativ: [0]\n",
        "        date_format = '%m/%d/%Y %H:%M:%S')\n",
        "\n",
        "print(stock.head(), \"\\n\")\n",
        "print(stock.info())"
      ],
      "id": "7463893a",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "2. Aufgabe\n",
        "\n",
        "Die Pandas-Methode `Series.dt.weekofyear()` wird seit einiger Zeit nicht mehr unterstützt ([siehe Dokumentation](https://pandas.pydata.org/pandas-docs/version/1.5/reference/api/pandas.Series.dt.weekofyear.html)). Die Funktion wurde durch `Series.dt.isocalendar().week` ersetzt. \n"
      ],
      "id": "1894f282"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Jahr und Woche isolieren\n",
        "print(stock['Date'].dt.isocalendar().week.head(), \"\\n\")\n",
        "print(stock['Date'].dt.isocalendar().year.tail())\n",
        "\n",
        "# Jahr und Woche in den DataFrame einfügen\n",
        "stock.insert(loc = 1, column = 'week', value = stock['Date'].dt.isocalendar().week)\n",
        "stock.insert(loc = 1, column = 'year', value = stock['Date'].dt.isocalendar().year)\n",
        "\n",
        "# Maximum für jede Woche mit groupby bestimmen\n",
        "print(stock.groupby(by = ['year', 'week'])['High'].max())\n",
        "\n",
        "# grafisch darstellen\n",
        "stock.groupby(by = ['year', 'week'])['High'].max().plot(ylabel = 'Wochenhöchstkurs (intraday)', title = 'Kursentwicklung der Microsoft-Aktie')"
      ],
      "id": "e41607fd",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        ":::\n",
        "\n",
        "## Schwierige Dateien einlesen\n",
        "Das Einlesen von Dateien ist nicht immer einfach. Werkzeuge und Strategien zur Bewältigung schwieriger Fälle finden Sie im Methodenbaustein Einlesen strukturierter Datensätze **Querverweis auf m-EsD**. Dort wird auch der Umgang mit fehlenden Werten ausführlich behandelt."
      ],
      "id": "97aa5577"
    }
  ],
  "metadata": {
    "kernelspec": {
      "name": "python3",
      "language": "python",
      "display_name": "Python 3 (ipykernel)",
      "path": "C:\\Users\\mapoe004\\AppData\\Local\\Programs\\Python\\Python312\\share\\jupyter\\kernels\\python3"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}