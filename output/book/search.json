[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Bausteine Computergestützter Datenanalyse",
    "section": "",
    "text": "Werkzeugbaustein Pandas",
    "crumbs": [
      "Werkzeugbaustein Pandas"
    ]
  },
  {
    "objectID": "index.html#voraussetzungen",
    "href": "index.html#voraussetzungen",
    "title": "Bausteine Computergestützter Datenanalyse",
    "section": "Voraussetzungen",
    "text": "Voraussetzungen\nFolgende Bausteine sollte Sie bereits bearbeitet haben:\n\nw-Python\nw-NumPy\n\nIn diesem Baustein werden die folgenden Module verwendet:\n\nNumPy\nPandas\nMatplotlib\nzoneinfo (optional)\n\nIm Baustein werden folgende Daten verwendet:\n\nZahnwachstum bei Meerschweinchen CSV-Datei\nFahrzeugdaten aus der Zeitschrift Motor Trend GitHub\nVermessung von Pinguinen an der Palmer Station GitHub\nKursdaten der Microsoft-Aktie kaggle",
    "crumbs": [
      "Werkzeugbaustein Pandas"
    ]
  },
  {
    "objectID": "index.html#lernziele",
    "href": "index.html#lernziele",
    "title": "Bausteine Computergestützter Datenanalyse",
    "section": "Lernziele",
    "text": "Lernziele\nIn diesem Baustein lernen Sie …\n\ndie Datenstrukturen des Moduls Pandas Series und DataFrame kennen.\nwie Operationen in Pandas ausgeführt werden.\nwie Grafiken mit Pandas erstellt werden.\nDateien einzulesen (und zu schreiben).",
    "crumbs": [
      "Werkzeugbaustein Pandas"
    ]
  },
  {
    "objectID": "skript/einleitung.html",
    "href": "skript/einleitung.html",
    "title": "1  Einleitung",
    "section": "",
    "text": "1.1 Die Datenstrukturen Series und DataFrame\nDas Modul Pandas wurde für die Arbeit mit strukturierten Daten konzipiert. Pandas erleichtert die Analyse insbesondere von in Tabellenform vorliegenden Daten, da es mit dem DataFrame eine leicht zu benutzende Struktur für die Verarbeitung unterschiedlicher Datentypen und fehlenden Werten bietet. Wie NumPy erlaubt Pandas vektorisierte Operationen, ohne mit Hilfe einer Schleife jedes Element eines Sammeltyps durchlaufen zu müssen. Pandas integriert darüber hinaus Funktionalitäten anderer Module und bietet unter anderem einen einheitlichen Zugang zu:\nDas Modul Pandas wird mit dem Befehl import pandas geladen. Als Kürzel hat sich pd etabliert. Da Pandas auf dem Modul NumPy aufbaut, werden häufig beide Module geladen. Viele Funktionen und Methoden von NumPy und Pandas sind miteinander kompatibel.\nPandas führt die zwei Klassen Series und DataFrame ein.\nBeide Datenstrukturen verfügen über einen Index, der in der Ausgabe angezeigt wird.\nDer Index beginnt wie in der Pythonbasis bei 0.\n0    Frühschicht\n1    Frühschicht\n2    Spätschicht\ndtype: string\nDer Index ist standardmäßig numerisch, kann aber mit beliebigen Werten versehen werden.\nDer Index kann angepasst werden.\nMontag      Frühschicht\nDienstag    Frühschicht\nMittwoch    Spätschicht\ndtype: string",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Einleitung</span>"
    ]
  },
  {
    "objectID": "skript/einleitung.html#die-datenstrukturen-series-und-dataframe",
    "href": "skript/einleitung.html#die-datenstrukturen-series-und-dataframe",
    "title": "1  Einleitung",
    "section": "",
    "text": "Series sind eindimensionale Arrays, die genau einen Datentyp haben.\nDataFrame sind zweidimensionale Arrays, die spaltenweise aus Series bestehen und so verschiedene Datentypen enthalten können. (Durch hierarchische Indexierung sind mehrdimensionale Datenstrukturen möglich, siehe MultiIndex.)\n\n\n\n\n\n\nSeries\nSeries werden mit der Funktion pd.Series(data) erstellt. data kann ein Einzelwert, ein Sammeltyp oder ein NumPy-Array sein.\n\neinzelwert_series = pd.Series('Hallo Welt!')\nprint(f\"Series aus Einzelwert:\\n{einzelwert_series}\")\n\nnumerische_series = pd.Series([1, 2, 3])\nprint(f\"\\nSeries aus Liste:\\n{numerische_series}\")\n\nalphanumerische_series = pd.Series(('a', '5', 'g'))\nprint(f\"\\nSeries aus Tupel:\\n{alphanumerische_series}\")\n\nboolean_series = pd.Series(np.array([True, False, True])) # NumPy-Array\nprint(f\"\\nSeries aus NumPy-Array:\\n{boolean_series}\")\n\nSeries aus Einzelwert:\n0    Hallo Welt!\ndtype: object\n\nSeries aus Liste:\n0    1\n1    2\n2    3\ndtype: int64\n\nSeries aus Tupel:\n0    a\n1    5\n2    g\ndtype: object\n\nSeries aus NumPy-Array:\n0     True\n1    False\n2     True\ndtype: bool\n\n\nBeim Anlegen einer pd.Series können verschiedene Parameter übergeben werden:\n\npd.Series(data, dtype = 'float') legt den Datentyp der Series fest.\npd.Series(data, index = ['A1', 'B2', 'C3']) übergibt Werte für den Index.\npd.Series(data, name = 'der Name') legt einen Namen für die Series fest.\n\n\nnumerische_series = pd.Series([1, 2, 3], dtype = 'float', index = ['A1', 'B2', 'C3'],name = 'Gleitkommazahlen')\nprint(numerische_series)\n\nA1    1.0\nB2    2.0\nC3    3.0\nName: Gleitkommazahlen, dtype: float64\n\n\nFür eine bestehende Series können Name und Index über entsprechende Attribute aufgerufen und geändert werden. Um den Datentyp zu ändern, wird die Methode pd.Series.astype() verwendet. Eine Übersicht der in Pandas verfügbaren Datentypen finden Sie in der Pandas-Dokumentation.\n\nprint(f\"Name der Series: {numerische_series.name}\")\nnumerische_series.name = 'Fließkommazahlen'\n\nprint(f\"Index der Series: {numerische_series.index}\")\nnumerische_series.index =  ['eins', 'zwei', 'drei']\n\nnumerische_series = numerische_series.astype('string')\nprint(f\"\\nDie geänderte Series:\\n{numerische_series}\")\n\nName der Series: Gleitkommazahlen\nIndex der Series: Index(['A1', 'B2', 'C3'], dtype='object')\n\nDie geänderte Series:\neins    1.0\nzwei    2.0\ndrei    3.0\nName: Fließkommazahlen, dtype: string\n\n\n\n\nAufgabe Series\nÄndern Sie den Datentyp des Objekts ‘numerische_series’ in Ganzzahl und wählen Sie einen neuen Namen für die Series aus.\n\n\n\n\n\n\nTipp 1.1: Musterlösung dtype\n\n\n\n\n\n\nnumerische_series.name = 'Ganzzahlen'\nnumerische_series = numerische_series.astype('float')\nnumerische_series = numerische_series.astype('int')\n\nprint(numerische_series)\n\neins    1\nzwei    2\ndrei    3\nName: Ganzzahlen, dtype: int64\n\n\n\n\n\n\n\nDataFrame\nEin DataFrame wird mit der Funktion pd.DataFrame([data]) angelegt. data ist listenartig, kann aber aus einem Einzelwert, einer Series, einem Numpy-Array oder aus mehreren Series und Sammeltypen bestehen.\n\neinzelwert_df = pd.DataFrame(['Hallo Welt!'])\nprint(einzelwert_df, \"\\n\")\n\ndf_aus_listen = pd.DataFrame([[1, 2, 3], [4, 5, 6]])\nprint(df_aus_listen, \"\\n\")\n\ndf_aus_series = pd.DataFrame([alphanumerische_series, boolean_series])\nprint(df_aus_series, \"\\n\")\n\ndf_aus_verschieden = pd.DataFrame([np.array([True, False, True]), alphanumerische_series, [1, 2, 3]]) # NumPy-Array\nprint(df_aus_verschieden)\n\n             0\n0  Hallo Welt! \n\n   0  1  2\n0  1  2  3\n1  4  5  6 \n\n      0      1     2\n0     a      5     g\n1  True  False  True \n\n      0      1     2\n0  True  False  True\n1     a      5     g\n2     1      2     3\n\n\nBeim Anlegen eines DataFrames können ebenfalls verschiedene Parameter übergeben werden:\n\npd.DataFrame(data, dtype = 'float') legt den Datentyp des DataFrames für alle Werte fest. Wird der Parameter nicht übergeben, wählt Pandas einen passenden Datentyp für jede Spalte aus.\npd.DataFrame(data, index = ['A1', 'B2', 'C3']) übergibt Werte für den Index.\npd.DataFrame(data, columns = ['Spalte1', 'Spalte2']) übergibt Werte für die Spaltenbeschriftung.\n\nUm Daten spaltenweise einzutragen, kann der DataFrame zum einen mit dem Attribut DataFrame.T transponiert werden. Dabei müssen die Spaltenbeschriftungen als Argument index und die Indexbeschriftung als Argument columns übergeben werden.\n\ndf_transponiert = pd.DataFrame([[1, 2, 3], [True, False, True]], index = ['Spalte 1', 'Spalte 2'], columns = ['Zeile 1', 'Zeile 2', 'Zeile 3']).T\nprint(df_transponiert)\n\n        Spalte 1 Spalte 2\nZeile 1        1     True\nZeile 2        2    False\nZeile 3        3     True\n\n\nEine direkte Zuordnung der Beschriftungen ist möglich, indem zuerst der transponierte DataFrame angelegt und anschließend über die Attribute .index und .columns die Beschriftungen eingetragen werden.\n\ndf_transponiert = pd.DataFrame([[1, 2, 3], [True, False, True]]).T\ndf_transponiert.columns = ['Spalte 1', 'Spalte 2']\ndf_transponiert.index = ['Zeile 1', 'Zeile 2', 'Zeile 3']\nprint(df_transponiert)\n\n        Spalte 1 Spalte 2\nZeile 1        1     True\nZeile 2        2    False\nZeile 3        3     True\n\n\nDas Anlegen von transponierten DataFrames hat den Nachteil, dass Pandas die Datentypen der eingegebenen Daten spaltenweise verwaltet. Bei der zeilenweise erfolgenden Eingabe von Daten unterschiedlichen Datentyps wird ein für alle Spalten passender Datentyp gewählt. Im folgenden Beispiel wird deshalb von Pandas der Datentyp object für gemischte Datentypen gewählt.\n\ndf_transponiert = pd.DataFrame([[1, 2, 3], ['a', 'b', 'c']], index = ['Zahlen', 'Buchstaben']).T\nprint(df_transponiert)\nprint(f\"\\n{df_transponiert.dtypes}\")\n\n  Zahlen Buchstaben\n0      1          a\n1      2          b\n2      3          c\n\nZahlen        object\nBuchstaben    object\ndtype: object\n\n\nZum anderen kann ein DataFrame direkt aus einem Dictionary erzeugt werden. Dabei werden die Schlüssel als Spaltenbeschriftung verwendet.\n\ndf = pd.DataFrame({'Spalte 1': [1, 2, 3], 'Spalte 2': [4.1, 5.6, 6.0]}, index = ['oben', 'mitte', 'unten'])\nprint(df)\n\n       Spalte 1  Spalte 2\noben          1       4.1\nmitte         2       5.6\nunten         3       6.0\n\n\nAußerdem kann ein DataFrame durch Zuweisung von Daten erweitert werden.\n\n# einen leeren DataFrame erzeugen\ndf = pd.DataFrame()\n\n# Zuweisung von Daten\ndf['Spaltenbeschriftung'] = [1, 2, 3]\ndf['zweite Spalte'] = alphanumerische_series\n\nprint(df)\n\n   Spaltenbeschriftung zweite Spalte\n0                    1             a\n1                    2             5\n2                    3             g\n\n\n\n\n\n\n\n\nTipp 1.2: Der Index\n\n\n\n\n\nIn den meisten Fällen ist der von 0 bis n-1 reichende Index am praktischsten. Der numerische Index hilft bei der Auswahl von Indexbereichen (Slicing) und der Arbeit mit mehreren Datenstrukturen. Probieren Sie einmal aus, was passiert, wenn Sie einen DataFrame aus zwei Series mit unterschiedlichen Indizes erstellen.\nAuch widerspricht das Auslagern beschreibender oder gemessener Variablen in den Index dem Konzept tidy data, einem System zum Strukturieren von Datensätzen, das Sie im Methodenbaustein Einlesen strukturierter Datensätze kennenlernen.\n\n\n\nBestehende DataFrames können ähnlich wie Series modifiziert werden. Um den Datentyp einer oder mehrerer Spalten zu ändern, wird die Methode pd.DataFrame.astype() verwendet.\n\ndf = pd.DataFrame({'Spalte 1': ['1', '2', '3'], 'Spalte 2': [True, False, True]})\nprint(f\"Die Datentypen von df:\\n{df.dtypes}\")\n\n# Datentyp von Spalte 1 ändern\ndf['Spalte 1'] = df['Spalte 1'].astype('string')\nprint(f\"\\nDie Datentypen von df:\\n{df.dtypes}\")\n\nDie Datentypen von df:\nSpalte 1    object\nSpalte 2      bool\ndtype: object\n\nDie Datentypen von df:\nSpalte 1    string[python]\nSpalte 2              bool\ndtype: object\n\n\nEbenso kann allen Spalten eines DataFrames ein Datentyp zugewiesen werden.\n\ndf = df.astype('string')\nprint(f\"\\nDie Datentypen von df:\\n{df.dtypes}\")\n\n\nDie Datentypen von df:\nSpalte 1    string[python]\nSpalte 2    string[python]\ndtype: object\n\n\nUm unterschiedliche Datentypen zuzweisen, wird ein Dictionary verwendet.\n\ndf = df.astype({'Spalte 1': 'int', 'Spalte 2': 'bool'})\nprint(f\"\\nDie Datentypen von df:\\n{df.dtypes}\")\n\n\nDie Datentypen von df:\nSpalte 1    int64\nSpalte 2     bool\ndtype: object\n\n\nSpaltennamen und Index eines bestehenden DataFrame können über entsprechende Attribute oder Methoden verändert werden. Die Spaltennamen können über das Attribut pd.DataFrame.columns geändert werden. Dabei wird eine Liste übergeben, deren Länge der Spaltenanzahl entsprechen muss. Der Index kann über das Attribut pd.DataFrame.index geändert werden, indem eine Liste zugewiesen wird. Dabei muss die Länge der Liste der Anzahl Zeilen entsprechen.\n\n# ändern der Spaltennamen über das Attribut .columns\ndf.columns = ['Spalte1', 'Spalte2']\ndf.index = [1, 2, 3]\nprint(df)\n\n   Spalte1  Spalte2\n1        1     True\n2        2     True\n3        3     True\n\n\nMit der Methode pd.DataFrame.rename(columns = {\"alt1\": \"neu1\", \"alt2\": \"neu2\"}, index = {\"alt1\": \"neu1\", \"alt2\": \"neu2\"}, inplace = True) können Spalten- und Zeilenbeschriftungen in Form eines Dictionarys übergeben werden. Auf diese Weise können alle oder ausgewählte Beschriftungen geändert werden. Durch das Argument inplace = True erfolgt die Zuweisung direkt ohne Neuzuweisung des Objekts.\n\ndf.rename(columns = {'Spalte1': 'Spalte_1', 'Spalte2': 'Spalte_2'}, index = {1: 'A1', 2: 'B2', 3: 'C3'}, inplace = True)\nprint(df)\n\n    Spalte_1  Spalte_2\nA1         1      True\nB2         2      True\nC3         3      True\n\n\nMit der Methode pd.DataFrame.reset_index(inplace = True, drop = True) wird der Index auf die Standardwerte zurückgesetzt. Wird der Parameter drop = False gesetzt, wird der alte Index als Spalte an Indexposition 0 in den DataFrame eingefügt.\n\ndf.reset_index(inplace = True, drop = True)\nprint(df)\n\n   Spalte_1  Spalte_2\n0         1      True\n1         2      True\n2         3      True\n\n\n\n\nAufgabe DataFrame\nErstellen Sie einen DataFrame.\n\nDie erste Spalte soll die Zahlen von 1 bis 12 enthalten und mit ‘Nummer’ beschriftet werden. Die zweite Spalte soll die Monatsnamen des Jahres enthalten und mit ‘Monat’ beschriftet werden.\nFügen Sie nachträglich die Series ‘ferien’ als dritte Spalte mit der Spaltenbeschriftung ‘Ferien’ ein.\nferien = [False, False, False, True, False, True, True, True, False, True, False, True]\n\n\n\n\n\n\n\nTipp 1.3: Musterlösung\n\n\n\n\n\n\nferien = [False, False, False, True, False, True, True, True, False, True, False, True]\n\ndf = pd.DataFrame({\n  'Nummer': list(range(1,13)),\n  'Monat': ['Januar', 'Februar', 'März', 'April', 'Mai', 'Juni', 'Juli', 'August', 'September', 'Oktober', 'November', 'Dezember'],\n})\n\ndf['Ferien'] = ferien\n\nprint(df)\n\n    Nummer      Monat  Ferien\n0        1     Januar   False\n1        2    Februar   False\n2        3       März   False\n3        4      April    True\n4        5        Mai   False\n5        6       Juni    True\n6        7       Juli    True\n7        8     August    True\n8        9  September   False\n9       10    Oktober    True\n10      11   November   False\n11      12   Dezember    True",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Einleitung</span>"
    ]
  },
  {
    "objectID": "skript/einleitung.html#deskriptive-datenanalyse-mit-pandas",
    "href": "skript/einleitung.html#deskriptive-datenanalyse-mit-pandas",
    "title": "1  Einleitung",
    "section": "1.2 Deskriptive Datenanalyse mit Pandas",
    "text": "1.2 Deskriptive Datenanalyse mit Pandas\nPandas bietet einige praktische Funktionen, um den Aufbau eines Datensatzes und die enthaltenen Daten zu beschreiben. Als Beispieldatensatz dienen Daten zur Länge zahnbildender Zellen bei Meerschweinchen, die Vitamin C direkt (VC) oder in Form von Orangensaft (OJ) in unterschiedlichen Dosen erhielten.\n\n\n\n\n\ndateipfad = \"01-daten/ToothGrowth.csv\"\nmeerschweinchen = pd.read_csv(filepath_or_buffer = dateipfad, sep = ',', header = 0, \\\n  names = ['ID', 'len', 'supp', 'dose'], dtype = {'ID': 'int', 'len': 'float', 'dose': 'float', 'supp': 'category'})\n\n\n\nCode-Block 1.1\n\n\n\nCrampton, E. W. 1947. „THE GROWTH OF THE ODONTOBLASTS OF THE INCISOR TOOTH AS A CRITERION OF THE VITAMIN C INTAKE OF THE GUINEA PIG“. The Journal of Nutrition 33 (5): 491–504. https://doi.org/10.1093/jn/33.5.491\nDer Datensatz kann in R mit dem Befehl “ToothGrowth” aufgerufen werden.\n\n \nEin Aussschnitt des Datensatzes:\n\n\n\n\n\n\n\n\n\nID\nlen\nsupp\ndose\n\n\n\n\n0\n1\n4.2\nVC\n0.5\n\n\n10\n11\n16.5\nVC\n1.0\n\n\n20\n21\n23.6\nVC\n2.0\n\n\n30\n31\n15.2\nOJ\n0.5\n\n\n40\n41\n19.7\nOJ\n1.0\n\n\n50\n51\n25.5\nOJ\n2.0\n\n\n\n\n\n\n\n \nDie Methode pd.DataFrame.info() erzeugt eine Beschreibung des Datensatzes.\n\nmeerschweinchen.info()\n\n&lt;class 'pandas.core.frame.DataFrame'&gt;\nRangeIndex: 60 entries, 0 to 59\nData columns (total 4 columns):\n #   Column  Non-Null Count  Dtype   \n---  ------  --------------  -----   \n 0   ID      60 non-null     int64   \n 1   len     60 non-null     float64 \n 2   supp    60 non-null     category\n 3   dose    60 non-null     float64 \ndtypes: category(1), float64(2), int64(1)\nmemory usage: 1.7 KB\n\n\nDie Dimensionen einer Series oder eines DataFrame können mit dem Attribut shape abgerufen werden. Der DataFrame hat 60 Zeilen und 4 Spalten.\n\nprint(meerschweinchen.shape)\n\n(60, 4)\n\n\nDie Methode pd.DataFrame.describe() erzeugt eine beschreibende Statistik für einen DataFrame. Standardmäßig werden alle numerischen Spalten berücksichtigt. Mit dem Parameter include können die zu berücksichtigenden Spalten vorgegeben werden. include = all berücksichtigt alle Spalten, was nicht unbedingt sinnvoll ist, da auf diese Weise auch die Spalte mit den ID-Nummern der Meerschweinchen ausgewertet wird.\n\nprint(meerschweinchen.describe(include = 'all'))\n\n               ID        len supp       dose\ncount   60.000000  60.000000   60  60.000000\nunique        NaN        NaN    2        NaN\ntop           NaN        NaN   OJ        NaN\nfreq          NaN        NaN   30        NaN\nmean    30.500000  18.813333  NaN   1.166667\nstd     17.464249   7.649315  NaN   0.628872\nmin      1.000000   4.200000  NaN   0.500000\n25%     15.750000  13.075000  NaN   0.500000\n50%     30.500000  19.250000  NaN   1.000000\n75%     45.250000  25.275000  NaN   2.000000\nmax     60.000000  33.900000  NaN   2.000000\n\n\nMit dem Parameter include kann eine Liste zu berücksichtigender Datentypen übergeben werden. Der Parameter exclude schließt auf die gleiche Weise Datentypen von der Ausgabe aus.\n\nprint(meerschweinchen.describe(include = ['float']))\n\n             len       dose\ncount  60.000000  60.000000\nmean   18.813333   1.166667\nstd     7.649315   0.628872\nmin     4.200000   0.500000\n25%    13.075000   0.500000\n50%    19.250000   1.000000\n75%    25.275000   2.000000\nmax    33.900000   2.000000\n\n\n\nprint(meerschweinchen.describe(include = ['category']))\n\n       supp\ncount    60\nunique    2\ntop      OJ\nfreq     30\n\n\nDie Methode pd.DataFrame.count() zählt alle nicht fehlenden Werte in jeder Spalte oder mit pd.DataFrame.count(axis = 'columns') in jeder Zeile.\n\nmeerschweinchen.count(axis = 'rows') # der Standardwert von axis ist 'rows'\n\nID      60\nlen     60\nsupp    60\ndose    60\ndtype: int64\n\n\nDie Methode pd.Series.value_counts() zählt die Anzahl der Merkmalsausprägungen in einer Series. Die Methode kann auch auf einen DataFrame angewendet werden, dann wird die Häufigkeit jeder einzigartigen Zeile gezählt (was hier nicht sinnvoll ist).\n\nmeerschweinchen['dose'].value_counts()\n\ndose\n0.5    20\n1.0    20\n2.0    20\nName: count, dtype: int64\n\n\nDie Methode pd.unique() listet alle einzigartigen Werte einer Series auf.\n\nmeerschweinchen['dose'].unique()\n\narray([0.5, 1. , 2. ])",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Einleitung</span>"
    ]
  },
  {
    "objectID": "skript/einleitung.html#slicing",
    "href": "skript/einleitung.html#slicing",
    "title": "1  Einleitung",
    "section": "1.3 Slicing",
    "text": "1.3 Slicing\n\n\n\n\nzweidimensionaler Datensatz\n\n\nslicing von Marc Fehr ist lizensiert unter CC-BY-4.0 und abrufbar auf GitHub. Die Grafik wurde auf den gezeigten Teil beschnitten und die obenstehende Beschriftung entfernt. 2024\n\n \nPandas bringt eigene Werkzeuge für die Auswahl von Indexbereichen mit. Der Slice Operator aus der Pythonbasis wird deshalb nur kurz vorgestellt.\n\nSlice Operator\nMit dem Slice Operator können wie bei einer Liste Indexbereiche aus einer Series ausgewählt werden.\n\nzehn_zahlen = pd.Series(range(0, 10))\nprint(zehn_zahlen[3:6])\n\n3    3\n4    4\n5    5\ndtype: int64\n\n\nMit dem Slice Operator werden die Zeilen eines DataFrames ausgewählt.\n\nprint(meerschweinchen[7:12])\n\n    ID   len supp  dose\n7    8  11.2   VC   0.5\n8    9   5.2   VC   0.5\n9   10   7.0   VC   0.5\n10  11  16.5   VC   1.0\n11  12  16.5   VC   1.0\n\n\nDurch Angabe eines Spaltennamens wird die entsprechende Spalte ausgewählt, die als Series zurückgegeben wird. Durch das Anfügen eines zweiten Slice Operators ist es möglich, wie bei einem eindimensionalen Datensatz die Werte in einem bestimmten Indexbereich abzurufen. Dies wird verkettete Indexierung genannt.\n\nprint(meerschweinchen['dose'][10:15], \"\\n\")\nprint(type(meerschweinchen['dose'][10:15]))\n\n10    1.0\n11    1.0\n12    1.0\n13    1.0\n14    1.0\nName: dose, dtype: float64 \n\n&lt;class 'pandas.core.series.Series'&gt;\n\n\n\n\n\n\n\n\nHinweis 1.1: Verkettete Indexierung\n\n\n\nDie verkettete Indexierung erzeugt in Pandas abhängig vom Kontext eine Kopie des Objekts oder greift auf den Speicherbereich des Objekts zu. Mit Pandas 3.0 wird die verkettete Indexierung nicht mehr unterstützt, das Anlegen einer Kopie wird zum Standard werden. Weitere Informationen erhalten Sie im zitierten Link.\n\n\n\n\n\n\n \n\n\n“Whether a copy or a reference is returned for a setting operation, may depend on the context. This is sometimes called chained assignment and should be avoided. See Returning a View versus Copy.”\n\n\n \n\n\n\n(Pandas Dokumentation)\n\n\n\n\nSlicing mit Pandas-Methoden\nFür das Slicing von Series und DataFrames werden in Pandas die Methoden .iloc[] und .loc[] verwendet.\n\n.loc[] arbeitet mit Index- oder Spaltenbeschriftungen, akzeptiert aber auch ein boolsches Array.\n.iloc[] arbeitet mit Ganzzahlen, akzeptiert aber auch ein boolsches Array.\n\nFür das Slicing von Series wird eine Bereichsangabe übergeben, bspw. pd.Series.iloc[5:8]. Für das Slicing von DataFrames werden zwei durch ein Komma getrennte Bereichsangaben übergeben, wobei an erster Stelle die Zeilen und an zweiter Stelle die Spalten ausgewählt werden, bspw. pd.DataFrame.iloc[5, 2:4]. Um alle Zeilen oder Spalten auszuwählen kann der Doppelpunkt verwendet werden, etwa pd.DataFrame.iloc[5, :].\n\nBeschriftungsbasiertes Slicing mit .loc[]\nFür eine Series interpretiert .loc übergebene Zeichen als Indexbeschriftung. Buchstaben und andere Zeichen werden wie strings in Anführungszeichen übergeben, bspw. .loc['e'], Zahlen ohne Anführungszeichen. Neben Einzelwerten ('a' oder 0) können Listen oder Arrays (['a', 'b', 'c'] oder [1, 2, 3]) und Slices übergeben werden ('a':'c' oder 0:2). Das Slicing mit einem Einzelwert führt zur Rückgabe eines Einzelwerts (sog. Skalar).\n\n\n\n\n\n\nHinweis 1.2: inklusives Slicing\n\n\n\nAnders als die Pythonbasis und das Slicing mit .iloc[] zählt Pandas beim beschriftungsbasiertem Slicing inklusiv, gibt also die letzte ausgewählte Position mit aus.\n\n\n\n# Nummern\nzehn_zahlen = pd.Series(range(0, 10))\nprint(\"Rückgabe eines Einzelwerts:\", zehn_zahlen.loc[5]) # Einzelwert\nprint(zehn_zahlen.loc[[2, 4, 7]]) # Liste\nprint(zehn_zahlen.loc[5:7], \"\\n\") # Slice\n\n# Buchstaben und andere Zeichen\nsechs_zahlen = pd.Series(list(range(0, 6)), index = ['a', 'b', 'c', 'd', 'e', 'f'])\nprint(\"Rückgabe eines Einzelwerts:\", sechs_zahlen.loc['c']) # Einzelwert\nprint(sechs_zahlen.loc[['c', 'f', 'a']]) # Liste\nprint(sechs_zahlen.loc['c':'e']) # Slice\n\nRückgabe eines Einzelwerts: 5\n2    2\n4    4\n7    7\ndtype: int64\n5    5\n6    6\n7    7\ndtype: int64 \n\nRückgabe eines Einzelwerts: 2\nc    2\nf    5\na    0\ndtype: int64\nc    2\nd    3\ne    4\ndtype: int64\n\n\nDie Interpretation als Beschriftung bedeutet, dass bei einem nicht numerischen Index, übergebene Zahlen nicht gefunden werden.\n\ntry:\n  print(sechs_zahlen.loc[2:4])\nexcept Exception as error:\n  print(error)\n\ncannot do slice indexing on Index with these indexers [2] of type int\n\n\nFür DataFrames funktioniert das Slicing genauso.\n\nprint(meerschweinchen.loc[18:22, ['len', 'dose']])\n\n     len  dose\n18  18.8   1.0\n19  15.5   1.0\n20  23.6   2.0\n21  18.5   2.0\n22  33.9   2.0\n\n\n\n\n\nIndexbasiertes Slicing mit .iloc[]\nDie Methode .iloc[] ermöglicht die Auswahl von Ausschnitten basierend auf Indexpositionen. Die Methode akzeptiert die gleichen Eingaben wie die Methode .loc[].\n\n\n\n\n\n\nHinweis 1.3: exklusives Slicing\n\n\n\nBeim Slicing mit der Methode .iloc[] zählt Pandas wie die Pythonbasis exklusiv.\n\n\nDas Slicing mit Einzelwerten führt zur Ausgabe eines Einzelwertes. Die Methode akzeptiert ebenfalls eine Liste oder ein Slice.\n\nprint(\"Rückgabe eines Einzelwerts:\", meerschweinchen.iloc[27, 2]) # Einzelwerte\nprint(meerschweinchen.iloc[[27, 29, 52], 2:4]) # Liste und Slice\n\nRückgabe eines Einzelwerts: VC\n   supp  dose\n27   VC   2.0\n29   VC   2.0\n52   OJ   2.0\n\n\n\nDie Methoden .head() und .tail()\nVereinfachte Varianten des indexbasierten Slicings sind die Methoden .head(n=5) und .tail(n=5), mit denen die ersten bzw. letzten n Zeilen eines DataFrame oder einer Series ausgegeben werden können. Über den optionalen Paramenter n kann die Anzahl der angezeigten Zeilen gesteuert werden. Die Methoden eignen sich gut, um sich einen ersten Eindruck von einem Datensatz zu verschaffen.\n\nprint(meerschweinchen.head(3), \"\\n\")\nprint(meerschweinchen.tail(3))\n\n   ID   len supp  dose\n0   1   4.2   VC   0.5\n1   2  11.5   VC   0.5\n2   3   7.3   VC   0.5 \n\n    ID   len supp  dose\n57  58  27.3   OJ   2.0\n58  59  29.4   OJ   2.0\n59  60  23.0   OJ   2.0\n\n\nEbenso können Series damit betrachtet werden.\n\nprint(meerschweinchen['len'].tail(3))\n\n57    27.3\n58    29.4\n59    23.0\nName: len, dtype: float64",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Einleitung</span>"
    ]
  },
  {
    "objectID": "skript/einleitung.html#aufgaben-slicing",
    "href": "skript/einleitung.html#aufgaben-slicing",
    "title": "1  Einleitung",
    "section": "1.4 Aufgaben Slicing",
    "text": "1.4 Aufgaben Slicing\n\nGegeben ist eine Pandas Series ‘temperaturen_2021’ mit den durchschnittlichen Monatstemperaturen. Wählen Sie die Temperaturen für die Frühlingsmonate (März bis Mai) aus.\n\n\ntemperaturen_2021 = pd.Series([2, 4, 7, 12, 19, 23, 25, 23, 18, 15, 9, 5],\n                         index = ['Jan', 'Feb', 'Mär', 'Apr', 'Mai', 'Jun', \n                         'Jul', 'Aug', 'Sep', 'Okt', 'Nov', 'Dez'])\n\n\nWählen Sie die Temperaturen für die letzten drei Monate des Jahres einmal mit Hilfe des Slicing Operators und einmal mit Hilfe der Pandas-Methoden aus.\nWählen Sie mit der Methode .loc[] die Spalten ‘dose’ und ‘len’ des DataFrame meerschweinchen aus und geben Sie die ersten 4 und die letzten 3 Zeilen aus. (Code zum Einlesen der Datei siehe Code-Block 1.1)\nDie Methoden .loc[] und .iloc[] akzeptieren auch ein boolsches Array als Eingabe. Geben Sie aus der Spalte ‘dose’ des DataFrame meerschweinchen alle Zeilen mit dem Wert 2.0 aus.\n\n\n\n\n\n\n\nTipp 1.4: Musterlösung Slicing\n\n\n\n\n\nAufgabe 1\n\nprint(temperaturen_2021.loc[['Mär', 'Apr', 'Mai']])\n\nMär     7\nApr    12\nMai    19\ndtype: int64\n\n\nAufgabe 2\n\nprint(temperaturen_2021[len(temperaturen_2021)-3:], \"\\n\")\nprint(temperaturen_2021.iloc[len(temperaturen_2021)-3:])\n\nOkt    15\nNov     9\nDez     5\ndtype: int64 \n\nOkt    15\nNov     9\nDez     5\ndtype: int64\n\n\nAufgabe 3\n\nprint(meerschweinchen.loc[ :, ['dose', 'len']].head(n = 4), \"\\n\")\nprint(meerschweinchen.loc[ :, ['dose', 'len']].tail(n = 3))\n\n   dose   len\n0   0.5   4.2\n1   0.5  11.5\n2   0.5   7.3\n3   0.5   5.8 \n\n    dose   len\n57   2.0  27.3\n58   2.0  29.4\n59   2.0  23.0\n\n\nAufgabe 4\n\n# Slice aus Series\n# print(meerschweinchen['dose'].loc[meerschweinchen['dose'] == 2.0])\n\n# Slice aus DataFrame\nprint(meerschweinchen.loc[meerschweinchen['dose'] == 2.0, ['dose']])\n\n    dose\n20   2.0\n21   2.0\n22   2.0\n23   2.0\n24   2.0\n25   2.0\n26   2.0\n27   2.0\n28   2.0\n29   2.0\n50   2.0\n51   2.0\n52   2.0\n53   2.0\n54   2.0\n55   2.0\n56   2.0\n57   2.0\n58   2.0\n59   2.0",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Einleitung</span>"
    ]
  },
  {
    "objectID": "skript/einleitung.html#datenstrukturen-verbinden",
    "href": "skript/einleitung.html#datenstrukturen-verbinden",
    "title": "1  Einleitung",
    "section": "1.5 Datenstrukturen verbinden",
    "text": "1.5 Datenstrukturen verbinden\nDataFrames sind flexible Datenspeicher. Mit der Funktion pd.concat() können Series und DataFrames zusammengeführt werden.\n\nMit dem Argument pd.concat(ignore_index = True) wird ein neuer Index generiert.\nMit dem Argument pd.concat(axis = 1) werden die übergebenen objekte spaltenweise zusammengeführt.\n\n\nseries_1 = pd.Series([1, 2])\nseries_2 = pd.Series([4, 5])\nprint(pd.concat([series_1, series_2]), \"\\n\")\nprint(pd.concat([series_1, series_2], ignore_index = True), \"\\n\")\nprint(pd.concat([series_1, series_2], ignore_index = True, axis = 1))\n\n0    1\n1    2\n0    4\n1    5\ndtype: int64 \n\n0    1\n1    2\n2    4\n3    5\ndtype: int64 \n\n   0  1\n0  1  4\n1  2  5\n\n\nGleichermaßen können DataFrames verbunden werden.\n\ntemperaturen_2022 = pd.Series([3, 6, 9, 13, 18, 21, 24, 23, 19, 14, 8, 4],\n                         index = ['Jan', 'Feb', 'Mär', 'Apr', 'Mai', 'Jun', \n                         'Jul', 'Aug', 'Sep', 'Okt', 'Nov', 'Dez'])\n\ntemperaturen_2023 = pd.Series([-3, -1, 4, 9, 15, 20, 20, 19, 16, 15, 7, 6],\n                         index = ['Jan', 'Feb', 'Mär', 'Apr', 'Mai', 'Jun', \n                         'Jul', 'Aug', 'Sep', 'Okt', 'Nov', 'Dez'])\n\ntemperaturen_2024 = pd.Series([-1, 2, 5, 8, 17, 24, 25, 20, 17, 14, 9, 2],\n                         index = ['Jan', 'Feb', 'Mär', 'Apr', 'Mai', 'Jun', \n                         'Jul', 'Aug', 'Sep', 'Okt', 'Nov', 'Dez'])\n\n# Series zu DataFrame verbinden\ndf1 = pd.concat([temperaturen_2021, temperaturen_2022], axis = 1)\ndf2 = pd.concat([temperaturen_2023, temperaturen_2024], axis = 1)\n\n# DataFrames verbinden\ntemperaturen = pd.concat([df1, df2], axis = 1)\ntemperaturen.columns = [2021, 2022, 2023, 2024]\nprint(temperaturen)\n\n     2021  2022  2023  2024\nJan     2     3    -3    -1\nFeb     4     6    -1     2\nMär     7     9     4     5\nApr    12    13     9     8\nMai    19    18    15    17\nJun    23    21    20    24\nJul    25    24    20    25\nAug    23    23    19    20\nSep    18    19    16    17\nOkt    15    14    15    14\nNov     9     8     7     9\nDez     5     4     6     2",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Einleitung</span>"
    ]
  },
  {
    "objectID": "skript/einleitung.html#einfügen-und-löschen-in-datenstrukturen",
    "href": "skript/einleitung.html#einfügen-und-löschen-in-datenstrukturen",
    "title": "1  Einleitung",
    "section": "1.6 Einfügen und löschen in Datenstrukturen",
    "text": "1.6 Einfügen und löschen in Datenstrukturen\nDer Operator del aus der Pythonbasis löscht Spalten aus einem DataFrame del DataFrame['Spaltenname']. Pandas bringt aber auch eigene Methoden mit, um Einträge zeilen- / oder spaltenweise zu ergänzen und zu löschen.\n\npd.DataFrame.drop(labels = None, axis = 0, index = None, columns = None, inplace = False) entfernt Zeilen oder Spalten nach den mit dem Parameter labels als Einzelwert ('Spalte 1') oder als Liste (['Spalte 1', 'Spalte 2']) übergebenen Beschriftungen. Der Parameter axis steuert, ob Zeilen oder Spalten (axis = 1) entfernt werden sollen. Die Parameter index und columns sind alternative Möglichkeiten, Index- oder Spaltenbeschriftungen direkt zu übergeben und ersetzen die Parameter labels und axis.\npd.DataFrame.insert(loc, column, value) fügt eine Spalte an Position loc mit dem Spaltennamen column und dem Inhalt value ein. Falls value eine Series mit abweichendem Index ist, kann über das Attribut value = Series.values auf die enthaltenen Werte der Series zugegriffen und diese in den bestehenden Index einfgefügt werden (andernfalls gleicht Pandas die Indizes der Series und des DataFrames ab und fügt nur die Werte übereinstimmender Indizes ein).\nWerte können zeilenweise mit der Methode pd.DataFrame.loc[index] = value eingefügt werden. Falls value eine Series ist, muss über das Attribut value = Series.values auf die enthaltenen Werte der Series zugegriffen werden, da Pandas andernfalls versucht, den Index der Series mit den Spaltennamen des DataFrames abzugleichen. Wird als value ein Einzelwert übergeben, füllt dieser die gesamte Zeile aus.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Einleitung</span>"
    ]
  },
  {
    "objectID": "skript/einleitung.html#aufgaben-verbinden-und-löschen",
    "href": "skript/einleitung.html#aufgaben-verbinden-und-löschen",
    "title": "1  Einleitung",
    "section": "1.7 Aufgaben verbinden und löschen",
    "text": "1.7 Aufgaben verbinden und löschen\nLegen Sie einen leeren DataFrame df = pd.DataFrame() an.\n\nFügen Sie die Spalten ‘len’ und ‘dose’ aus dem DataFrame ‘meerschweinchen’ ein.\nLöschen Sie alle ungeraden Zeilennummern aus dem DataFrame df.\nBenutzen Sie die Indexnummern des DataFrame df, um die entsprechenden Zeilen aus der Spalte ‘ID’ des DataFrame ‘meerschweinchen’ auszuwählen. Fügen Sie diese als Spalte an Indexposition 0 in den DataFrame df ein.\n\n\n\n\n\n\n\nTipp 1.5: Musterlösung verbinden und löschen\n\n\n\n\n\n\nAufgabe\n\n\ndf = pd.DataFrame()\n\n# Alternative 1\ndf['len'] = meerschweinchen['len']\n\n# Alternative 2\ndf.insert(loc = 1, column = 'dose', value = meerschweinchen['dose'])\n\nprint(df.head(), \"\\n\", df.shape)\n\n    len  dose\n0   4.2   0.5\n1  11.5   0.5\n2   7.3   0.5\n3   5.8   0.5\n4   6.4   0.5 \n (60, 2)\n\n\n\nAufgabe\n\n\ndf = df.drop(index = range(1, len(df), 2))\n\nprint(df.head(), \"\\n\", df.shape)\n\n    len  dose\n0   4.2   0.5\n2   7.3   0.5\n4   6.4   0.5\n6  11.2   0.5\n8   5.2   0.5 \n (30, 2)\n\n\n\nAufgabe\n\n\ndf.insert(loc = 0, column = 'ID', value = meerschweinchen.loc[df.index, 'ID'])\n\nprint(df.head(), \"\\n\")\nprint(df.tail(), \"\\n\")\nprint(\"df.shape:\", df.shape)\n\n   ID   len  dose\n0   1   4.2   0.5\n2   3   7.3   0.5\n4   5   6.4   0.5\n6   7  11.2   0.5\n8   9   5.2   0.5 \n\n    ID   len  dose\n50  51  25.5   2.0\n52  53  22.4   2.0\n54  55  24.8   2.0\n56  57  26.4   2.0\n58  59  29.4   2.0 \n\ndf.shape: (30, 3)",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Einleitung</span>"
    ]
  },
  {
    "objectID": "skript/einleitung.html#quellen",
    "href": "skript/einleitung.html#quellen",
    "title": "1  Einleitung",
    "section": "Quellen",
    "text": "Quellen\nhttps://pandas.pydata.org/docs/user_guide/dsintro.html https://pandas.pydata.org/docs/user_guide/basics.html",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Einleitung</span>"
    ]
  },
  {
    "objectID": "skript/operationen.html",
    "href": "skript/operationen.html",
    "title": "2  Operationen",
    "section": "",
    "text": "2.1 Zeilen- und spaltenweise Operationen\nPandas erlaubt wie NumPy vektorisierte Operationen, dass heißt, Berechnungen mit einer Series oder einem DataFrame werden auf jedes Element angewendet. So können die Rechenoperatoren direkt verwendet werden.\nAuch boolsche Operationen können direkt ausgeführt werden.\nPandas umfasst eine Vielzahl von Methoden, die arithmetische, summarische, boolsche und Indexfunktionen umsetzen. Eine vollständige Übersicht finden Sie hier: https://pandas.pydata.org/docs/reference/index.html.\nIn der Regel werden die Funktionen standardmäßig spaltenweise angewendet. Mit dem Argument axis = 1 wird die jeweilige Funktion zeilenweise ausgeführt. Die Funktionen sind auch für Series verfügbar.\nIm Folgenden werden einige Methoden exemplarisch vorgestellt.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Operationen</span>"
    ]
  },
  {
    "objectID": "skript/operationen.html#zeilen--und-spaltenweise-operationen",
    "href": "skript/operationen.html#zeilen--und-spaltenweise-operationen",
    "title": "2  Operationen",
    "section": "",
    "text": "arithmetische Funktionen\nDie Methoden pd.DataFrame.add(), pd.DataFrame.sub(), pd.DataFrame.mul(), pd.DataFrame.div(), pd.DataFrame.floordiv(), pd.DataFrame.mod() und pd.DataFrame.pow() entsprechen den Grundrechenarten mit den Operatoren +, -, *, /, //, %, **. Sie eignen sich gut für verkettete Operationen.\n\nprint(\"Temperaturen in Fahrenheit:\")\nprint(27 * \"=\")\nprint(temperaturen.mul(9).div(5).add(32))\n\nTemperaturen in Fahrenheit:\n===========================\n     2021  2022  2023  2024\nJan  35.6  37.4  26.6  30.2\nFeb  39.2  42.8  30.2  35.6\nMär  44.6  48.2  39.2  41.0\nApr  53.6  55.4  48.2  46.4\nMai  66.2  64.4  59.0  62.6\nJun  73.4  69.8  68.0  75.2\nJul  77.0  75.2  68.0  77.0\nAug  73.4  73.4  66.2  68.0\nSep  64.4  66.2  60.8  62.6\nOkt  59.0  57.2  59.0  57.2\nNov  48.2  46.4  44.6  48.2\nDez  41.0  39.2  42.8  35.6\n\n\nAußerdem kann mit dem Parameter fill_value ein Füllwert für fehlende Werte spezifiziert werden (dieser wird vor der Operation eingesetzt). Wie NumPys np.nan umfasst auch Pandas einen speziellen fehlenden Wert: pd.NA (achten Sie auf den Datentyp der Ausgabe). Der Umgang mit fehlenden Werten wird ausführlich im Methodenbaustein Einlesen strukturierter Datensätze behandelt.\n\nmissing_value = pd.Series([1, pd.NA, 3])\nprint(missing_value.add(1, fill_value = -999), \"\\n\")\nprint(missing_value.add(1, fill_value = np.nan), \"\\n\")\nprint(missing_value.add(1, fill_value = pd.NA))\n\n0      2\n1   -998\n2      4\ndtype: int64 \n\n0    2.0\n1    NaN\n2    4.0\ndtype: float64 \n\n0       2\n1    &lt;NA&gt;\n2       4\ndtype: object\n\n\n\n\nsummarische Funktionen\n\npd.DataFrame.mean() ermittelt den Durchschnitt.\npd.DataFrame.median() ermittelt den Median.\npd.DataFrame.mode() ermittelt den Modus.\npd.DataFrame.sum() ermittelt die Summe.\npd.DataFrame.cumsum() ermittelt die kummulierte Summe.\npd.DataFrame.min() und pd.DataFrame.max() ermitteln Minimum bzw. Maximum.\npd.DataFrame.cummin() und pd.DataFrame.cummax() ermittelt das kummulierte Minimum bzw. Maximum.\n\n\n# spaltenweise\nprint(\"Mittlere Jahrestemperaturen\")\nprint(27 * \"=\")\nprint(temperaturen.mean(), \"\\n\")\n\n# zeilenweise\nprint(\"Monatliche Mindesttemperatur\")\nprint(28 * \"=\")\nprint(temperaturen.min(axis = 1))\n\nMittlere Jahrestemperaturen\n===========================\n2021    13.500000\n2022    13.500000\n2023    10.583333\n2024    11.833333\ndtype: float64 \n\nMonatliche Mindesttemperatur\n============================\nJan    -3\nFeb    -1\nMär     4\nApr     8\nMai    15\nJun    20\nJul    20\nAug    19\nSep    16\nOkt    14\nNov     7\nDez     2\ndtype: int64\n\n\n\n\nboolsche Funktionen\nPandas bietet wie die Pythonbasis verschiedene boolsche Funktionen.\npd.DataFrame.isin(values) prüft für jedes Element des DataFrame, ob dieses in values enthalten ist. Mit dem Operator ~ kann geprüft werden, ob die Elemente eines DataFrame nicht in values enthalten sind: ~pd.DataFrame.isin(values).\nDie Funktionsausführung ist abhängig vom Datentyp des in values übergebenen Objekts.\n\nWenn values eine Liste oder ein NumPy-Array ist, ist das Ergebnis True, wenn es eine Übereinstimmung mit einem der enthaltenen Elemente gibt.\nIst value eine Series oder ein DataFrame, wird die Übereinstimmung positionsbasiert überprüft (siehe Beispiel).\n\n\n\n\n\n\n\nBeispiel 2.1: klassenabhängige Funktionsausführung\n\n\n\n\n\n\nEinzelwerte oder ListeNumPy-ArraySeriesDataFrame\n\n\nFür Einzelwerte oder eine Liste wird die Übereinstimmung elementweise überprüft.\n\nprint(temperaturen, \"\\n\")\n\nprint(temperaturen.isin([2, 3]))\n\n     2021  2022  2023  2024\nJan     2     3    -3    -1\nFeb     4     6    -1     2\nMär     7     9     4     5\nApr    12    13     9     8\nMai    19    18    15    17\nJun    23    21    20    24\nJul    25    24    20    25\nAug    23    23    19    20\nSep    18    19    16    17\nOkt    15    14    15    14\nNov     9     8     7     9\nDez     5     4     6     2 \n\n      2021   2022   2023   2024\nJan   True   True  False  False\nFeb  False  False  False   True\nMär  False  False  False  False\nApr  False  False  False  False\nMai  False  False  False  False\nJun  False  False  False  False\nJul  False  False  False  False\nAug  False  False  False  False\nSep  False  False  False  False\nOkt  False  False  False  False\nNov  False  False  False  False\nDez  False  False  False   True\n\n\n\n\nFür ein NumPy-Array wird die Übereinstimmung elementweise überprüft (vergleiche zum nächsten Reiter).\n\nprint(type(temperaturen[2021].values), \"\\n\")\n\nprint(temperaturen.isin(temperaturen[2021].values))\n\n&lt;class 'numpy.ndarray'&gt; \n\n     2021   2022   2023   2024\nJan  True  False  False  False\nFeb  True  False  False   True\nMär  True   True   True   True\nApr  True  False   True  False\nMai  True   True   True  False\nJun  True  False  False  False\nJul  True  False  False   True\nAug  True   True   True  False\nSep  True   True  False  False\nOkt  True  False   True  False\nNov  True  False   True   True\nDez  True   True  False   True\n\n\n\n\nFür eine Series wird die Übereinstimmung positionsweise geprüft (vergleiche zum vorherigen Reiter). Der Index muss übereinstimmen.\n\nprint(temperaturen.isin(temperaturen[2021]), \"\\n\")\n\ntemperaturen_2021_falscher_index = pd.Series([2, 4, 7, 12, 19, 23, 25, 23, 18, 15, 9, 5])\ntemperaturen_2021_falscher_index.index = ['A', 'B', 'C', 'D', 'E', 'F', 'Jul', 'Aug', 'Sep', 'Okt', 'Nov', 'Dez']\n\nprint(\"Der Index der Series lautet:\\n['A', 'B', 'C', 'D', 'E', 'F', 'Jul', 'Aug', 'Sep', 'Okt', 'Nov', 'Dez'].\\nDas Ergebnis an den Indexpositionen A-F ist immer False.\")\nprint(temperaturen.isin(temperaturen_2021_falscher_index))\n\n     2021   2022   2023   2024\nJan  True  False  False  False\nFeb  True  False  False  False\nMär  True  False  False  False\nApr  True  False  False  False\nMai  True  False  False  False\nJun  True  False  False  False\nJul  True  False  False   True\nAug  True   True  False  False\nSep  True  False  False  False\nOkt  True  False   True  False\nNov  True  False  False   True\nDez  True  False  False  False \n\nDer Index der Series lautet:\n['A', 'B', 'C', 'D', 'E', 'F', 'Jul', 'Aug', 'Sep', 'Okt', 'Nov', 'Dez'].\nDas Ergebnis an den Indexpositionen A-F ist immer False.\n      2021   2022   2023   2024\nJan  False  False  False  False\nFeb  False  False  False  False\nMär  False  False  False  False\nApr  False  False  False  False\nMai  False  False  False  False\nJun  False  False  False  False\nJul   True  False  False   True\nAug   True   True  False  False\nSep   True  False  False  False\nOkt   True  False   True  False\nNov   True  False  False   True\nDez   True  False  False  False\n\n\n\n\nFür einen DataFrame wird die Übereinstimmung positionsweise geprüft. Index und Spaltennamen müssen übereinstimmen (Index siehe Reiter Series).\n\ntemperaturen_2021_df = pd.DataFrame(temperaturen[2021])\nprint(temperaturen.isin(temperaturen_2021_df), \"\\n\")\n\ntemperaturen_2021_df.columns = [2035]\nprint(temperaturen.isin(temperaturen_2021_df), \"\\n\")\n\n     2021   2022   2023   2024\nJan  True  False  False  False\nFeb  True  False  False  False\nMär  True  False  False  False\nApr  True  False  False  False\nMai  True  False  False  False\nJun  True  False  False  False\nJul  True  False  False  False\nAug  True  False  False  False\nSep  True  False  False  False\nOkt  True  False  False  False\nNov  True  False  False  False\nDez  True  False  False  False \n\n      2021   2022   2023   2024\nJan  False  False  False  False\nFeb  False  False  False  False\nMär  False  False  False  False\nApr  False  False  False  False\nMai  False  False  False  False\nJun  False  False  False  False\nJul  False  False  False  False\nAug  False  False  False  False\nSep  False  False  False  False\nOkt  False  False  False  False\nNov  False  False  False  False\nDez  False  False  False  False \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTipp 2.1: Überraschungen vermeiden\n\n\n\nEine klassenabhängige Funktionsausführung kann, wenn das Verhalten unbemerkt bleibt, die Ergebnisse einer Datenanalyse verfälschen. Um dies zu verhindern, sollten Sie 3 allgemeine Ratschläge befolgen:\n\nSchauen Sie in die Dokumentation der jeweiligen Funktion. Python und viele Module entwickeln sich dynamisch, sodass sich das Verhalten einer Funktion verändern kann.\nGehen Sie schrittweise vor und lassen sich die Zwischenergebnisse von Arbeitsschritten mit der Funktion print() ausgeben.\nBei großen Datenmengen ist es häufig einfacher, mit eigens erzeugten Testdaten zu arbeiten. Ein zehnzeiliger DataFrame mit den Datentypen und der Struktur der Arbeitsdaten, ist leichter zu überblicken. Nutzen Sie einen solchen Testdatensatz um die von Ihnen verwendeten Funktionen zu überprüfen.\n\n\n\nEine Gruppe von Funktionen setzt logische Vergleiche um.\n\n\n\nFunktion\nVergleich\n\n\n\n\npd.DataFrame.lt(other)\nkleiner\n\n\npd.DataFrame.le(other)\nkleiner gleich\n\n\npd.DataFrame.eq(other)\ngleich\n\n\npd.DataFrame.ne(other)\nungleich\n\n\npd.DataFrame.ge(other)\ngrößer gleich\n\n\npd.DataFrame.gt(other)\ngrößer\n\n\n\n\nprint(temperaturen.le(2), \"\\n\")\nprint(temperaturen[2021].gt(5))\n\n      2021   2022   2023   2024\nJan   True  False   True   True\nFeb  False  False   True   True\nMär  False  False  False  False\nApr  False  False  False  False\nMai  False  False  False  False\nJun  False  False  False  False\nJul  False  False  False  False\nAug  False  False  False  False\nSep  False  False  False  False\nOkt  False  False  False  False\nNov  False  False  False  False\nDez  False  False  False   True \n\nJan    False\nFeb    False\nMär     True\nApr     True\nMai     True\nJun     True\nJul     True\nAug     True\nSep     True\nOkt     True\nNov     True\nDez    False\nName: 2021, dtype: bool\n\n\n\n\nVerwendung der Methoden .agg() und .apply()\nPandas bringt zwei eigene Methoden mit, um Operationen zeilen- oder spaltenweise auszuführen. DataFrame.agg() (oder auch DataFrame.aggregate()) aggregiert einen DataFrame zeilen- oder spaltenweise durch eine Funktion. Die Pandas-Methode DF.apply() wendet eine Funktion zeilen- oder spaltenweise auf einen DataFrame an. Die Methoden sind also sehr ähnlich und führen in den meisten Fällen zum selben Ergebnis.\nBeide Funktionen führen mit dem Argument axis = 1 Operationen zeilenweise aus.\n\nFunktionFunktionsnameListe von FunktionenDictionary von Funktionen\n\n\n\ndef my_plus_ten(x):\n  y = x + 10\n  return y\n\nprint(temperaturen.agg(my_plus_ten), \"\\n\")\nprint(temperaturen.apply(my_plus_ten))\n\n     2021  2022  2023  2024\nJan    12    13     7     9\nFeb    14    16     9    12\nMär    17    19    14    15\nApr    22    23    19    18\nMai    29    28    25    27\nJun    33    31    30    34\nJul    35    34    30    35\nAug    33    33    29    30\nSep    28    29    26    27\nOkt    25    24    25    24\nNov    19    18    17    19\nDez    15    14    16    12 \n\n     2021  2022  2023  2024\nJan    12    13     7     9\nFeb    14    16     9    12\nMär    17    19    14    15\nApr    22    23    19    18\nMai    29    28    25    27\nJun    33    31    30    34\nJul    35    34    30    35\nAug    33    33    29    30\nSep    28    29    26    27\nOkt    25    24    25    24\nNov    19    18    17    19\nDez    15    14    16    12\n\n\n\n\n\nprint(temperaturen.agg(\"sum\"), \"\\n\")\nprint(temperaturen.apply(\"sum\"))\n\n2021    162\n2022    162\n2023    127\n2024    142\ndtype: int64 \n\n2021    162\n2022    162\n2023    127\n2024    142\ndtype: int64\n\n\n\n\n\nprint(temperaturen.agg([\"sum\", \"mean\", \"median\"]), \"\\n\")\nprint(temperaturen.apply([\"sum\", \"mean\", \"median\"]))\n\n         2021   2022        2023        2024\nsum     162.0  162.0  127.000000  142.000000\nmean     13.5   13.5   10.583333   11.833333\nmedian   13.5   13.5   12.000000   11.500000 \n\n         2021   2022        2023        2024\nsum     162.0  162.0  127.000000  142.000000\nmean     13.5   13.5   10.583333   11.833333\nmedian   13.5   13.5   12.000000   11.500000\n\n\n\n\n\nprint(temperaturen.agg({2021: \"sum\", 2022: \"mean\", 2023: \"median\", 2024: \"min\"}), \"\\n\")\nprint(temperaturen.apply({2021: \"sum\", 2022: \"mean\", 2023: \"median\", 2024: \"min\"}), \"\\n\")\n\n2021    162.0\n2022     13.5\n2023     12.0\n2024     -1.0\ndtype: float64 \n\n2021    162.0\n2022     13.5\n2023     12.0\n2024     -1.0\ndtype: float64 \n\n\n\n\n\n\nBesonders nützlich ist die Möglichkeit, Funktionen, die normalerweise auf eine Series angewendet werden, auf jedes Element der Series anzuwenden. Dafür wird die lambda Syntax verwendet: lambda x: x + 1. lambda ist ein Platzhalter und kann als “für jedes x tue:” gelesen werden. So kann beispielsweise die Anzahl der Zeichen in jeder Zeile bestimmt werden.\n\n# Auf die Series angewendet\nprint(len(str(temperaturen[2021])), \"\\n\")\n\n# Elementweise angewendet\nprint(temperaturen[2021].agg(lambda x: len(str(x))), \"\\n\") # deprecated\nprint(temperaturen[2021].apply(lambda x: len(str(x))), \"\\n\")\n\n144 \n\nJan    1\nFeb    1\nMär    1\nApr    2\nMai    2\nJun    2\nJul    2\nAug    2\nSep    2\nOkt    2\nNov    1\nDez    1\nName: 2021, dtype: int64 \n\nJan    1\nFeb    1\nMär    1\nApr    2\nMai    2\nJun    2\nJul    2\nAug    2\nSep    2\nOkt    2\nNov    1\nDez    1\nName: 2021, dtype: int64 \n\n\n\nDetails zur Verwendung des Lambda-Ausdrucks finden Sie in der Dokumentation.\nDer Vollständigkeit wegen ist zu erwähnen, dass mit den Methoden .map() und .transform() weitere, sehr ähnliche Alternativen bestehen. Bei Interesse können Sie die Unterschiede in diesem Artikel nachlesen.\n\n# print(temperaturen[2021].map(lambda x: len(str(x))))\n# print(temperaturen[2021].transform(lambda x: len(str(x))), \"\\n\")",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Operationen</span>"
    ]
  },
  {
    "objectID": "skript/operationen.html#aufgaben-operationen",
    "href": "skript/operationen.html#aufgaben-operationen",
    "title": "2  Operationen",
    "section": "2.2 Aufgaben Operationen",
    "text": "2.2 Aufgaben Operationen\n\nBestimmen Sie für den Dataframe temperaturen die monatliche Mediantemperatur.\nErmitteln Sie die Monate mit einer Mediantemperatur größer gleich 21 Grad.\nGeben Sie die Indexbeschriftung dieser Monate aus.\n\n\n\n\n\n\n\nTipp 2.2: Musterlösung Aufgaben Operationen\n\n\n\n\n\n\nAufgabe\n\n\nprint(temperaturen.mean(axis = 1))\n\nJan     0.25\nFeb     2.75\nMär     6.25\nApr    10.50\nMai    17.25\nJun    22.00\nJul    23.50\nAug    21.25\nSep    17.50\nOkt    14.50\nNov     8.25\nDez     4.25\ndtype: float64\n\n\n\nAufgabe\n\n\nprint(temperaturen.mean(axis = 1).ge(21))\n\nJan    False\nFeb    False\nMär    False\nApr    False\nMai    False\nJun     True\nJul     True\nAug     True\nSep    False\nOkt    False\nNov    False\nDez    False\ndtype: bool\n\n\n\nAufgabe\n\n\nprint(temperaturen.index[temperaturen.mean(axis = 1).ge(21)], \"\\n\")\n\n# als Liste\nprint(list(temperaturen.index[temperaturen.mean(axis = 1).ge(21)]), \"\\n\")\n\nIndex(['Jun', 'Jul', 'Aug'], dtype='object') \n\n['Jun', 'Jul', 'Aug']",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Operationen</span>"
    ]
  },
  {
    "objectID": "skript/operationen.html#suchen-und-ersetzen",
    "href": "skript/operationen.html#suchen-und-ersetzen",
    "title": "2  Operationen",
    "section": "2.3 Suchen und ersetzen",
    "text": "2.3 Suchen und ersetzen\nUm die Indexposition eines bestimmten Werts zu bestimmen, kann die Numpy-Funktion np.where() verwendet werden. Diese gibt zwei Arrays mit den jeweiligen Zeilen- und Spaltennummern zurück.\n\nprint(np.where(temperaturen == 4))\n\n(array([ 1,  2, 11]), array([0, 2, 1]))\n\n\nUnter anderem befindet sich der Wert 4 in Zeile 1 in Spalte 0 oder auch in Zeile 2 in Spalte 2.\n\nprint(temperaturen.iloc[1, 0])\nprint(temperaturen.iloc[2, 2])\n\n4\n4\n\n\nPandas bietet zwei Methoden, um Werte zu ersetzen.\n\npd.DataFrame.replace(to_replace, value, *, inplace = False) ersetzt to_replace mit value. Mit dem Argument inplace = True erfolgt dies direkt im Objekt.\npd.where(cond, other = nan, inplace = False) behält cond und ersetzt alle anderen Werte mit other (standardmäßig ein Platzhalter für fehlende Werte). Mit dem Argument inplace = True erfolgt dies direkt im Objekt.\n\nDie Syntax beider Funktionen unterscheidet sich leicht, wie im folgenden Beispiel zu sehen ist.\n\nprint(temperaturen.replace(to_replace = 25, value = 1000), \"\\n\")\nprint(temperaturen.where(temperaturen == 25, other = 1000))\n\n     2021  2022  2023  2024\nJan     2     3    -3    -1\nFeb     4     6    -1     2\nMär     7     9     4     5\nApr    12    13     9     8\nMai    19    18    15    17\nJun    23    21    20    24\nJul  1000    24    20  1000\nAug    23    23    19    20\nSep    18    19    16    17\nOkt    15    14    15    14\nNov     9     8     7     9\nDez     5     4     6     2 \n\n     2021  2022  2023  2024\nJan  1000  1000  1000  1000\nFeb  1000  1000  1000  1000\nMär  1000  1000  1000  1000\nApr  1000  1000  1000  1000\nMai  1000  1000  1000  1000\nJun  1000  1000  1000  1000\nJul    25  1000  1000    25\nAug  1000  1000  1000  1000\nSep  1000  1000  1000  1000\nOkt  1000  1000  1000  1000\nNov  1000  1000  1000  1000\nDez  1000  1000  1000  1000",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Operationen</span>"
    ]
  },
  {
    "objectID": "skript/operationen.html#aufgaben-suchen-und-ersetzen",
    "href": "skript/operationen.html#aufgaben-suchen-und-ersetzen",
    "title": "2  Operationen",
    "section": "2.4 Aufgaben suchen und ersetzen",
    "text": "2.4 Aufgaben suchen und ersetzen\n\nBestimmen Sie die Position der Werte im DataFrame ‘temperaturen’, die kleiner als 0 sind und geben Sie die Werte aus.\nErsetzen Sie alle Werte im DataFrame temperaturen, die kleiner sind als 0 durch den Wert 0 und geben Sie das Ergebnis aus.\n\n\n\n\n\n\n\nTipp 2.3: Musterlösung suchen und ersetzen\n\n\n\n\n\n\nAufgabe\n\n\nprint(np.where(temperaturen &lt;= 0))\nprint(\"Anzahl Werte:\", len(np.where(temperaturen &lt;= 0)[0]))\n\nfor i in range(len(np.where(temperaturen &lt;= 0)[0])):\n  print(temperaturen.iloc[np.where(temperaturen &lt;= 0)[0][i], np.where(temperaturen &lt;= 0)[1][i]])\n\n(array([0, 0, 1]), array([2, 3, 2]))\nAnzahl Werte: 3\n-3\n-1\n-1\n\n\n\nAufgabe\n\n\nprint(temperaturen.where(temperaturen &gt; 0, other = 0))\n\n     2021  2022  2023  2024\nJan     2     3     0     0\nFeb     4     6     0     2\nMär     7     9     4     5\nApr    12    13     9     8\nMai    19    18    15    17\nJun    23    21    20    24\nJul    25    24    20    25\nAug    23    23    19    20\nSep    18    19    16    17\nOkt    15    14    15    14\nNov     9     8     7     9\nDez     5     4     6     2",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Operationen</span>"
    ]
  },
  {
    "objectID": "skript/operationen.html#sortieren",
    "href": "skript/operationen.html#sortieren",
    "title": "2  Operationen",
    "section": "2.5 Sortieren",
    "text": "2.5 Sortieren\nDie Methode DataFrame.sort_index(axis = 0, ascending = True, inplace = False) sortiert entlang einer Achse, standardmäßig aufsteigend nach dem Index. Durch die Übergabe des Arguments axis = 1 werden die Spalten sortiert. Mit dem Argument ascending = False wird absteigend sortiert. Das Argument inplace = True sorgt, wie gewohnt, dafür, dass das Ergebnis des Sortiervorgangs direkt im Objekt gespeichert wird.\n\nprint(temperaturen.sort_index(), \"\\n\")\nprint(temperaturen.sort_index(axis = 1, ascending = False))\n\n     2021  2022  2023  2024\nApr    12    13     9     8\nAug    23    23    19    20\nDez     5     4     6     2\nFeb     4     6    -1     2\nJan     2     3    -3    -1\nJul    25    24    20    25\nJun    23    21    20    24\nMai    19    18    15    17\nMär     7     9     4     5\nNov     9     8     7     9\nOkt    15    14    15    14\nSep    18    19    16    17 \n\n     2024  2023  2022  2021\nJan    -1    -3     3     2\nFeb     2    -1     6     4\nMär     5     4     9     7\nApr     8     9    13    12\nMai    17    15    18    19\nJun    24    20    21    23\nJul    25    20    24    25\nAug    20    19    23    23\nSep    17    16    19    18\nOkt    14    15    14    15\nNov     9     7     8     9\nDez     2     6     4     5\n\n\nDie Methode DataFrame.sort_values(by, *, axis = 0, ascending = True, inplace = False) sortiert Werte entlang einer Achse, standardmäßig entlang des Index (axis = 0). Dem Parameter by sind laut Dokumentation der Spaltenname als string bzw. eine Liste von Spaltennamen als string zu übergeben, nach denen sortiert werden soll. Wie im folgenden Code-Beispiel zu sehen ist, muss die numerische Spaltenbeschriftung jedoch auch in numerischer Form übergeben werden.\nWird mit dem Argument axis = 1 entlang der zweiten Dimension sortiert, werden entsprechend Indexbeschriftungen übergeben.\n\n# Sortieren nach numerischen Spaltenbeschriftungen\nprint(temperaturen.sort_values(by = 2021), \"\\n\")\nprint(temperaturen.sort_values(by = [2021, 2023]), \"\\n\")\n\n# Sortieren nach als string übergebenen Spaltenbeschriftungen\n# führt zu KeyError, die Fehlermeldung wird nicht vollständig abgefangen\ntry:\n  print(temperaturen.sort_values(by = '2021'))\nexcept Exception as error:\n  print(error)\n\n     2021  2022  2023  2024\nJan     2     3    -3    -1\nFeb     4     6    -1     2\nDez     5     4     6     2\nMär     7     9     4     5\nNov     9     8     7     9\nApr    12    13     9     8\nOkt    15    14    15    14\nSep    18    19    16    17\nMai    19    18    15    17\nJun    23    21    20    24\nAug    23    23    19    20\nJul    25    24    20    25 \n\n     2021  2022  2023  2024\nJan     2     3    -3    -1\nFeb     4     6    -1     2\nDez     5     4     6     2\nMär     7     9     4     5\nNov     9     8     7     9\nApr    12    13     9     8\nOkt    15    14    15    14\nSep    18    19    16    17\nMai    19    18    15    17\nAug    23    23    19    20\nJun    23    21    20    24\nJul    25    24    20    25 \n\n'2021'",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Operationen</span>"
    ]
  },
  {
    "objectID": "skript/operationen.html#aufgaben-sortieren",
    "href": "skript/operationen.html#aufgaben-sortieren",
    "title": "2  Operationen",
    "section": "2.6 Aufgaben Sortieren",
    "text": "2.6 Aufgaben Sortieren\n\nSortieren Sie den DataFrame meerschweinchen absteigend nach der Zahnlänge (‘len’). Welches Meerschweinchen hat die längste zahnbildende Zelle (gesucht ist die ID)?\nWelches Meerschweinchen, welches die Dosis 1.0 erhielt, hat die längste zahnbildende Zelle (gesucht ist die ID)?\n\n\n\n\n\n\n\nTipp 2.4: Musterlösung Sortieren\n\n\n\n\n\n\nAufgabe\n\n\nprint(meerschweinchen.sort_values(by = 'len', ascending = False).head(), \"\\n\")\n\nprint(\"Die ID lautet:\", meerschweinchen.sort_values(by = 'len', ascending = False).iloc[0, 0])\n\n    ID   len supp  dose\n22  23  33.9   VC   2.0\n25  26  32.5   VC   2.0\n55  56  30.9   OJ   2.0\n29  30  29.5   VC   2.0\n58  59  29.4   OJ   2.0 \n\nDie ID lautet: 23\n\n\n\nAufgabe\n\n\ndose_1 = meerschweinchen[meerschweinchen['dose'] == 1.0]\n\nprint(dose_1.sort_values(by = 'len', ascending = False).head(), \"\\n\")\n\nprint(\"Die ID lautet:\", dose_1.sort_values(by = 'len', ascending = False).iloc[0, 0])\n\n    ID   len supp  dose\n49  50  27.3   OJ   1.0\n43  44  26.4   OJ   1.0\n46  47  25.8   OJ   1.0\n45  46  25.2   OJ   1.0\n42  43  23.6   OJ   1.0 \n\nDie ID lautet: 50",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Operationen</span>"
    ]
  },
  {
    "objectID": "skript/operationen.html#groupby",
    "href": "skript/operationen.html#groupby",
    "title": "2  Operationen",
    "section": "2.7 GroupBy",
    "text": "2.7 GroupBy\nDie Methode pd.groupby() teilt einen DataFrame (oder eine Series) in Gruppen auf und gibt ein GroupBy-Objekt zurück. Das GroupBy-Objekt hat dieselben Spalten- und Zeilenbeschriftungen wie der DataFrame, das GroupBy-Objekt ist aber nach der Gruppenaufteilung sortiert. Operationen, die auf das GroupBy-Objekt angewendet werden, werden für jede Gruppe separat ausgeführt.\nDies kann am Datensatz ‘meerschweinchen’ im folgenden Panel nachvollzogen werden.\n\nReiter: Der Datensatz enthält 60 Einträge. Die ersten 30 Einträge haben in der Spalte ‘supp’ die Ausprägung VC für Vitamin C, die letzten 30 Einträge die Ausprägung OJ für Orangensaft.\nReiter: Mit der Methode pd.groupby('supp') kann der Datensatz nach den Merkmalsausprägungen in der Spalte ‘dose’ (0.5, 1 und 2) gruppiert werden.\nReiter: Auf das Groupby-Objekt können Operationen ausgeführt werden. Beispielsweise kann die Spalte ‘len’ ausgewählt und mit der Methode .mean() die mittlere Länge der zahnbildenden Zelle bestimmt werden.\nReiter: Ebenso kann nach den Ausprägungen mehrerer Merkmale gruppiert werden, indem diese als Liste übergeben werden pd.groupby(by = ['supp', 'dose']).\n\n\nDataFrame meerschweinchenmeerschweinchen gruppiert nach VerabreichungsartLänge nach VerabreichungsartLänge nach Verabreichungsart und Dosis\n\n\n\nprint(meerschweinchen.head(n = 12))\n\n    ID   len supp  dose\n0    1   4.2   VC   0.5\n1    2  11.5   VC   0.5\n2    3   7.3   VC   0.5\n3    4   5.8   VC   0.5\n4    5   6.4   VC   0.5\n5    6  10.0   VC   0.5\n6    7  11.2   VC   0.5\n7    8  11.2   VC   0.5\n8    9   5.2   VC   0.5\n9   10   7.0   VC   0.5\n10  11  16.5   VC   1.0\n11  12  16.5   VC   1.0\n\n\n\n\nFür die Methode .head() wurde das Argument n halbiert, um die gleiche Zeilenzahl in der Ausgabe anzeigen zu lassen, da auch diese Methode für jede der beiden Gruppen (VC und OJ) ausgeführt wird.\n\nprint(meerschweinchen.groupby('supp').head(n = 6))\n\n    ID   len supp  dose\n0    1   4.2   VC   0.5\n1    2  11.5   VC   0.5\n2    3   7.3   VC   0.5\n3    4   5.8   VC   0.5\n4    5   6.4   VC   0.5\n5    6  10.0   VC   0.5\n30  31  15.2   OJ   0.5\n31  32  21.5   OJ   0.5\n32  33  17.6   OJ   0.5\n33  34   9.7   OJ   0.5\n34  35  14.5   OJ   0.5\n35  36  10.0   OJ   0.5\n\n\n\n\n\nprint(meerschweinchen.groupby(by = 'supp')['len'].mean())\n\nsupp\nOJ    20.663333\nVC    16.963333\nName: len, dtype: float64\n\n\n\n\n\nprint(meerschweinchen.groupby(by = ['supp', 'dose'])['len'].mean())\n\nsupp  dose\nOJ    0.5     13.23\n      1.0     22.70\n      2.0     26.06\nVC    0.5      7.98\n      1.0     16.77\n      2.0     26.14\nName: len, dtype: float64",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Operationen</span>"
    ]
  },
  {
    "objectID": "skript/operationen.html#aufgaben-groupby",
    "href": "skript/operationen.html#aufgaben-groupby",
    "title": "2  Operationen",
    "section": "2.8 Aufgaben GroupBy",
    "text": "2.8 Aufgaben GroupBy\nDer Datensatz Motor Trend Car Road Tests (mtcars) stammt aus der us-amerikanischen Zeitschrift Motor Trend von 1974 und enthalt Daten für 32 Autos.\n\n\n\nmtcars = pd.read_csv(filepath_or_buffer = \"01-daten/mtcars.csv\", sep = \",\")\nmtcars.rename(columns = {'Unnamed: 0': 'car'}, inplace = True)\n\nmtcars.head()\n\n\n\n\n\n\n\n\ncar\nmpg\ncyl\ndisp\nhp\ndrat\nwt\nqsec\nvs\nam\ngear\ncarb\n\n\n\n\n0\nMazda RX4\n21.0\n6\n160.0\n110\n3.90\n2.620\n16.46\n0\n1\n4\n4\n\n\n1\nMazda RX4 Wag\n21.0\n6\n160.0\n110\n3.90\n2.875\n17.02\n0\n1\n4\n4\n\n\n2\nDatsun 710\n22.8\n4\n108.0\n93\n3.85\n2.320\n18.61\n1\n1\n4\n1\n\n\n3\nHornet 4 Drive\n21.4\n6\n258.0\n110\n3.08\n3.215\n19.44\n1\n0\n3\n1\n\n\n4\nHornet Sportabout\n18.7\n8\n360.0\n175\n3.15\n3.440\n17.02\n0\n0\n3\n2\n\n\n\n\n\n\n\n\n\n\n\nSpalte\nBedeutung\n\n\n\n\nmpg\nKraftstoffverbrauch in Meilen pro Gallone\n\n\ncyl\nAnzahl Zylinder\n\n\ndisp\nHubraum in Kubikzoll\n\n\nhp\nPferdestärken\n\n\ndrat\nHinterachsübersetzung\n\n\nwt\nGewicht in 1000 Pfund\n\n\nqsec\nZeit auf der Viertelmeile\n\n\nvs\nMotor (0 = V-Motor, 1 = Reihenmotor)\n\n\nam\nSchaltung (0 = Automatik, 1 = Handschaltung)\n\n\ngear\nAnzahl der Vorwärtsgänge\n\n\ncarb\nAnzahl der Vergaser\n\n\n\nHenderson and Velleman 1981. Building multiple regression models interactively. Biometrics 37: 391–411. Der Datensatz ist abrufbar auf GitHub und in R verfügbar.\n\n \n\nGruppieren Sie den Datensatz nach der Anzahl Zylinder und ermitteln Sie den durchschnittlichen Kraftstoffverbrauch für jede Gruppe.\nWie viele Liter auf 100 Kilometer sind es?\nGruppieren Sie den Datensatz nach der Anzahl der Zylinder und der Vergaser. Welche Gruppe ist am schnellsten auf der Viertelmeile?\n\n\n\n\n\n\n\nTipp 2.5: Musterlösung GroupBy\n\n\n\n\n\n\nAufgabe\n\n\nmtcars.groupby(by = 'cyl')['mpg'].mean() \n\ncyl\n4    26.663636\n6    19.742857\n8    15.100000\nName: mpg, dtype: float64\n\n\n\nAufgabe\n\n\n# 1 Meile = 1.60934 Kilometer\n# 1 Gallone = 3.78541 Liter\n\nmpg = mtcars.groupby(by = 'cyl')['mpg'].mean()\n\nliter_100km = 1 / mpg.mul(1.60934).div(3.78541).div(100)\n\nprint(liter_100km)\n\ncyl\n4     8.821567\n6    11.913932\n8    15.577156\nName: mpg, dtype: float64\n\n\n\nAufgabe\n\n\nprint(mtcars.groupby(by = ['cyl', 'carb'])['qsec'].mean(), \"\\n\")\nprint(mtcars.groupby(by = ['cyl', 'carb'])['qsec'].mean().index[-1], \"\\n\")\n\ncyl  carb\n4    1       19.378000\n     2       18.936667\n6    1       19.830000\n     4       17.670000\n     6       15.500000\n8    2       17.060000\n     3       17.666667\n     4       16.495000\n     8       14.600000\nName: qsec, dtype: float64 \n\n(np.int64(8), np.int64(8)) \n\n\n\nDie Gruppe mit 8 Zylindern und 8 Vergasern ist am schnellsten. (Hinweis: Es handelt sich hierbei um einen sogenannten MultiIndex.)",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Operationen</span>"
    ]
  },
  {
    "objectID": "skript/plotting.html",
    "href": "skript/plotting.html",
    "title": "3  Grafikerstellung",
    "section": "",
    "text": "3.1 Series\nMit der Methode pd.plot() können Series und DataFrame grafisch dargestellt werden. Dazu greift Pandas auf matplotlib zurück. Die Syntax von Pandas ist einfacher, dafür bietet das Modul weniger Möglichkeiten als matplotlib. Jedoch können Befehle aus Pandas und aus matplotlib zur Grafikerstellung kombiniert werden (siehe Werkzeugbaustein Matplotlib).\nEine Series wird gegen den Index geplottet. Standardmäßig wird ein Liniendiagramm gezeichnet. Mit den Parametern xlabel und ylabel können Achsenbeschriftungen eingetragen werden.\nmeerschweinchen['len'].plot(xlabel = 'Index', ylabel = 'len')\nMit dem Parameter kind kann der Grafiktyp geändert werden. Einige Möglichkeiten sind:\nEinige sinnvolle Parameter sind:\nmeerschweinchen['dose'].value_counts().plot(kind = 'pie', ylabel = 'Dosis', colormap = 'Blues', figsize = (6, 6), legend = True, title = 'Tortendiagramm der Dosis Vitamin C')",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Grafikerstellung</span>"
    ]
  },
  {
    "objectID": "skript/plotting.html#series",
    "href": "skript/plotting.html#series",
    "title": "3  Grafikerstellung",
    "section": "",
    "text": "'line': Standardwert Liniendiagramm\n'bar': vertikales Balkendiagramm\n'hbar': horizontales Balkendiagramm\n'hist': Histogramm\n'box': Boxplot\n'pie': Tortendiagramm\n\n\n\ncolormap = palette ändert die Farbpalette. Eine Liste der in matplotlib verfügbaren Paletten finden Sie in der Dokumentation.\nfigsize = (Breite, Höhe) Tupel der Bildgröße in Zoll\nlegend = True zeichnet eine Legende ein..\ntitle = 'Titel' trägt einen Titel ein.\ngrid = True fügt Gitternetzlinien ein.\nxlim = (min, max) / ylim = (min, max) setzt den Wertebereich der x- bzw. y-Achse.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Grafikerstellung</span>"
    ]
  },
  {
    "objectID": "skript/plotting.html#dataframe",
    "href": "skript/plotting.html#dataframe",
    "title": "3  Grafikerstellung",
    "section": "3.2 DataFrame",
    "text": "3.2 DataFrame\nFür DataFrames sind weitere Optionen verfügbar. Mittels der Parameter x und y können Spalten oder Zeilen ausgewählt werden, die auf den jeweiligen Achsen aufgetragen werden sollen. y kann dabei auch eine Liste mit mehreren Einträgen enthalten.\n\nmeerschweinchen.plot(x = 'ID', y = ['dose', 'len'])\n\n\n\n\n\n\n\n\n \nFür DataFrames ist das Streudiagramm als Diagrammtyp verfügbar.\n\nmeerschweinchen.plot(x = 'ID', y = 'len', kind = 'scatter')",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Grafikerstellung</span>"
    ]
  },
  {
    "objectID": "skript/plotting.html#subplots",
    "href": "skript/plotting.html#subplots",
    "title": "3  Grafikerstellung",
    "section": "3.3 subplots",
    "text": "3.3 subplots\nMit dem Argument subplots = True werden Teilgrafiken erstellt. Dabei wird automatisch das Argument sharex = True gesetzt, sodass beide Teilgrafiken eine gemeinsame x-Achse nutzen teilen. Dem Parameter title können Überschriften für jede Teilgrafik als Liste übergeben werden.\n\nmeerschweinchen.plot(x = 'ID', y = ['dose', 'len'], subplots = True, title = ['Vitamin C Dosis', 'Länge zahnbildender Zellen']);\n\n\n\n\n\n\n\n\n \nEbenso ist das Argument sharey = True verfügbar. Das Argument sharex wird auf False gesetzt.\n\nmeerschweinchen.plot(x = 'ID', y = ['dose', 'len'], subplots = True, sharex = False, sharey = True, title = ['Vitamin C Dosis', 'Länge zahnbildender Zellen']);\n\n\n\n\n\n\n\n\n \nUm die überdeckte Beschriftung der x-Achse zu beheben, muss auf einen Befehl aus dem Modul matplotlib.pyplot zurückgegriffen werden.\n\nimport matplotlib.pyplot as plt\n\nmeerschweinchen.plot(x = 'ID', y = ['dose', 'len'], subplots = True, sharex = False, sharey = True, title = ['Vitamin C Dosis', 'Länge zahnbildender Zellen']);\nplt.tight_layout()\n\n\n\n\n\n\n\n\n \nAuch um für jede Teilgrafik eine y-Achsenbeschriftung zu setzen, muss auf matplotlib zurückgegriffen werden.\n\nmein_plot = meerschweinchen.plot(x = 'ID', y = ['dose', 'len'], subplots = True, sharex = False, sharey = True, title = ['Vitamin C Dosis', 'Länge zahnbildender Zellen']);\n\nmein_plot[0].set_ylabel('Milligramm pro Tag')\nmein_plot[1].set_ylabel('Micron')\nplt.tight_layout()\nplt.show()",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Grafikerstellung</span>"
    ]
  },
  {
    "objectID": "skript/datentypen.html",
    "href": "skript/datentypen.html",
    "title": "4  Datentypen",
    "section": "",
    "text": "Das Modul Pandas ist auf den Umgang mit unterschiedlichen Datentypen spezialisiert. Ein Dataframe kann unterschiedliche Datentypen enthalten (bspw. Zahlen und Wahrheitswerte).\nNumPy unterstützt folgende Datentypen:\n\n\n\nDatentyp NumPy-Array\nDatentyp in Python\n\n\n\n\nint_\nint\n\n\ndouble\nfloat\n\n\ncdouble\ncomplex\n\n\nbytes_\nbytes\n\n\nstr_\nstr\n\n\nbool_\nbool\n\n\ndatetime64\ndatetime.datetime\n\n\ntimedelta64\ndatetime.timedelta\n\n\n\n \nDie NumPy-Datentypen haben betriebssystemabhängige Synonyme. Beispielsweise wird für ein Array vom Datentyp int_ der Datentyp int ausgegeben, für ein Array aus Gleitkommazahlen der Datentyp float64.\n\nskalar = np.array([2])\nprint(skalar.dtype, \"\\n\")\n\nskalar = np.array([2.1])\n\nprint(skalar.dtype)\n\nint64 \n\nfloat64\n\n\nAußerdem gibt es für jeden NumPy-Datentyp ein Kürzel, das aus einem einzigen Buchstaben besteht. Beispielsweise wird für Zeichenfolgen das Kürzel U für Unicode-Zeichen und die Anzahl der Stellen ausgegeben (Für alle anderen Datentypen repräsentiert die Zahl die Anzahl der Bytes, die im Speicher benötigt werden.). Der Ausgabe ist ein Zeichen zur Kodiererung der Byte-Reihenfolge im Speicher vorangestellt ‘&gt;’ (big-endian), ‘&lt;’ (little-endian) oder ‘=’ (Systemstandard).\n\nskalar = np.array(['2'])\nprint(skalar.dtype, \"\\n\")\n\nskalar = np.array(['2.1'])\nprint(skalar.dtype, \"\\n\")\n\n# Ein Datentyp mit mehr Speicherplatzbedarf kann zugewiesen werden\nskalar = np.array([2], dtype = 'U3')\nprint(skalar.dtype)\n\n&lt;U1 \n\n&lt;U3 \n\n&lt;U3\n\n\nAlle Synonyme und Kürzel können Sie der NumPy-Dokumentation entnehmen.\nHäufig verwendet das Modul Pandas die NumPy-Datentypen. Pandas führt aber auch einige zusätzliche Datentypen ein. Eine vollständige Liste finden Sie in der Pandas Dokumentation. Die wichtigsten zusätzlichen Datentypen sind:\n\nKategorie dtype = 'category' für kategoriale, also ungeordnete, Daten.\nZeitzonenbewusstes Datumsformat dtype = 'datetime64[ns, US/Eastern]'\nErweiterungen der NumPy-Datentypen mit Unterstützung fehlender Werte. Diese sind an der Großschreibung zu erkennen.\n\n\n# NumPy-Datentyp int\nseries = pd.Series([1, 2, 3], dtype = 'int')\nprint(series, \"\\n\")\n\n# NumPy-Datentyp int unterstützt fehlende Werte nicht\ntry:\n  series = pd.Series([1, 2, 3, np.nan], dtype = 'int')\nexcept Exception as error:\n    print(error, \"\\n\")\n\n# Pandas-Datentyp Int64 unterstützt fehlende Werte\nseries = pd.Series([1, 2, 3, np.nan], dtype = 'Int64')\nprint(series)\n\n0    1\n1    2\n2    3\ndtype: int64 \n\ncannot convert float NaN to integer \n\n0       1\n1       2\n2       3\n3    &lt;NA&gt;\ndtype: Int64\n\n\n\n\n\n\n\n\nHinweis 4.1: Pandas-Datentyp string\n\n\n\n\n\nPandas nutzt wie die Pythonbasis den Datentyp ‘string’, der unveränderlich (immutable) ist. Das bedeutet, es gibt keine Methode, die eine angelegte Zeichenkette verändern kann. Operationen mit diesem Datentyp geben ein neues Objekt mit dem Datentyp ‘string’ zurück.\nDie Übergabe des Datentyps ‘str’ führt zur Verwendung des NumPy-Datentyps string (dtype = ‘str’), der veränderlich (mutable) ist.\nJe nach Situation kann die Verwendung des einen oder des anderen Datentyps nützlich sein. Beispielsweise kann der NumPy-Datentyp ‘str’ mit der Methode pd.Series.sum() verkettet werden.\n\n# mit NumPy-Datentyp 'str'\nstring_series = pd.Series(['H', 'a', 'l', 'l', 'o', '!'], dtype = 'str')\nprint(f\"Mit NumPy-Datentyp 'str': {string_series.sum()}\")\n\n# mit Pandas-Datentyp 'string'\ntry:\n  string_series.astype('string').sum()\nexcept Exception as error:\n  print(\"\\nMit Pandas-Datentyp 'string':\")\n  print(error)\n\nMit NumPy-Datentyp 'str': Hallo!",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Datentypen</span>"
    ]
  },
  {
    "objectID": "skript/datetime.html",
    "href": "skript/datetime.html",
    "title": "5  Zeitreihen",
    "section": "",
    "text": "5.1 Datums- und Zeitinformationen in Python\nDie Verarbeitung von Datums- und Zeitinformationen wird in Python durch verschiedene Module ermöglicht. Einleitend werden einige dieser Module kurz vorgestellt, da in der Dokumentation gelegentlich auf diese verwiesen wird. Pandas bietet einen einheitlichen Zugang zu den meisten dieser Funktionen und verwendet die NumPy Datentypen datetime64 und timedelta64.\nIn Python gibt es einige Module zur Verarbeitung von Datums- und Zeitinformationen.\nNumPy und Pandas können Datetime-Objekte anderer Module in den Datentyp datetime64 umwandeln.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Zeitreihen</span>"
    ]
  },
  {
    "objectID": "skript/datetime.html#datums--und-zeitinformationen-in-python",
    "href": "skript/datetime.html#datums--und-zeitinformationen-in-python",
    "title": "5  Zeitreihen",
    "section": "",
    "text": "Das Modul time stellt Zeit- und Datumsoperationen mit Objekten vom Typ struct_time bereit. (Dokumentation des Moduls time)\nDas Modul datetime führt die Datentypen datetime und timedelta, zusätzliche Methoden für die Bearbeitung und die Ausgabe von Datums- und Zeitinformationen ein. Das Modul kann Jahreszahlen von 1 bis 9999 nach unserer Zeitrechnung im Gregorianischen Kalender verarbeiten. (Dokumentation des Moduls datetime)\nDas Modul calendar führt verschiedene Kalenderfunktionen ein und erweitert den verarbeitbaren Zeitraum. Basierend auf dem Gregorianischen Kalender reicht dieser in beide Richtungen ins Unendliche. (Dokumentation des Moduls calendar)\nDas Modul pytz führt die IANA-Zeitzonendatenbank (Internet Assigned Numbers Authority) für Anwendungsprogramme und Betriebssysteme ein (auch Olsen-Datenbank genannt). Die IANA-Datenbank beinhaltet die Zeitzonen und Änderungen der Zeit seit 1970. (Wikipedia) Das Modul pytz sorgt für eine korrekte Berechnung von Zeiten zum Ende der Zeitumstellung (Ende Sommerzeit) über Zeitzonen hinweg. (Dokumentation pytz)\nNumPy führt die Datentypen datetime64 und timedelta64 ein. Diese basieren auf dem Gregorianischen Kalender und reichen in beide Richtungen ins Unendliche. https://numpy.org/doc/stable/reference/arrays.datetime.html\nPandas nutzt die NumPy-Datentypen datetime64 und timedelta64 und ergänzt zahlreiche Funktionen zur Verarbeitung von Datums- und Zeitinformationen aus anderen Paketen. https://pandas.pydata.org/docs/user_guide/timeseries.html\n\n\n\nNaive und bewusste Datetime-Objekte\nDatetime-Objekte werden abhängig davon, ob sie Informationen über Zeitzonen enthalten, als naiv (naive) oder als bewusst (aware) bezeichnet. Naiven Datetime-Objekten fehlt diese Information, bewusste Datetime-Objekte enthalten diese. Objekte der Module time, datetime und Pandas verfügen über ein Zeitzonenattribut, sind also bewusst. np.datetime64 ist seit NumPy-Version 1.11.0 ein naiver Datentyp, unterstützt aber Zeitzonen aus Gründen der Rückwärtskompatibilität.\n\n\n\n\n\n\n \n\n\n“Deprecated since version 1.11.0: NumPy does not store timezone information. For backwards compatibility, datetime64 still parses timezone offsets, which it handles by converting to UTC±00:00 (Zulu time). This behaviour is deprecated and will raise an error in the future.” NumPy Dokumentation\n\n\n \n\n\n\n\nZeitzonen\nPandas kann mit Zeitzonen umgehen und datetime-Objekte von einer in eine andere Zeitzone umwandeln. Über das Argument tz kann in verschiedenen Funktionen die Zeitzone angegeben werden.\n\nzeitreihe = pd.Series(pd.date_range(start = \"2023-03-26T00:00\", end = \"2023-03-27T00:00\", freq = \"3h\", tz = \"turkey\"))\nzeitreihe\n\n0   2023-03-26 00:00:00+03:00\n1   2023-03-26 03:00:00+03:00\n2   2023-03-26 06:00:00+03:00\n3   2023-03-26 09:00:00+03:00\n4   2023-03-26 12:00:00+03:00\n5   2023-03-26 15:00:00+03:00\n6   2023-03-26 18:00:00+03:00\n7   2023-03-26 21:00:00+03:00\n8   2023-03-27 00:00:00+03:00\ndtype: datetime64[ns, Turkey]\n\n\nMit der Funktion pd.to_datetime(arg, utc = True) kann die Zeitzone in die koordinierte Universalzeit UTC umgewandelt werden.\n\npd.to_datetime(zeitreihe, utc = True)\n\n0   2023-03-25 21:00:00+00:00\n1   2023-03-26 00:00:00+00:00\n2   2023-03-26 03:00:00+00:00\n3   2023-03-26 06:00:00+00:00\n4   2023-03-26 09:00:00+00:00\n5   2023-03-26 12:00:00+00:00\n6   2023-03-26 15:00:00+00:00\n7   2023-03-26 18:00:00+00:00\n8   2023-03-26 21:00:00+00:00\ndtype: datetime64[ns, UTC]\n\n\nEine Umwandlung in beliebige Zeitzonen ist mit der Methode pd.Series.dt.tz_convert(tz = 'utc') möglich.\n\nzeitreihe.dt.tz_convert(tz = 'portugal')\n\n0   2023-03-25 21:00:00+00:00\n1   2023-03-26 00:00:00+00:00\n2   2023-03-26 04:00:00+01:00\n3   2023-03-26 07:00:00+01:00\n4   2023-03-26 10:00:00+01:00\n5   2023-03-26 13:00:00+01:00\n6   2023-03-26 16:00:00+01:00\n7   2023-03-26 19:00:00+01:00\n8   2023-03-26 22:00:00+01:00\ndtype: datetime64[ns, Portugal]\n\n\n\n\n\n\n\n\nBeispiel 5.1: verfügbare Zeitzonen ermitteln\n\n\n\n\n\nDer folgende Code gibt die in Python verfügbaren Zeitzonen aus.\n\nfrom zoneinfo import available_timezones\n\nfor timezone in sorted(available_timezones()):\n  print(timezone)\n\nAfrica/Abidjan\nAfrica/Accra\nAfrica/Addis_Ababa\nAfrica/Algiers\nAfrica/Asmara\nAfrica/Asmera\nAfrica/Bamako\nAfrica/Bangui\nAfrica/Banjul\nAfrica/Bissau\nAfrica/Blantyre\nAfrica/Brazzaville\nAfrica/Bujumbura\nAfrica/Cairo\nAfrica/Casablanca\nAfrica/Ceuta\nAfrica/Conakry\nAfrica/Dakar\nAfrica/Dar_es_Salaam\nAfrica/Djibouti\nAfrica/Douala\nAfrica/El_Aaiun\nAfrica/Freetown\nAfrica/Gaborone\nAfrica/Harare\nAfrica/Johannesburg\nAfrica/Juba\nAfrica/Kampala\nAfrica/Khartoum\nAfrica/Kigali\nAfrica/Kinshasa\nAfrica/Lagos\nAfrica/Libreville\nAfrica/Lome\nAfrica/Luanda\nAfrica/Lubumbashi\nAfrica/Lusaka\nAfrica/Malabo\nAfrica/Maputo\nAfrica/Maseru\nAfrica/Mbabane\nAfrica/Mogadishu\nAfrica/Monrovia\nAfrica/Nairobi\nAfrica/Ndjamena\nAfrica/Niamey\nAfrica/Nouakchott\nAfrica/Ouagadougou\nAfrica/Porto-Novo\nAfrica/Sao_Tome\nAfrica/Timbuktu\nAfrica/Tripoli\nAfrica/Tunis\nAfrica/Windhoek\nAmerica/Adak\nAmerica/Anchorage\nAmerica/Anguilla\nAmerica/Antigua\nAmerica/Araguaina\nAmerica/Argentina/Buenos_Aires\nAmerica/Argentina/Catamarca\nAmerica/Argentina/ComodRivadavia\nAmerica/Argentina/Cordoba\nAmerica/Argentina/Jujuy\nAmerica/Argentina/La_Rioja\nAmerica/Argentina/Mendoza\nAmerica/Argentina/Rio_Gallegos\nAmerica/Argentina/Salta\nAmerica/Argentina/San_Juan\nAmerica/Argentina/San_Luis\nAmerica/Argentina/Tucuman\nAmerica/Argentina/Ushuaia\nAmerica/Aruba\nAmerica/Asuncion\nAmerica/Atikokan\nAmerica/Atka\nAmerica/Bahia\nAmerica/Bahia_Banderas\nAmerica/Barbados\nAmerica/Belem\nAmerica/Belize\nAmerica/Blanc-Sablon\nAmerica/Boa_Vista\nAmerica/Bogota\nAmerica/Boise\nAmerica/Buenos_Aires\nAmerica/Cambridge_Bay\nAmerica/Campo_Grande\nAmerica/Cancun\nAmerica/Caracas\nAmerica/Catamarca\nAmerica/Cayenne\nAmerica/Cayman\nAmerica/Chicago\nAmerica/Chihuahua\nAmerica/Ciudad_Juarez\nAmerica/Coral_Harbour\nAmerica/Cordoba\nAmerica/Costa_Rica\nAmerica/Coyhaique\nAmerica/Creston\nAmerica/Cuiaba\nAmerica/Curacao\nAmerica/Danmarkshavn\nAmerica/Dawson\nAmerica/Dawson_Creek\nAmerica/Denver\nAmerica/Detroit\nAmerica/Dominica\nAmerica/Edmonton\nAmerica/Eirunepe\nAmerica/El_Salvador\nAmerica/Ensenada\nAmerica/Fort_Nelson\nAmerica/Fort_Wayne\nAmerica/Fortaleza\nAmerica/Glace_Bay\nAmerica/Godthab\nAmerica/Goose_Bay\nAmerica/Grand_Turk\nAmerica/Grenada\nAmerica/Guadeloupe\nAmerica/Guatemala\nAmerica/Guayaquil\nAmerica/Guyana\nAmerica/Halifax\nAmerica/Havana\nAmerica/Hermosillo\nAmerica/Indiana/Indianapolis\nAmerica/Indiana/Knox\nAmerica/Indiana/Marengo\nAmerica/Indiana/Petersburg\nAmerica/Indiana/Tell_City\nAmerica/Indiana/Vevay\nAmerica/Indiana/Vincennes\nAmerica/Indiana/Winamac\nAmerica/Indianapolis\nAmerica/Inuvik\nAmerica/Iqaluit\nAmerica/Jamaica\nAmerica/Jujuy\nAmerica/Juneau\nAmerica/Kentucky/Louisville\nAmerica/Kentucky/Monticello\nAmerica/Knox_IN\nAmerica/Kralendijk\nAmerica/La_Paz\nAmerica/Lima\nAmerica/Los_Angeles\nAmerica/Louisville\nAmerica/Lower_Princes\nAmerica/Maceio\nAmerica/Managua\nAmerica/Manaus\nAmerica/Marigot\nAmerica/Martinique\nAmerica/Matamoros\nAmerica/Mazatlan\nAmerica/Mendoza\nAmerica/Menominee\nAmerica/Merida\nAmerica/Metlakatla\nAmerica/Mexico_City\nAmerica/Miquelon\nAmerica/Moncton\nAmerica/Monterrey\nAmerica/Montevideo\nAmerica/Montreal\nAmerica/Montserrat\nAmerica/Nassau\nAmerica/New_York\nAmerica/Nipigon\nAmerica/Nome\nAmerica/Noronha\nAmerica/North_Dakota/Beulah\nAmerica/North_Dakota/Center\nAmerica/North_Dakota/New_Salem\nAmerica/Nuuk\nAmerica/Ojinaga\nAmerica/Panama\nAmerica/Pangnirtung\nAmerica/Paramaribo\nAmerica/Phoenix\nAmerica/Port-au-Prince\nAmerica/Port_of_Spain\nAmerica/Porto_Acre\nAmerica/Porto_Velho\nAmerica/Puerto_Rico\nAmerica/Punta_Arenas\nAmerica/Rainy_River\nAmerica/Rankin_Inlet\nAmerica/Recife\nAmerica/Regina\nAmerica/Resolute\nAmerica/Rio_Branco\nAmerica/Rosario\nAmerica/Santa_Isabel\nAmerica/Santarem\nAmerica/Santiago\nAmerica/Santo_Domingo\nAmerica/Sao_Paulo\nAmerica/Scoresbysund\nAmerica/Shiprock\nAmerica/Sitka\nAmerica/St_Barthelemy\nAmerica/St_Johns\nAmerica/St_Kitts\nAmerica/St_Lucia\nAmerica/St_Thomas\nAmerica/St_Vincent\nAmerica/Swift_Current\nAmerica/Tegucigalpa\nAmerica/Thule\nAmerica/Thunder_Bay\nAmerica/Tijuana\nAmerica/Toronto\nAmerica/Tortola\nAmerica/Vancouver\nAmerica/Virgin\nAmerica/Whitehorse\nAmerica/Winnipeg\nAmerica/Yakutat\nAmerica/Yellowknife\nAntarctica/Casey\nAntarctica/Davis\nAntarctica/DumontDUrville\nAntarctica/Macquarie\nAntarctica/Mawson\nAntarctica/McMurdo\nAntarctica/Palmer\nAntarctica/Rothera\nAntarctica/South_Pole\nAntarctica/Syowa\nAntarctica/Troll\nAntarctica/Vostok\nArctic/Longyearbyen\nAsia/Aden\nAsia/Almaty\nAsia/Amman\nAsia/Anadyr\nAsia/Aqtau\nAsia/Aqtobe\nAsia/Ashgabat\nAsia/Ashkhabad\nAsia/Atyrau\nAsia/Baghdad\nAsia/Bahrain\nAsia/Baku\nAsia/Bangkok\nAsia/Barnaul\nAsia/Beirut\nAsia/Bishkek\nAsia/Brunei\nAsia/Calcutta\nAsia/Chita\nAsia/Choibalsan\nAsia/Chongqing\nAsia/Chungking\nAsia/Colombo\nAsia/Dacca\nAsia/Damascus\nAsia/Dhaka\nAsia/Dili\nAsia/Dubai\nAsia/Dushanbe\nAsia/Famagusta\nAsia/Gaza\nAsia/Harbin\nAsia/Hebron\nAsia/Ho_Chi_Minh\nAsia/Hong_Kong\nAsia/Hovd\nAsia/Irkutsk\nAsia/Istanbul\nAsia/Jakarta\nAsia/Jayapura\nAsia/Jerusalem\nAsia/Kabul\nAsia/Kamchatka\nAsia/Karachi\nAsia/Kashgar\nAsia/Kathmandu\nAsia/Katmandu\nAsia/Khandyga\nAsia/Kolkata\nAsia/Krasnoyarsk\nAsia/Kuala_Lumpur\nAsia/Kuching\nAsia/Kuwait\nAsia/Macao\nAsia/Macau\nAsia/Magadan\nAsia/Makassar\nAsia/Manila\nAsia/Muscat\nAsia/Nicosia\nAsia/Novokuznetsk\nAsia/Novosibirsk\nAsia/Omsk\nAsia/Oral\nAsia/Phnom_Penh\nAsia/Pontianak\nAsia/Pyongyang\nAsia/Qatar\nAsia/Qostanay\nAsia/Qyzylorda\nAsia/Rangoon\nAsia/Riyadh\nAsia/Saigon\nAsia/Sakhalin\nAsia/Samarkand\nAsia/Seoul\nAsia/Shanghai\nAsia/Singapore\nAsia/Srednekolymsk\nAsia/Taipei\nAsia/Tashkent\nAsia/Tbilisi\nAsia/Tehran\nAsia/Tel_Aviv\nAsia/Thimbu\nAsia/Thimphu\nAsia/Tokyo\nAsia/Tomsk\nAsia/Ujung_Pandang\nAsia/Ulaanbaatar\nAsia/Ulan_Bator\nAsia/Urumqi\nAsia/Ust-Nera\nAsia/Vientiane\nAsia/Vladivostok\nAsia/Yakutsk\nAsia/Yangon\nAsia/Yekaterinburg\nAsia/Yerevan\nAtlantic/Azores\nAtlantic/Bermuda\nAtlantic/Canary\nAtlantic/Cape_Verde\nAtlantic/Faeroe\nAtlantic/Faroe\nAtlantic/Jan_Mayen\nAtlantic/Madeira\nAtlantic/Reykjavik\nAtlantic/South_Georgia\nAtlantic/St_Helena\nAtlantic/Stanley\nAustralia/ACT\nAustralia/Adelaide\nAustralia/Brisbane\nAustralia/Broken_Hill\nAustralia/Canberra\nAustralia/Currie\nAustralia/Darwin\nAustralia/Eucla\nAustralia/Hobart\nAustralia/LHI\nAustralia/Lindeman\nAustralia/Lord_Howe\nAustralia/Melbourne\nAustralia/NSW\nAustralia/North\nAustralia/Perth\nAustralia/Queensland\nAustralia/South\nAustralia/Sydney\nAustralia/Tasmania\nAustralia/Victoria\nAustralia/West\nAustralia/Yancowinna\nBrazil/Acre\nBrazil/DeNoronha\nBrazil/East\nBrazil/West\nCET\nCST6CDT\nCanada/Atlantic\nCanada/Central\nCanada/Eastern\nCanada/Mountain\nCanada/Newfoundland\nCanada/Pacific\nCanada/Saskatchewan\nCanada/Yukon\nChile/Continental\nChile/EasterIsland\nCuba\nEET\nEST\nEST5EDT\nEgypt\nEire\nEtc/GMT\nEtc/GMT+0\nEtc/GMT+1\nEtc/GMT+10\nEtc/GMT+11\nEtc/GMT+12\nEtc/GMT+2\nEtc/GMT+3\nEtc/GMT+4\nEtc/GMT+5\nEtc/GMT+6\nEtc/GMT+7\nEtc/GMT+8\nEtc/GMT+9\nEtc/GMT-0\nEtc/GMT-1\nEtc/GMT-10\nEtc/GMT-11\nEtc/GMT-12\nEtc/GMT-13\nEtc/GMT-14\nEtc/GMT-2\nEtc/GMT-3\nEtc/GMT-4\nEtc/GMT-5\nEtc/GMT-6\nEtc/GMT-7\nEtc/GMT-8\nEtc/GMT-9\nEtc/GMT0\nEtc/Greenwich\nEtc/UCT\nEtc/UTC\nEtc/Universal\nEtc/Zulu\nEurope/Amsterdam\nEurope/Andorra\nEurope/Astrakhan\nEurope/Athens\nEurope/Belfast\nEurope/Belgrade\nEurope/Berlin\nEurope/Bratislava\nEurope/Brussels\nEurope/Bucharest\nEurope/Budapest\nEurope/Busingen\nEurope/Chisinau\nEurope/Copenhagen\nEurope/Dublin\nEurope/Gibraltar\nEurope/Guernsey\nEurope/Helsinki\nEurope/Isle_of_Man\nEurope/Istanbul\nEurope/Jersey\nEurope/Kaliningrad\nEurope/Kiev\nEurope/Kirov\nEurope/Kyiv\nEurope/Lisbon\nEurope/Ljubljana\nEurope/London\nEurope/Luxembourg\nEurope/Madrid\nEurope/Malta\nEurope/Mariehamn\nEurope/Minsk\nEurope/Monaco\nEurope/Moscow\nEurope/Nicosia\nEurope/Oslo\nEurope/Paris\nEurope/Podgorica\nEurope/Prague\nEurope/Riga\nEurope/Rome\nEurope/Samara\nEurope/San_Marino\nEurope/Sarajevo\nEurope/Saratov\nEurope/Simferopol\nEurope/Skopje\nEurope/Sofia\nEurope/Stockholm\nEurope/Tallinn\nEurope/Tirane\nEurope/Tiraspol\nEurope/Ulyanovsk\nEurope/Uzhgorod\nEurope/Vaduz\nEurope/Vatican\nEurope/Vienna\nEurope/Vilnius\nEurope/Volgograd\nEurope/Warsaw\nEurope/Zagreb\nEurope/Zaporozhye\nEurope/Zurich\nFactory\nGB\nGB-Eire\nGMT\nGMT+0\nGMT-0\nGMT0\nGreenwich\nHST\nHongkong\nIceland\nIndian/Antananarivo\nIndian/Chagos\nIndian/Christmas\nIndian/Cocos\nIndian/Comoro\nIndian/Kerguelen\nIndian/Mahe\nIndian/Maldives\nIndian/Mauritius\nIndian/Mayotte\nIndian/Reunion\nIran\nIsrael\nJamaica\nJapan\nKwajalein\nLibya\nMET\nMST\nMST7MDT\nMexico/BajaNorte\nMexico/BajaSur\nMexico/General\nNZ\nNZ-CHAT\nNavajo\nPRC\nPST8PDT\nPacific/Apia\nPacific/Auckland\nPacific/Bougainville\nPacific/Chatham\nPacific/Chuuk\nPacific/Easter\nPacific/Efate\nPacific/Enderbury\nPacific/Fakaofo\nPacific/Fiji\nPacific/Funafuti\nPacific/Galapagos\nPacific/Gambier\nPacific/Guadalcanal\nPacific/Guam\nPacific/Honolulu\nPacific/Johnston\nPacific/Kanton\nPacific/Kiritimati\nPacific/Kosrae\nPacific/Kwajalein\nPacific/Majuro\nPacific/Marquesas\nPacific/Midway\nPacific/Nauru\nPacific/Niue\nPacific/Norfolk\nPacific/Noumea\nPacific/Pago_Pago\nPacific/Palau\nPacific/Pitcairn\nPacific/Pohnpei\nPacific/Ponape\nPacific/Port_Moresby\nPacific/Rarotonga\nPacific/Saipan\nPacific/Samoa\nPacific/Tahiti\nPacific/Tarawa\nPacific/Tongatapu\nPacific/Truk\nPacific/Wake\nPacific/Wallis\nPacific/Yap\nPoland\nPortugal\nROC\nROK\nSingapore\nTurkey\nUCT\nUS/Alaska\nUS/Aleutian\nUS/Arizona\nUS/Central\nUS/East-Indiana\nUS/Eastern\nUS/Hawaii\nUS/Indiana-Starke\nUS/Michigan\nUS/Mountain\nUS/Pacific\nUS/Samoa\nUTC\nUniversal\nW-SU\nWET\nZulu\nlocaltime\n\n\n\n\n\n\n\n\nAlles ist relativ: die Epoche\nPython speichert Zeit relativ zu einem zeitlichen Bezugspunkt, der Unix-Zeit, der sogenannten Epoche. Die Epoche kann mit der Funktion pd.to_datetime(0) ausgegeben werden. Die Funktion konvertiert Argumente in Zeitpunkte (Timestamp). Ganzzahlen werden dabei als Nanosekunden seit der Epoche interpretiert. Die Funktion werden wir später noch ausführlicher behandeln.\n\nimport pandas as pd\nprint(pd.to_datetime(0))\n\n1970-01-01 00:00:00\n\n\n\n\n\n\n\n\nHinweis 5.1: Zeit - atomar, koordiniert oder universal?\n\n\n\n\n\nNumPy nutzt die Internationale Atomzeit (abgekürzt TAI für französisch Temps Atomique International). Diese nimmt für jeden Kalendertag eine Länge von 86.400 Sekunden an, kennt also keine Schaltsekunde. Die Atomzeit bildet die Grundlage für die koordinierte Weltzeit UTC.\nUTC steht für Coordinated Universal Time (auch bekannt als Greenwich Mean Time). Das Kürzel UTC ist ein Kompromiss für die englische und die französische Sprache. Die koordinierte Weltzeit gleicht die Verlangsamung der Erdrotation (astronomisch gemessen als Universalzeit, Universal Time UT) durch Schaltsekunden aus, um die geringfügige Verlängerung eines Tages auszugleichen. Die TAI geht deshalb gegenüber der UTC vor. Seit 1972 unterscheiden sich beide Zeiten um eine ganzzahlige Anzahl von Sekunden. Aktuell (2024) geht die TAI 37 Sekunden gegenüber UTC vor.\nEine Umwandlung in die koordinierte Weltzeit ist in NumPy bislang noch nicht umgesetzt. (Dokumentation NumPy, Wikipedia).\n\n\n\n\n\nZeitumstellung - Dailight Saving Time\n\n\n\n\n\n\n \n\n\n“DST is Daylight Saving Time, an adjustment of the timezone by (usually) one hour during part of the year. DST rules are magic (determined by local law) and can change from year to year. The C library has a table containing the local rules (often it is read from a system file for flexibility) and is the only source of True Wisdom in this respect.” (Dokumentation time)\n\n\n \n\n\n\n \nPandas arbeitet standardmäßig mit der koordinierten Weltzeit UTC. Die UTC selbst ist keine Zeitzone und kennt deshalb keine Zeitumstellung. Die Zeitumstellung wird abhängig von der Zeitzone berücksichtigt. Beispielsweise wurde die Zeitumstellung in der Türkei 2016 abgeschafft (und die Sommerzeit dauerhaft eingeführt).\nIn den folgenden Beispielen wird am Tag vor der Zeitumstellung um 9 Uhr eine Zeitdifferenz von 24 Stunden addiert. Da über die Nacht (der Morgen des Folgetages) die Uhr um eine Stunde vorgestellt wird, zeigt der resultierende Zeitstempel die Uhrzeit 10 Uhr an, sofern die Zeitumstellung gilt.\n\nprint(\"Keine Zeitumstellung in UTC:\")\nprint(pd.Timestamp(\"2025-03-29T09:00\") + pd.Timedelta(24, \"h\"), \"\\n\")\n\nprint(\"Zeitzone mit Zeitumstellung:\")\nprint(pd.Timestamp(\"2025-03-29T09:00\", tz=\"Europe/Berlin\") + pd.Timedelta(24, \"h\"), \"\\n\")\n\nprint(\"Heute keine Zeitumstellung in Türkei:\")\nprint(pd.Timestamp(\"2025-03-29T09:00\", tz=\"Turkey\") + pd.Timedelta(24, \"h\"), \"\\n\")\n\nprint(\"Türkei vor der Abschaffung der Zeitumstellung:\")\nprint(pd.Timestamp(\"2014-03-30T09:00\", tz=\"Turkey\")  + pd.Timedelta(24, \"h\"))\n\nKeine Zeitumstellung in UTC:\n2025-03-30 09:00:00 \n\nZeitzone mit Zeitumstellung:\n2025-03-30 10:00:00+02:00 \n\nHeute keine Zeitumstellung in Türkei:\n2025-03-30 09:00:00+03:00 \n\nTürkei vor der Abschaffung der Zeitumstellung:\n2014-03-31 10:00:00+03:00\n\n\nEine Liste der Zeitzonen finden Sie auf Wikipedia: https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\n\n\nKalender\nDie Module calendar, NumPy und Pandas verwenden den um die Zeit vor seiner Einführung 1582 erweiterten Gregorianische Kalender, den proleptischen Gregorianischen Kalender. Während das Modul date nur die Jahre 1-9999 nach unserer Zeit unterstützt, erlaubt der Datentyp datetime64 auch Jahre vor unserer Zeit in astronomischer Jahresnumerierung. Das bedeutet, es gibt ein Jahr 0 (das erste Jahr vor unserer Zeit) und vorausgehende Jahre werden mit negativen Zahlen dargestellt (-1 ist das zweite Jahr vor unserer Zeit). NumPy Dokumentation",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Zeitreihen</span>"
    ]
  },
  {
    "objectID": "skript/datetime.html#datetime-in-pandas",
    "href": "skript/datetime.html#datetime-in-pandas",
    "title": "5  Zeitreihen",
    "section": "5.2 datetime in Pandas",
    "text": "5.2 datetime in Pandas\nPandas nutzt den NumPy-Datentyp datetime64, um Datums- und Zeitinformationen zu verarbeiten. In Pandas werden datetime64-Objekte mit den Funktionen pd.to_datetime() oder pd.date_range() angelegt.\nHinweis: Eine weitere Möglichkeit ist die Funktion pd.Timestamp(), die umfangreichere Möglichkeiten zur Erzeugung eines Zeitpunkts bietet, aber kein string-parsing unterstützt.\npd.to_datetime() erzeugt Werte des Datentyps datetime64[ns] (mit pd.to_datetime() erzeugte Skalare (Einzelwerte) werden als Timestamp (Zeitpunkt) ausgegeben, die kein Attribut dtype haben). Die Funktion pd.to_datetime() akzeptiert als Eingabewerte:\n\ndatetime-Objekte anderer Module.\nZahlen und eine Zeiteinheit pd.to_datetime(1, unit = None) (Standard sind Nanosekunden). Das Argument unit nimmt die Werte ‘ns’, ‘ms’, ‘s’, ‘m’, ‘h’, ‘D’, ‘W’, ‘M’, ‘Y’ für Nanosekunde, Millisekunde, Sekunde, Minute, Stunde, Tag, Woche, Monat bzw. Jahr entgegen. Erzeugt wird ein Zeitpunkt relativ zur Epoche.\n\n\nprint(pd.to_datetime(1000, unit = 'D'))\nprint(pd.to_datetime(1000 * 1000, unit = 'h'))\nprint(pd.to_datetime(1000 * 1000 * 1000, unit = 's'))\n\n1972-09-27 00:00:00\n2084-01-29 16:00:00\n2001-09-09 01:46:40\n\n\n\nZeichenketten, die ein Datum oder ein Datum mit Uhrzeit ausdrücken, formatiert nach ISO 8601.\n\n\nprint(pd.to_datetime('2017'))\nprint(pd.to_datetime('2017-01-01T00'))\nprint(pd.to_datetime('2017-01-01 00:00:00'))\n\n2017-01-01 00:00:00\n2017-01-01 00:00:00\n2017-01-01 00:00:00\n\n\n\nAnders formatierte Zeichenketten mit dem Argument format = \"%d/%m/%Y\" (siehe Dokumentation strftime zur string-Formatierung).\n\n\nprint(pd.to_datetime('Monday, 12. August `24', format = \"%A, %d. %B `%y\"))\nprint(pd.to_datetime('Monday, 12. August 2024, 12:15 Uhr CET', format = \"%A, %d. %B %Y, %H:%M Uhr %Z\"))\n\n2024-08-12 00:00:00\n2024-08-12 12:15:00+02:00\n\n\n\nDictionary oder DataFrame.\n\n\nprint(pd.to_datetime({'year':[2020, 2024], 'month': [1, 11], 'day': [1, 21]}), \"\\n\")\nprint(pd.to_datetime(pd.DataFrame({'year':[2020, 2024], 'month': [1, 11], 'day': [1, 21]})))\n\n0   2020-01-01\n1   2024-11-21\ndtype: datetime64[ns] \n\n0   2020-01-01\n1   2024-11-21\ndtype: datetime64[ns]\n\n\nDie Funktion pd.date_range() erzeugt ein Array vom Typ DatetimeIndex mit dtype datetime64. Genau drei der folgenden vier Argumente sind für die Erzeugung erforderlich:\n\nstart: Beginn der Reihe.\nend: Ende der Reihe (inklusiv)\nfreq: Schrittweite (bspw. Jahr, Tag, Geschäftstag, Stunde oder Vielfache wie ‘6h’ - siehe Liste verfügbarer strings)\nperiods: Anzahl der zu erzeugenden Werte.\n\n\nprint(pd.date_range(start = '2017', end = '2024', periods = 3), \"\\n\")\n\nprint(pd.date_range(start = '2017', end = '2024', freq = 'Y'), \"\\n\")\n\nprint(pd.date_range(end = '2024', freq = 'h', periods = 3))\n\nDatetimeIndex(['2017-01-01', '2020-07-02', '2024-01-01'], dtype='datetime64[ns]', freq=None) \n\nDatetimeIndex(['2017-12-31', '2018-12-31', '2019-12-31', '2020-12-31',\n               '2021-12-31', '2022-12-31', '2023-12-31'],\n              dtype='datetime64[ns]', freq='YE-DEC') \n\nDatetimeIndex(['2023-12-31 22:00:00', '2023-12-31 23:00:00',\n               '2024-01-01 00:00:00'],\n              dtype='datetime64[ns]', freq='h')\n\n\n\n\n\n\n\n\nHinweis 5.2: pd.date_range()\n\n\n\n\n\nDie Funktion pd.date_range() wird künftig das Kürzel ‘Y’ nicht mehr unterstützen. Stattdessen können die Kürzel ‘YS’ (Jahresbeginn) oder ‘YE’ (Jahresende) verwendet werden. Ebenso wird das Kürzel ‘M’ künftig durch ‘MS’ (Monatsstart), ‘ME’ (Monatsende) ersetzt.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Zeitreihen</span>"
    ]
  },
  {
    "objectID": "skript/datetime.html#timedelta-in-pandas",
    "href": "skript/datetime.html#timedelta-in-pandas",
    "title": "5  Zeitreihen",
    "section": "5.3 timedelta in Pandas",
    "text": "5.3 timedelta in Pandas\nZeitdifferenzen werden mit der Funktion pd.Timedelta() erzeugt. Zeitdifferenzen können zum einen durch Angabe einer Ganzzahl und einer Zeiteinheit angelegt werden. Außerdem ist die Übergabe mit Argumenten möglich (zulässige Argumente sind: weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds).\n\nprint(pd.Timedelta(1, 'D'))\nprint(pd.Timedelta(days = 1, hours = 1))\n\n1 days 00:00:00\n1 days 01:00:00\n\n\nWichtig: Anders als in NumPy werden Zeitdifferenzen in Monaten und Jahren nicht mehr von Pandas unterstützt.\n\ntry:\n  print(pd.Timedelta(1, 'Y'))\nexcept ValueError as error:\n  print(error)\nelse:\n  print(pd.Timedelta(1, 'Y'))\n\nUnits 'M', 'Y', and 'y' are no longer supported, as they do not represent unambiguous timedelta values durations.\n\n\nZum anderen können Zeitdifferenzen mit einer Zeichenkette erzeugt werden.\n\nprint(pd.Timedelta('10sec'))\nprint(pd.Timedelta('10min'))\nprint(pd.Timedelta('10hours'))\nprint(pd.Timedelta('10days'))\nprint(pd.Timedelta('10w'))\n\n0 days 00:00:10\n0 days 00:10:00\n0 days 10:00:00\n10 days 00:00:00\n70 days 00:00:00\n\n\nMit Hilfe einer Zeitdifferenz können Zeitreihen leicht verschoben werden.\n\npd.date_range(start = '2024-01-01T00:00', end = '2024-01-01T02:00', freq = '15min') + pd.Timedelta('30min')\n\nDatetimeIndex(['2024-01-01 00:30:00', '2024-01-01 00:45:00',\n               '2024-01-01 01:00:00', '2024-01-01 01:15:00',\n               '2024-01-01 01:30:00', '2024-01-01 01:45:00',\n               '2024-01-01 02:00:00', '2024-01-01 02:15:00',\n               '2024-01-01 02:30:00'],\n              dtype='datetime64[ns]', freq='15min')",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Zeitreihen</span>"
    ]
  },
  {
    "objectID": "skript/datetime.html#zugriff-auf-zeitreihen",
    "href": "skript/datetime.html#zugriff-auf-zeitreihen",
    "title": "5  Zeitreihen",
    "section": "5.4 Zugriff auf Zeitreihen",
    "text": "5.4 Zugriff auf Zeitreihen\nPandas bietet zahlreiche Attribute und Methoden, um Informationen aus datetime64-Objekten auszulesen. Eine Übersicht aller verfügbaren Attribute und Methoden liefert dir(pd.to_datetime(0)) bzw. der im folgenden Beispiel gezeigte Code.\n\n# Attribute\nprint(\"Jahr:\", pd.to_datetime(0).year)\nprint(\"Monat:\", pd.to_datetime(0).month)\nprint(\"Tag:\", pd.to_datetime(0).day)\nprint(\"Stunde:\", pd.to_datetime(0).hour)\nprint(\"Minute:\", pd.to_datetime(0).minute)\nprint(\"Sekunde:\", pd.to_datetime(0).second)\nprint(\"Tag des Jahres:\", pd.to_datetime(0).dayofyear)\nprint(\"Wochentag:\", pd.to_datetime(0).dayofweek)\nprint(\"Tage im Monat:\", pd.to_datetime(0).days_in_month)\nprint(\"Schaltjahr:\", pd.to_datetime(0).is_leap_year)\n\n# Methoden\nprint(\"\\nDatum:\", pd.to_datetime(0).date())\nprint(\"Zeit:\", pd.to_datetime(0).time())\nprint(\"Wochentag (0-6):\", pd.to_datetime(0).weekday())\nprint(\"Monatsname:\",  pd.to_datetime(0).month_name())\n\nJahr: 1970\nMonat: 1\nTag: 1\nStunde: 0\nMinute: 0\nSekunde: 0\nTag des Jahres: 1\nWochentag: 3\nTage im Monat: 31\nSchaltjahr: False\n\nDatum: 1970-01-01\nZeit: 00:00:00\nWochentag (0-6): 3\nMonatsname: January\n\n\n\n\n\n\n\n\nBeispiel 5.2: Attribute und Methoden eines datetime-Objekts\n\n\n\n\n\n\nobjekt = pd.to_datetime(0)\n\nattribute = [attr for attr in dir(objekt) if not (callable(getattr(objekt, attr)) or attr.startswith('_'))]\nprint(\"Attribute:\")\nprint(30 * \"=\")\nprint(attribute)\n\nmethoden = [attr for attr in dir(objekt) if (callable(getattr(objekt, attr)) and not attr.startswith('__'))]\nprint(\"\\nMethoden:\")\nprint(30 * \"=\")\nprint(methoden)\n\nAttribute:\n==============================\n['asm8', 'day', 'day_of_week', 'day_of_year', 'dayofweek', 'dayofyear', 'days_in_month', 'daysinmonth', 'fold', 'hour', 'is_leap_year', 'is_month_end', 'is_month_start', 'is_quarter_end', 'is_quarter_start', 'is_year_end', 'is_year_start', 'max', 'microsecond', 'min', 'minute', 'month', 'nanosecond', 'quarter', 'resolution', 'second', 'tz', 'tzinfo', 'unit', 'value', 'week', 'weekofyear', 'year']\n\nMethoden:\n==============================\n['_from_dt64', '_from_value_and_reso', '_round', 'as_unit', 'astimezone', 'ceil', 'combine', 'ctime', 'date', 'day_name', 'dst', 'floor', 'fromisocalendar', 'fromisoformat', 'fromordinal', 'fromtimestamp', 'isocalendar', 'isoformat', 'isoweekday', 'month_name', 'normalize', 'now', 'replace', 'round', 'strftime', 'strptime', 'time', 'timestamp', 'timetuple', 'timetz', 'to_datetime64', 'to_julian_date', 'to_numpy', 'to_period', 'to_pydatetime', 'today', 'toordinal', 'tz_convert', 'tz_localize', 'tzname', 'utcfromtimestamp', 'utcnow', 'utcoffset', 'utctimetuple', 'weekday']\n\n\n\n\n\nFür pd.Series erfolgt der Zugriff über den .dt-Operator (siehe .dt accessor). Der Zugriff auf verschiedene Informationen über ein Attribut (ohne Klammern) oder über eine Methode (mit Klammern) unterscheidet sich jedoch teilweise (siehe folgendes Beispiel).\n\n\n\n\n\n\nDer dt-Operator\n\n\n\n\n\n\n# Attribute\nprint(\"Datum:\", pd.Series(pd.to_datetime(0)).dt.date) # Unterschied\nprint(\"Zeit:\", pd.Series(pd.to_datetime(0)).dt.time) # Unterschied\nprint(\"Jahr\", pd.Series(pd.to_datetime(0)).dt.year)\nprint(\"Monat\", pd.Series(pd.to_datetime(0)).dt.month)\nprint(\"Tag\", pd.Series(pd.to_datetime(0)).dt.day)\nprint(\"Stunde\", pd.Series(pd.to_datetime(0)).dt.hour)\nprint(\"Minute\", pd.Series(pd.to_datetime(0)).dt.minute)\nprint(\"Sekunde\", pd.Series(pd.to_datetime(0)).dt.second)\n\nprint(\"\\nTag des Jahres\", pd.Series(pd.to_datetime(0)).dt.dayofyear)\nprint(\"Wochentag:\", pd.Series(pd.to_datetime(0)).dt.dayofweek)\nprint(\"Wochentag:\", pd.Series(pd.to_datetime(0)).dt.weekday) # Unterschied\nprint(\"Tage im Monat:\", pd.Series(pd.to_datetime(0)).dt.days_in_month)\nprint(\"Schaltjahr:\", pd.Series(pd.to_datetime(0)).dt.is_leap_year)\n\n# Methoden\nprint(\"\\nName des Monats:\", pd.Series(pd.to_datetime(0)).dt.month_name())\n\nDatum: 0    1970-01-01\ndtype: object\nZeit: 0    00:00:00\ndtype: object\nJahr 0    1970\ndtype: int32\nMonat 0    1\ndtype: int32\nTag 0    1\ndtype: int32\nStunde 0    0\ndtype: int32\nMinute 0    0\ndtype: int32\nSekunde 0    0\ndtype: int32\n\nTag des Jahres 0    1\ndtype: int32\nWochentag: 0    3\ndtype: int32\nWochentag: 0    3\ndtype: int32\nTage im Monat: 0    31\ndtype: int32\nSchaltjahr: 0    False\ndtype: bool\n\nName des Monats: 0    January\ndtype: object",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Zeitreihen</span>"
    ]
  },
  {
    "objectID": "skript/datetime.html#aufgaben",
    "href": "skript/datetime.html#aufgaben",
    "title": "5  Zeitreihen",
    "section": "5.5 Aufgaben",
    "text": "5.5 Aufgaben\n\nWie alt sind Sie in Tagen? Wie alt in Sekunden?\nAn welchem Wochentag war ihr Geburtstag?\nWie viele Tage sind es noch bis Weihnachten?\nErstellen Sie eine Liste aller Schaltjahre im 20. Jahrhundert.\n\n\n\n\n\n\n\nTipp 5.1: Musterlösung\n\n\n\n\n\nAufgabe 1\nErsetzen sie in der Lösung die Zeichenkette ‘YYYY-MM-DD’ bzw., wenn Sie die Uhrzeit Ihrer Geburt kennen, die Zeichenkette ‘YYYY-MM-DDTHH:MM’ durch Ihren Geburtstag.\nIn Pandas werden die Schlüsselwörter pd.to_datetime('today') und pd.to_datetime('now') in Nanosekunden aufgelöst.\nprint((pd.to_datetime('today') - pd.to_datetime('YYYY-MM-DD')).days)\nprint(pd.to_datetime('now') - pd.to_datetime('YYYY-MM-DDTHH:MM')).total_seconds())\nAufgabe 2\n´´´ {.raw} print(pd.to_datetime(‘YYYY-MM-DD’).day_of_week) ´´´\nAufgabe 3\n(pd.to_datetime('2025-12-25') - pd.to_datetime('now')).days\nAufgabe 4\n\nschaltjahre = pd.date_range(start = '1901', end = '2000', freq = 'Y')\nschaltjahre = schaltjahre[schaltjahre.is_leap_year]\nprint(schaltjahre.year)\n\nIndex([1904, 1908, 1912, 1916, 1920, 1924, 1928, 1932, 1936, 1940, 1944, 1948,\n       1952, 1956, 1960, 1964, 1968, 1972, 1976, 1980, 1984, 1988, 1992, 1996],\n      dtype='int32')\n\n\n/tmp/ipykernel_4052/3713700613.py:1: FutureWarning: 'Y' is deprecated and will be removed in a future version, please use 'YE' instead.\n  schaltjahre = pd.date_range(start = '1901', end = '2000', freq = 'Y')",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Zeitreihen</span>"
    ]
  },
  {
    "objectID": "skript/dateien.html",
    "href": "skript/dateien.html",
    "title": "6  Dateien lesen und schreiben",
    "section": "",
    "text": "6.1 Zeitreihen einlesen\nPandas bietet eine Reihe von Funktionen, um Dateien einzulesen und zu schreiben, deren Namensgebung einem einheitlichen Schema folgt. Funktionen zum Lesen von Dateien werden in der Form pd.read_csv() und Funktionen zum Schreiben in der Form pd.to_csv() aufgerufen. Mit Pandas können auch Dateien aus dem Internet abgerufen werden pd.read_csv(URL).\nIm Folgenden wird der Datensatz palmerpenguins mit Pandas eingelesen.\nDie Funktionen zum Lesen von Dateien erwarten eine Pfadangabe, die positional oder mit einem Schlüsselwort übergeben werden kann. Das Schlüsselwort für die Pfadangabe variiert abhängig vom Dateityp und lautet für eine kommaseparierte CSV-Datei filepath_or_buffer.\nEin Blick auf die Daten mit der Methode penguins.head():\nEinen Überblick über den Datensatz verschafft die Methode DataFrame.info().\nEinige Datentypen wurden nicht erkannt. Den betreffenden Spalten wurde der Sammeltyp object zugeordnet. Den Funktionen zum Einlesen von Daten kann mit dem Argument dtype der Datentyp übergeben werden. Für mehrere Spalten ist dies in Form eines Dictionaries in der Form {'Spaltenname': 'dtype'} möglich. Mit der Methode DataFrame.astype() ist dies auch nachträglich möglich.\nEinige Spalten weisen ungültige Werte auf. Die Tiere mit unvollständigen Werten sollen aus dem Datensatz entfernt werden.\nKontrolle:\nMit Pandas ist es leicht möglich, Zeitreihen einzulesen. Durch string parsing können beliebige Zeichenketten als datetime interpretiert werden.\nWenn der innere Aufbau einer Datei bekannt ist, können die notwendigen Parameter direkt beim Einlesen beispielsweise mit pd.read_csv() übergeben werden. Dazu werden die Parameter parse_dates und date_format verwendet.\nparse_dates gibt an, an welcher Stelle sich datetime-Informationen befinden. Es können verschiedene Argumente übergeben werden.\nPandas interpretiert die Zeichenketten nach ISO 8601 als Repräsentation eines Datums in der festgelegten Reihenfolge Jahr, Monat, Tag, Stunde, Minute, Sekunde, Millisekunde im Format YYYY-MM-DD 12:00:00.000. Als Zeichentrenner zwischen Datum und Uhrzeit sind ein Leerzeichen oder der Buchstabe T zulässig. Der Datentyp und die kleinste verwendete Einheit werden im Attribut dtype gespeichert.\nAndere Formate werden mit dem Parameter date_format spezifiziert. Mit Hilfe der strftime-Dokumentation kann das Datumsformat übergeben werden.\nDatumsinformationen können aber auch nachträglich als solche deklariert werden. Dafür wird die Funktion pd.to_datetime(arg, format = \" ... \") verwendet. Mit dem Parameter arg wird die zu konvertierende Spalte übergeben. Mit dem Parameter format kann wie mit dem Parameter date_format ein von der ISO8601 abweichendes Datumsformat spezifiziert werden.\nUnter dem Pfad ‘01-daten/Microsoft_Stock.csv’ sind Kursdaten der Microsoft-Aktie gespeichert.\nIn der Spalte Date sind Datums- und Zeitinformationen in der Form ‘Monat/Tag/Jahr Stunde:Minute:Sekunde’ verzeichnet, die von Pandas nicht automatisch erkannt wurden. Die Spalte hat deshalb den Datentyp object erhalten.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Dateien lesen und schreiben</span>"
    ]
  },
  {
    "objectID": "skript/dateien.html#zeitreihen-einlesen",
    "href": "skript/dateien.html#zeitreihen-einlesen",
    "title": "6  Dateien lesen und schreiben",
    "section": "",
    "text": "parse_dates = True bewirkt, dass der Index als datetime interpretiert wird.\nEine Liste von Ganzzahlen oder Spaltenbeschriftungen bewirkt, dass diese Spalten jeweils als eigene Spalte in datetime übersetzt werden, bspw parse_dates = [1, 2, 3].\nEine von einer Liste umschlossene Liste bewirkt, dass die übergebenen Spalten in einer einzigen Spalte zusammengeführt werden, bspw. parse_dates = [[1, 2, 3]]. Die Werte der Spalten werden mit einem Leerzeichen getrennt und anschließend interpretiert.\n\n\n\n\n\n\nMicrosoft Stock- Time Series Analysis von Vijay V Venkitesh steht unter der Lizenz CC0 und ist auf kaggle abrufbar. 2021\n\nstock = pd.read_csv(filepath_or_buffer = '01-daten/Microsoft_Stock.csv')\n\nprint(stock.head(), \"\\n\")\nprint(stock.info())\n\n                Date   Open   High    Low  Close    Volume\n0  4/1/2015 16:00:00  40.60  40.76  40.31  40.72  36865322\n1  4/2/2015 16:00:00  40.66  40.74  40.12  40.29  37487476\n2  4/6/2015 16:00:00  40.34  41.78  40.18  41.55  39223692\n3  4/7/2015 16:00:00  41.61  41.91  41.31  41.53  28809375\n4  4/8/2015 16:00:00  41.48  41.69  41.04  41.42  24753438 \n\n&lt;class 'pandas.core.frame.DataFrame'&gt;\nRangeIndex: 1511 entries, 0 to 1510\nData columns (total 6 columns):\n #   Column  Non-Null Count  Dtype  \n---  ------  --------------  -----  \n 0   Date    1511 non-null   object \n 1   Open    1511 non-null   float64\n 2   High    1511 non-null   float64\n 3   Low     1511 non-null   float64\n 4   Close   1511 non-null   float64\n 5   Volume  1511 non-null   int64  \ndtypes: float64(4), int64(1), object(1)\nmemory usage: 71.0+ KB\nNone",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Dateien lesen und schreiben</span>"
    ]
  },
  {
    "objectID": "skript/dateien.html#aufgaben-zeitreihen-einlesen",
    "href": "skript/dateien.html#aufgaben-zeitreihen-einlesen",
    "title": "6  Dateien lesen und schreiben",
    "section": "6.2 Aufgaben Zeitreihen einlesen",
    "text": "6.2 Aufgaben Zeitreihen einlesen\n\nÜbergeben Sie der Funktion pd.read_csv() die erforderlichen Argumente, um die Spalte Date korrekt als datetime einzulesen.\nBerechnen Sie die Höchstkurse für jede Woche (intraday).\n\n\n\n\n\n\n\nTipp 6.1: Musterlösung Zeitreihen einlesen\n\n\n\n\n\n\nAufgabe\n\n\nstock = pd.read_csv(filepath_or_buffer = '01-daten/Microsoft_Stock.csv',\n        parse_dates = ['Date'], # alternativ: [0]\n        date_format = '%m/%d/%Y %H:%M:%S')\n\nprint(stock.head(), \"\\n\")\nprint(stock.info())\n\n                 Date   Open   High    Low  Close    Volume\n0 2015-04-01 16:00:00  40.60  40.76  40.31  40.72  36865322\n1 2015-04-02 16:00:00  40.66  40.74  40.12  40.29  37487476\n2 2015-04-06 16:00:00  40.34  41.78  40.18  41.55  39223692\n3 2015-04-07 16:00:00  41.61  41.91  41.31  41.53  28809375\n4 2015-04-08 16:00:00  41.48  41.69  41.04  41.42  24753438 \n\n&lt;class 'pandas.core.frame.DataFrame'&gt;\nRangeIndex: 1511 entries, 0 to 1510\nData columns (total 6 columns):\n #   Column  Non-Null Count  Dtype         \n---  ------  --------------  -----         \n 0   Date    1511 non-null   datetime64[ns]\n 1   Open    1511 non-null   float64       \n 2   High    1511 non-null   float64       \n 3   Low     1511 non-null   float64       \n 4   Close   1511 non-null   float64       \n 5   Volume  1511 non-null   int64         \ndtypes: datetime64[ns](1), float64(4), int64(1)\nmemory usage: 71.0 KB\nNone\n\n\n\nAufgabe\n\nDie Pandas-Methode Series.dt.weekofyear() wird seit einiger Zeit nicht mehr unterstützt (siehe Dokumentation). Die Funktion wurde durch Series.dt.isocalendar().week ersetzt.\n\n# Jahr und Woche isolieren\nprint(stock['Date'].dt.isocalendar().week.head(), \"\\n\")\nprint(stock['Date'].dt.isocalendar().year.tail())\n\n# Jahr und Woche in den DataFrame einfügen\nstock.insert(loc = 1, column = 'week', value = stock['Date'].dt.isocalendar().week)\nstock.insert(loc = 1, column = 'year', value = stock['Date'].dt.isocalendar().year)\n\n# Maximum für jede Woche mit groupby bestimmen\nprint(stock.groupby(by = ['year', 'week'])['High'].max())\n\n# grafisch darstellen\nstock.groupby(by = ['year', 'week'])['High'].max().plot(ylabel = 'Wochenhöchstkurs (intraday)', title = 'Kursentwicklung der Microsoft-Aktie')\n\n0    14\n1    14\n2    15\n3    15\n4    15\nName: week, dtype: UInt32 \n\n1506    2021\n1507    2021\n1508    2021\n1509    2021\n1510    2021\nName: year, dtype: UInt32\nyear  week\n2015  14       40.76\n      15       41.95\n      16       42.46\n      17       48.14\n      18       49.54\n               ...  \n2021  9       237.47\n      10      239.17\n      11      240.06\n      12      241.05\n      13      239.10\nName: High, Length: 314, dtype: float64",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Dateien lesen und schreiben</span>"
    ]
  },
  {
    "objectID": "skript/dateien.html#schwierige-dateien-einlesen",
    "href": "skript/dateien.html#schwierige-dateien-einlesen",
    "title": "6  Dateien lesen und schreiben",
    "section": "6.3 Schwierige Dateien einlesen",
    "text": "6.3 Schwierige Dateien einlesen\nDas Einlesen von Dateien ist nicht immer einfach. Werkzeuge und Strategien zur Bewältigung schwieriger Fälle finden Sie im Methodenbaustein Einlesen strukturierter Datensätze. Dort wird auch der Umgang mit fehlenden Werten ausführlich behandelt.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Dateien lesen und schreiben</span>"
    ]
  }
]