[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Bausteine Computergestützter Datenanalyse",
    "section": "",
    "text": "Werkzeugbaustein Pandas",
    "crumbs": [
      "Werkzeugbaustein Pandas"
    ]
  },
  {
    "objectID": "index.html#voraussetzungen",
    "href": "index.html#voraussetzungen",
    "title": "Bausteine Computergestützter Datenanalyse",
    "section": "Voraussetzungen",
    "text": "Voraussetzungen",
    "crumbs": [
      "Werkzeugbaustein Pandas"
    ]
  },
  {
    "objectID": "index.html#lernziele",
    "href": "index.html#lernziele",
    "title": "Bausteine Computergestützter Datenanalyse",
    "section": "Lernziele",
    "text": "Lernziele",
    "crumbs": [
      "Werkzeugbaustein Pandas"
    ]
  },
  {
    "objectID": "einleitung.html",
    "href": "einleitung.html",
    "title": "1  Einleitung",
    "section": "",
    "text": "1.1 Die Datenstrukturen Series und DataFrame\nDas Modul Pandas wurde für die Arbeit mit strukturierten Daten konzipiert. Wie NumPy erlaubt Pandas vektorisierte Operationen, ohne mit Hilfe einer Schleife jedes Element eines Sammeltyps durchlaufen zu müssen. Pandas erleichtert die Analyse insbesondere von in Tabellenform vorliegenden Daten, da es mit dem DataFrame eine leicht zu benutzende Struktur für die Verarbeitung unterschiedlicher Datentypen und fehlenden Werten bietet. Pandas integriert darüber hinaus Funktionalitäten anderer Module und bietet unter anderem einen einheitlichen Zugang zu:\nDas Modul Pandas wird mit dem Befehl import pandas geladen. Als Kürzel hat sich pd etabliert. Da Pandas auf dem Modul NumPy aufbaut, werden häufig beide Module geladen. Viele Funktionen und Methoden von NumPy und Pandas sind miteinander kompatibel.\nwird NumPy in diesem Baustein überhaupt benutzt?!\n–&gt; ja unter Operationen, um die Indizes von Werten zu finden.\nPandas führt die zwei Klassen Series und DataFrame ein.\nBeide Datenstrukturen verfügen über einen Index, der in der Ausgabe angezeigt wird.\nDer Index beginnt wie in der Pythonbasis bei 0.\n0    Frühschicht\n1    Frühschicht\n2    Spätschicht\ndtype: string\nDer Index ist standardmäßig numerisch, kann aber mit beliebigen Werten versehen werden.\nDer Index kann angepasst werden.\nMontag      Frühschicht\nDienstag    Frühschicht\nMittwoch    Spätschicht\ndtype: string",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Einleitung</span>"
    ]
  },
  {
    "objectID": "einleitung.html#die-datenstrukturen-series-und-dataframe",
    "href": "einleitung.html#die-datenstrukturen-series-und-dataframe",
    "title": "1  Einleitung",
    "section": "",
    "text": "Series sind eindimensionale Arrays, die genau einen Datentyp haben.\nDataFrame sind zweidimensionale Arrays, die spaltenweise aus Series bestehen und so verschiedene Datentypen enthalten können. (Durch hierarchische Indexierung sind mehrdimensionale Datenstrukturen möglich, siehe MultiIndex.)\n\n\n\n\n\n\nSeries\nSeries werden mit der Funktion pd.Series(data) erstellt. data kann ein Einzelwert, ein Sammeltyp oder ein NumPy-Array sein.\n\neinzelwert_series = pd.Series('Hallo Welt!')\nprint(f\"Series aus Einzelwert:\\n{einzelwert_series}\")\n\nnumerische_series = pd.Series([1, 2, 3])\nprint(f\"\\nSeries aus Liste:\\n{numerische_series}\")\n\nalphanumerische_series = pd.Series(('a', '5', 'g'))\nprint(f\"\\nSeries aus Tupel:\\n{alphanumerische_series}\")\n\nboolean_series = pd.Series(np.array([True, False, True])) # NumPy-Array\nprint(f\"\\nSeries aus NumPy-Array:\\n{boolean_series}\")\n\nSeries aus Einzelwert:\n0    Hallo Welt!\ndtype: object\n\nSeries aus Liste:\n0    1\n1    2\n2    3\ndtype: int64\n\nSeries aus Tupel:\n0    a\n1    5\n2    g\ndtype: object\n\nSeries aus NumPy-Array:\n0     True\n1    False\n2     True\ndtype: bool\n\n\nBeim Anlegen einer pd.Series können verschiedene Parameter übergeben werden:\n\npd.Series(data, dtype = 'float') legt den Datentyp der Series fest.\npd.Series(data, index = ['A1', 'B2', 'C3']) übergibt Werte für den Index.\npd.Series(data, name = 'der Name') legt einen Namen für die Series fest.\n\n\nnumerische_series = pd.Series([1, 2, 3], dtype = 'float', index = ['A1', 'B2', 'C3'],name = 'Gleitkommazahlen')\nprint(numerische_series)\n\nA1    1.0\nB2    2.0\nC3    3.0\nName: Gleitkommazahlen, dtype: float64\n\n\nFür eine bestehende Series können Name und Index über entsprechende Attribute aufgerufen und geändert werden. Um den Datentyp zu ändern, wird die Methode pd.Series.astype() verwendet.\n\nprint(f\"Name der Series: {numerische_series.name}\")\nnumerische_series.name = 'Fließkommazahlen'\n\nprint(f\"Index der Series: {numerische_series.index}\")\nnumerische_series.index =  ['eins', 'zwei', 'drei']\n\nnumerische_series = numerische_series.astype('string')\nprint(f\"\\nDie geänderte Series:\\n{numerische_series}\")\n\nName der Series: Gleitkommazahlen\nIndex der Series: Index(['A1', 'B2', 'C3'], dtype='object')\n\nDie geänderte Series:\neins    1.0\nzwei    2.0\ndrei    3.0\nName: Fließkommazahlen, dtype: string\n\n\nDie Series ‘numerische_series’ hat nun den Datentyp string, der Name des Objekts ist also nicht mehr selbsterklärend. Ändern Sie den Datentyp des Objekts in Ganzzahl und wählen Sie einen passenden Namen für die Series aus. Eine Übersicht der in Pandas verfügbaren Datentypen finden Sie in der Pandas-Dokumentation.\n\n\n\n\n\n\nTipp 1.1: Musterlösung dtype\n\n\n\n\n\n\nnumerische_series.name = 'Ganzzahlen'\nnumerische_series = numerische_series.astype('float')\nnumerische_series = numerische_series.astype('int')\n\nprint(numerische_series)\n\neins    1\nzwei    2\ndrei    3\nName: Ganzzahlen, dtype: int32\n\n\n\n\n\n\n\n\n\n\n\nHinweis 1.1: Pandas-Datentyp string\n\n\n\n\n\nPandas nutzt wie die Pythonbasis den Datentyp ‘string’, der unveränderlich (immutable) ist. Das bedeutet, es gibt keine Methode, die eine angelegte Zeichenkette verändern kann. Operationen mit diesem Datentyp geben ein neues Objekt mit dem Datentyp ‘string’ zurück.\nDie Übergabe des Datentyps ‘str’ führt zur Verwendung des NumPy-Datentyps string (dtype = ‘str’), der veränderlich (mutable) ist.\nJe nach Situation kann die Verwendung des einen oder des anderen Datentyps nützlich sein. Beispielsweise kann der NumPy-Datentyp ‘str’ mit der Methode pd.Series.sum() verkettet werden.\n\n# mit NumPy-Datentyp 'str'\nstring_series = pd.Series(['H', 'a', 'l', 'l', 'o', '!'], dtype = 'str')\nprint(f\"Mit NumPy-Datentyp 'str': {string_series.sum()}\")\n\n# mit Pandas-Datentyp 'string'\ntry:\n  string_series.astype('string').sum()\nexcept Exception as error:\n  print(\"\\nMit Pandas-Datentyp 'string':\")\n  print(error)\n\nMit NumPy-Datentyp 'str': Hallo!\n\nMit Pandas-Datentyp 'string':\nCannot perform reduction 'sum' with string dtype\n\n\n\n\n\n\n\nDataFrame\nEin DataFrame wird mit der Funktion pd.DataFrame([data]) angelegt. data ist listenartig, kann aber aus einem Einzelwert, einer Series, einem Numpy-Array oder aus mehreren Series und Sammeltypen bestehen.\n\neinzelwert_df = pd.DataFrame(['Hallo Welt!'])\nprint(einzelwert_df, \"\\n\")\n\ndf_aus_listen = pd.DataFrame([[1, 2, 3], [4, 5, 6]])\nprint(df_aus_listen, \"\\n\")\n\ndf_aus_series = pd.DataFrame([alphanumerische_series, boolean_series])\nprint(df_aus_series, \"\\n\")\n\ndf_aus_verschieden = pd.DataFrame([np.array([True, False, True]), alphanumerische_series, [1, 2, 3]]) # NumPy-Array\nprint(df_aus_verschieden)\n\n             0\n0  Hallo Welt! \n\n   0  1  2\n0  1  2  3\n1  4  5  6 \n\n      0      1     2\n0     a      5     g\n1  True  False  True \n\n      0      1     2\n0  True  False  True\n1     a      5     g\n2     1      2     3\n\n\nBeim Anlegen eines DataFrames können ebenfalls verschiedene Parameter übergeben werden:\n\npd.DataFrame(data, dtype = 'float') legt den Datentyp des DataFrames für alle Werte fest. Wird der Parameter nicht übergeben, wählt Pandas einen passenden Datentyp aus.\npd.DataFrame(data, index = ['A1', 'B2', 'C3']) übergibt Werte für den Index.\npd.DataFrame(data, columns = ['Spalte1', 'Spalte2']) übergibt Werte für die Spaltenbeschriftung.\n\nUm Daten spaltenweise einzutragen, kann der DataFrame zum einen mit dem Attribut DataFrame.T transponiert werden. Dabei müssen die Spaltenbeschriftungen als Argument index und die Indexbeschriftung als Argument columns übergeben werden.\n\ndf_transponiert = pd.DataFrame([[1, 2, 3], [True, False, True]], index = ['Spalte 1', 'Spalte 2'], columns = ['Zeile 1', 'Zeile 2', 'Zeile 3']).T\nprint(df_transponiert)\n\n        Spalte 1 Spalte 2\nZeile 1        1     True\nZeile 2        2    False\nZeile 3        3     True\n\n\nEine direkte Zuordnung der Beschriftungen ist möglich, indem zuerst der transponierte DataFrame angelegt und anschließend über die Attribute .index und .columns die Beschriftungen eingetragen werden.\n\ndf_transponiert = pd.DataFrame([[1, 2, 3], [True, False, True]]).T\ndf_transponiert.columns = ['Spalte 1', 'Spalte 2']\ndf_transponiert.index = ['Zeile 1', 'Zeile 2', 'Zeile 3']\nprint(df_transponiert)\n\n        Spalte 1 Spalte 2\nZeile 1        1     True\nZeile 2        2    False\nZeile 3        3     True\n\n\nDas Anlegen von transponierten DataFrames hat den Nachteil, dass Pandas die Datentypen der eingegebenen Daten spaltenweise verwaltet. Bei der zeilenweise erfolgenden Eingabe von Daten unterschiedlichen Datentyps wird ein für alle Spalten passender Datentyp gewählt. Im folgenden Beispiel wird deshalb von Pandas der Datentyp object für gemischte Datentypen gewählt.\n\ndf_transponiert = pd.DataFrame([[1, 2, 3], ['a', 'b', 'c']], index = ['Zahlen', 'Buchstaben']).T\nprint(df_transponiert)\nprint(f\"\\n{df_transponiert.dtypes}\")\n\n  Zahlen Buchstaben\n0      1          a\n1      2          b\n2      3          c\n\nZahlen        object\nBuchstaben    object\ndtype: object\n\n\nZum anderen kann ein DataFrame direkt aus einem Dictionary erzeugt werden. Dabei werden die Schlüssel als Spaltenbeschriftung verwendet.\n\ndf = pd.DataFrame({'Spalte 1': [1, 2, 3], 'Spalte 2': [4.1, 5.6, 6.0]}, index = ['oben', 'mitte', 'unten'])\nprint(df)\n\n       Spalte 1  Spalte 2\noben          1       4.1\nmitte         2       5.6\nunten         3       6.0\n\n\n\n\n\n\n\n\nTipp 1.2: Der Index\n\n\n\n\n\nIn den meisten Fällen ist der von 0 bis n-1 reichende Index am praktischsten. Der numerische Index hilft bei der Auswahl von Indexbereichen (Slicing) und der Arbeit mit mehreren Datenstrukturen. Probieren Sie einmal aus, was passiert, wenn Sie einen DataFrame aus zwei Series mit unterschiedlichen Indizes erstellen.\nAuch widerspricht das Auslagern beschreibender oder gemessener Variablen in den Index dem Konzept tidy data, einem System zum Strukturieren von Datensätzen, das Sie im Methodenbaustein Einlesen strukturierter Datensätze kennenlernen.\n\n\n\nBestehende DataFrames können ähnlich wie Series modifiziert werden. Um den Datentyp einer oder mehrerer Spalten zu ändern, wird die Methode pd.DataFrame.astype() verwendet.\nEine Spalte kann neu angelegt werden. In diesem Beispiel ordnet Pandas Spalte 1 den unspezifischen Datenyp object zu. Die Spalte kann wie eine Series neu angelegt werden.\n\ndf = pd.DataFrame({'Spalte 1': ['1', '2', '3'], 'Spalte 2': [True, False, True]})\nprint(f\"Die Datentypen von df:\\n{df.dtypes}\")\n\n# Datentyp von Spalte 1 ändern\ndf['Spalte 1'] = df['Spalte 1'].astype('string')\nprint(f\"\\nDie Datentypen von df:\\n{df.dtypes}\")\n\nDie Datentypen von df:\nSpalte 1    object\nSpalte 2      bool\ndtype: object\n\nDie Datentypen von df:\nSpalte 1    string[python]\nSpalte 2              bool\ndtype: object\n\n\nEbenso kann allen Spalten eines DataFrames ein Datentyp zugewiesen werden.\n\ndf = df.astype('string')\nprint(f\"\\nDie Datentypen von df:\\n{df.dtypes}\")\n\n\nDie Datentypen von df:\nSpalte 1    string[python]\nSpalte 2    string[python]\ndtype: object\n\n\nUm unterschiedliche Datentypen zuzweisen, wird ein Dictionary verwendet.\n\ndf = df.astype({'Spalte 1': 'int', 'Spalte 2': 'bool'})\nprint(f\"\\nDie Datentypen von df:\\n{df.dtypes}\")\n\n\nDie Datentypen von df:\nSpalte 1    int32\nSpalte 2     bool\ndtype: object\n\n\nSpaltennamen und Index eines bestehenden DataFrame können über entsprechende Attribute oder Methoden verändert werden. Die Spaltennamen können über das Attribut pd.DataFrame.columns geändert werden. Dabei muss die Länge der Liste der Spaltenanzahl entsprechen. Der Index kann über das Attribut pd.DataFrame.index geändert werden. Dabei muss die Länge der Liste der Anzahl Zeilen entsprechen.\n\n# ändern der Spaltennamen über das Attribut .columns\ndf.columns = ['Spalte1', 'Spalte2']\ndf.index = [1, 2, 3]\nprint(df)\n\n   Spalte1  Spalte2\n1        1     True\n2        2     True\n3        3     True\n\n\nMit der Methode pd.DataFrame.rename(columns = {\"alt1\": \"neu1\", \"alt2\": \"neu2\"}, index = {\"alt1\": \"neu1\", \"alt2\": \"neu2\"}, inplace = True) können Spalten- und Zeilenbeschriftungen in Form eines Dictionarys übergeben werden. Auf diese Weise können alle oder ausgewählte Beschriftungen geändert werden. Durch den Parameter inplace = True erfolgt die Zuweisung direkt ohne Neuzuweisung des Objekts.\n\ndf.rename(columns = {'Spalte1': 'Spalte_1', 'Spalte2': 'Spalte_2'}, index = {1: 'A1', 2: 'B2', 3: 'C3'}, inplace = True)\nprint(df)\n\n    Spalte_1  Spalte_2\nA1         1      True\nB2         2      True\nC3         3      True\n\n\nMit der Methode pd.DataFrame.reset_index(inplace = True, drop = True) wird der Index auf die Standardwerte zurückgesetzt. Wird der Parameter drop = False gesetzt, wird der alte Index als Spalte an Indexposition 0 in den DataFrame eingefügt.\n\ndf.reset_index(inplace = True, drop = True)\nprint(df)\n\n   Spalte_1  Spalte_2\n0         1      True\n1         2      True\n2         3      True",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Einleitung</span>"
    ]
  },
  {
    "objectID": "einleitung.html#slicing",
    "href": "einleitung.html#slicing",
    "title": "1  Einleitung",
    "section": "1.3 Slicing",
    "text": "1.3 Slicing\nHinweis: dieser Abschnitt kommt ähnlich auch im m-EsD vor.\n\n\n\n\nzweidimensionaler Datensatz\n\n\nslicing von Marc Fehr ist lizensiert unter CC-BY-4.0 und abrufbar auf GitHub. Die Grafik wurde auf den gezeigten Teil beschnitten und die obenstehende Beschriftung entfernt. 2024\n\n \nPandas bringt eigene Werkzeuge für die Auswahl von Indexbereichen mit. Der aus der Pythonbasis bekannt Slice Operator wird deshalb nur kurz vorgestellt.\n\nSlice Operator\nMit dem Slice Operator können wie bei einer Liste Indexbereiche aus einer Series ausgewählt werden.\n\nzehn_zahlen = pd.Series(range(0, 10))\nprint(zehn_zahlen[3:6])\n\n3    3\n4    4\n5    5\ndtype: int64\n\n\nMit dem Slice Operator werden die Zeilen eines DataFrames ausgewählt.\n\nprint(meerschweinchen[7:12])\n\n    ID   len supp  dose\n7    8  11.2   VC   0.5\n8    9   5.2   VC   0.5\n9   10   7.0   VC   0.5\n10  11  16.5   VC   1.0\n11  12  16.5   VC   1.0\n\n\nDurch Angabe eines Spaltennamens wird die entsprechende Spalte ausgewählt, die als Series zurückgegeben wird. Durch das Anfügen eines zweiten Slice Operators ist es möglich, wie bei einem eindimensionalen Datensatz die Werte in einem bestimmten Indexbereich abzurufen. Dies wird verkettete Indexierung genannt.\n\nprint(meerschweinchen['dose'][10:15], \"\\n\")\nprint(type(meerschweinchen['dose'][10:15]))\n\n10    1.0\n11    1.0\n12    1.0\n13    1.0\n14    1.0\nName: dose, dtype: float64 \n\n&lt;class 'pandas.core.series.Series'&gt;\n\n\n\n\n\n\n\n\nHinweis 1.2: Verkettete Indexierung\n\n\n\nDie verkettete Indexierung erzeugt in Pandas abhängig vom Kontext eine Kopie des Objekts oder greift auf den Speicherbereich des Objekts zu. Mit Pandas 3.0 wird die verkettete Indexierung nicht mehr unterstützt, das Anlegen einer Kopie wird zum Standard werden. Weitere Informationen erhalten Sie im zitierten Link.\n\n\n\n\n\n\n \n\n\n“Whether a copy or a reference is returned for a setting operation, may depend on the context. This is sometimes called chained assignment and should be avoided. See Returning a View versus Copy.”\n\n\n \n\n\n\n(Pandas Dokumentation)\n\n\n\n\nSlicing mit Pandas-Methoden\nFür das Slicing von Series und DataFrames werden in Pandas die Methoden .iloc[] und .loc[] verwendet.\n\n.loc[] arbeitet mit Index- oder Spaltenbeschriftungen, akzeptiert aber auch ein boolsches Array.\n.iloc[] arbeitet mit Ganzzahlen, akzeptiert aber auch ein boolsches Array.\n\nFür das Slicing von Series wird eine Bereichsangabe übergeben, bspw. pd.Series.iloc[5:8]. Für das Slicing von DataFrames werden zwei durch ein Komma getrennte Bereichsangaben übergeben, wobei an erster Stelle die Zeilen und an zweiter Stelle die Spalten ausgewählt werden, bspw. pd.Series.iloc[5, 2:4]. Um alle Zeilen oder Spalten auszuwählen kann der Doppelpunkt verwendet werden, etwa pd.Series.iloc[5, :].\n\nBeschriftungsbasiertes Slicing mit .loc[]\nFür eine Series interpretiert .loc übergebene Zeichen als Indexbeschriftung. Buchstaben und andere Zeichen werden wie strings in Anführungszeichen übergeben, bspw. .loc['e'], Zahlen ohne Anführungszeichen. Neben Einzelwerten (‘a’ oder 0) können Listen oder Arrays ([‘a’, ‘b’, ‘c’] oder [1, 2, 3]) und Slices übergeben werden (‘a’:‘c’ oder 0:2). Das Slicing mit einem Einzelwert führt zur Rückgabe eines Einzelwerts (sog. Skalar).\nAnders als die Pythonbasis und das Slicing mit .iloc[] zählt Pandas beim beschriftungsbasiertem Slicing inklusiv, gibt also die letzte ausgewählte Position mit aus.\n\n# Nummern\nzehn_zahlen = pd.Series(range(0, 10))\nprint(\"Rückgabe eines Einzelwerts:\", zehn_zahlen.loc[5]) # Einzelwert\nprint(zehn_zahlen.loc[[2, 4, 7]]) # Liste\nprint(zehn_zahlen.loc[5:7], \"\\n\") # Slice\n\n# Buchstaben und andere Zeichen\nsechs_zahlen = pd.Series(list(range(0, 6)), index = ['a', 'b', 'c', 'd', 'e', 'f'])\nprint(\"Rückgabe eines Einzelwerts:\", sechs_zahlen.loc['c']) # Einzelwert\nprint(sechs_zahlen.loc[['c', 'f', 'a']]) # Liste\nprint(sechs_zahlen.loc['c':'e']) # Slice\n\nRückgabe eines Einzelwerts: 5\n2    2\n4    4\n7    7\ndtype: int64\n5    5\n6    6\n7    7\ndtype: int64 \n\nRückgabe eines Einzelwerts: 2\nc    2\nf    5\na    0\ndtype: int64\nc    2\nd    3\ne    4\ndtype: int64\n\n\nDie Interpretation als Beschriftung bedeutet, dass bei einem nicht numerischen Index, übergebene Zahlen nicht gefunden werden.\n\ntry:\n  print(sechs_zahlen.loc[2:4])\nexcept Exception as error:\n  print(error)\n\ncannot do slice indexing on Index with these indexers [2] of type int\n\n\nFür DataFrames funktioniert das Slicing genauso.\n\nprint(meerschweinchen.loc[18:22, ['len', 'dose']])\n\n     len  dose\n18  18.8   1.0\n19  15.5   1.0\n20  23.6   2.0\n21  18.5   2.0\n22  33.9   2.0\n\n\n\n\n\nIndexbasiertes Slicing mit .iloc[]\nDie Methode .iloc[] ermöglicht die Auswahl von Ausschnitten basierend auf Indexpositionen. Die Methode akzeptiert die gleichen Eingaben wie die Methode .loc[]. Beim Slicing mit der Methode .iloc[] zählt Pandas wie die Pythonbasis exklusiv.\nDas Slicing mit Einzelwerten führt ebenfalls zur Ausgabe eines Einzelwertes\n\nprint(\"Rückgabe eines Einzelwerts:\", meerschweinchen.iloc[27, 2]) # Einzelwerte\nprint(meerschweinchen.iloc[[27, 29, 52], 2:4]) # Liste und Slice\n\nRückgabe eines Einzelwerts: VC\n   supp  dose\n27   VC   2.0\n29   VC   2.0\n52   OJ   2.0\n\n\nNotiz: .loc, .iloc, and also [] indexing can accept a callable as indexer. See more at Selection By Callable.\n\nDie Methoden .head() und .tail()\nVereinfachte Varianten des numerisches Slicings sind die Methoden .head(n=5) und .tail(n=5), mit denen die ersten bzw. letzten n Zeilen eines DataFrame oder einer Series ausgegeben werden können. Über den optionalen Paramenter n kann die Anzahl der angezeigten Zeilen gesteuert werden. Die Methoden eignen sich gut, um sich einen ersten Eindruck von einem Datensatz zu verschaffen.\n\nprint(meerschweinchen.head(3), \"\\n\")\nprint(meerschweinchen.tail(3))\n\n   ID   len supp  dose\n0   1   4.2   VC   0.5\n1   2  11.5   VC   0.5\n2   3   7.3   VC   0.5 \n\n    ID   len supp  dose\n57  58  27.3   OJ   2.0\n58  59  29.4   OJ   2.0\n59  60  23.0   OJ   2.0\n\n\nEbenso können Series damit betrachtet werden.\n\nprint(meerschweinchen['len'].tail(3))\n\n57    27.3\n58    29.4\n59    23.0\nName: len, dtype: float64",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Einleitung</span>"
    ]
  },
  {
    "objectID": "einleitung.html#nützliche-methoden",
    "href": "einleitung.html#nützliche-methoden",
    "title": "1  Einleitung",
    "section": "1.3 nützliche Methoden",
    "text": "1.3 nützliche Methoden\nhierhier: erst Slicing, dann pd.concat, pd.DataFrame.drop\nZeilen / Spalten hinzufügen oder entfernen\n\npd.DataFrame.drop([labels, axis, index, columns, level, …])\npd.DataFrame.insert(loc, column, value[, allow_duplicates])\npd.DataFrame.Index.insert : Insert new item by index.\nwie fügt man eine Zeile an position x ein?\n\nDataFrames vereinen\n\npd.DataFrame.concat()\npd.DataFrame.merge(right[, how, on, left_on, right_on, …])\nMerge DataFrame or named Series objects with a database-style join.\n\nNamen ändern - reset_index([level, drop, inplace, …])\nReset the index, or a level of it.\n\nrename([mapper, index, columns, axis, copy, …]\nRename columns or index labels.\n\nWerte ersetzen\n\nwhere(cond[, other, inplace, axis, level])\nReplace values where the condition is False.\n\nDrop specified labels from rows or columns. Was passiert eigentlich mit dem Index, wenn man nun die Series mit unterschiedlichen Indizes zusammenbindet? –&gt; der df wird länger / breiter\n… reset_index(drop = True)\n\nnützliche Attribute\nAttribut heißt dtypes (zusätzliches beachten) T –&gt; der transponierte DataFrame https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.html Besondere: beide bringen einen Index mit… der Index kann auch aus Buchstaben oder Datumsinformationen bestehen\nDatentyp via .dtype",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Einleitung</span>"
    ]
  },
  {
    "objectID": "einleitung.html#operationen",
    "href": "einleitung.html#operationen",
    "title": "1  Einleitung",
    "section": "1.2 Operationen",
    "text": "1.2 Operationen\nWie NumPy erlaubt Pandas vektorisierte Operationen.\n\n# Index zurücksetzen\nnumerische_series.reset_index(inplace = True, drop = True)\n\nprint(numerische_series + 1, \"\\n\")\nprint(numerische_series * numerische_series, \"\\n\")\n\nprint(numerische_series // 2 == 0)\n\n0    2\n1    3\n2    4\nName: Ganzzahlen, dtype: int32 \n\n0    1\n1    4\n2    9\nName: Ganzzahlen, dtype: int32 \n\n0     True\n1    False\n2    False\nName: Ganzzahlen, dtype: bool\n\n\nFür die meisten Funktionen stehen Methoden zur Verfügung. –&gt; Sehr viele –&gt; Tipp: In der Dokumentation nachschlagen.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Einleitung</span>"
    ]
  },
  {
    "objectID": "einleitung.html#datenstrukturen-beschreiben-und-ausschnitte-auswählen",
    "href": "einleitung.html#datenstrukturen-beschreiben-und-ausschnitte-auswählen",
    "title": "1  Einleitung",
    "section": "1.2 Datenstrukturen beschreiben und Ausschnitte auswählen",
    "text": "1.2 Datenstrukturen beschreiben und Ausschnitte auswählen\n.columns() .head() / .tail() .columns .shape - Länge der Dimensionen .info() (siehe m-EsD)\nSlicing mit Slice Operator, iloc, loc",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Einleitung</span>"
    ]
  },
  {
    "objectID": "einleitung.html#löschen-und-verbinden",
    "href": "einleitung.html#löschen-und-verbinden",
    "title": "1  Einleitung",
    "section": "1.5 Löschen und verbinden",
    "text": "1.5 Löschen und verbinden\nDataFrames sind flexible Datenspeicher. Mit der Funktion pd.concat() können Series und DataFrames zusammengeführt werden. dann pd.concat, pd.DataFrame.drop\n\nseries_1 = pd.Series([1, 2, 3])\nseries_2 = pd.Series([4, 5, 6])\nprint(pd.concat([series_1, series_2]))\n\n0    1\n1    2\n2    3\n0    4\n1    5\n2    6\ndtype: int64\n\n\nTemperaturseries für mehrere Jahre verbinden\n\ntemperaturen_2022 = pd.Series([3, 6, 9, 13, 18, 21, 24, 23, 19, 14, 8, 4],\n                         index = ['Jan', 'Feb', 'Mär', 'Apr', 'Mai', 'Jun', \n                         'Jul', 'Aug', 'Sep', 'Okt', 'Nov', 'Dez'])\n\ntemperaturen_2023 = pd.Series([-3, -1, 4, 9, 15, 20, 20, 19, 16, 15, 7, 6],\n                         index = ['Jan', 'Feb', 'Mär', 'Apr', 'Mai', 'Jun', \n                         'Jul', 'Aug', 'Sep', 'Okt', 'Nov', 'Dez'])\n\ntemperaturen_2024 = pd.Series([-1, 2, 5, 8, 17, 24, 25, 20, 17, 14, 9, 2],\n                         index = ['Jan', 'Feb', 'Mär', 'Apr', 'Mai', 'Jun', \n                         'Jul', 'Aug', 'Sep', 'Okt', 'Nov', 'Dez'])\n\nder del Operator geht auch: &gt;&gt;&gt; del test[‘numbers’] (löscht eine Spalte)\nZeilen / Spalten hinzufügen oder entfernen\n\npd.DataFrame.drop([labels, axis, index, columns, level, …])\npd.DataFrame.insert(loc, column, value[, allow_duplicates])\npd.DataFrame.Index.insert : Insert new item by index.\nwie fügt man eine Zeile an position x ein?\n\nDataFrames vereinen\n\npd.DataFrame.concat()\npd.DataFrame.merge(right[, how, on, left_on, right_on, …])\nMerge DataFrame or named Series objects with a database-style join.\n\n\nnützliche Attribute\nAttribut heißt dtypes (zusätzliches beachten) T –&gt; der transponierte DataFrame https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.html Besondere: beide bringen einen Index mit… der Index kann auch aus Buchstaben oder Datumsinformationen bestehen\nDatentyp via .dtype",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Einleitung</span>"
    ]
  },
  {
    "objectID": "einleitung.html#funktionen-für-die-deskriptive-datenanalyse",
    "href": "einleitung.html#funktionen-für-die-deskriptive-datenanalyse",
    "title": "1  Einleitung",
    "section": "1.2 Funktionen für die deskriptive Datenanalyse",
    "text": "1.2 Funktionen für die deskriptive Datenanalyse\nNotiz: Der Teil ist zu großen Teilen auch im m-EsD enthalten –&gt; eine Dopplung wäre okay, ein Querverweis kann aber auch ergänzt werden.\nPandas bietet einige praktische Funktionen, um den Aufbau eines Datensatzes zu beschreiben. Als Beispieldatensatz dienen Daten zur Länge zahnbildender Zellen bei Meerschweinchen, die Vitamin C direkt (VC) oder in Form von Orangensaft (OJ) in unterschiedlichen Dosen erhielten.\n\nCrampton, E. W. 1947. „THE GROWTH OF THE ODONTOBLASTS OF THE INCISOR TOOTH AS A CRITERION OF THE VITAMIN C INTAKE OF THE GUINEA PIG“. The Journal of Nutrition 33 (5): 491–504. https://doi.org/10.1093/jn/33.5.491\n\n \nEin Aussschnitt des Datensatzes:\n\n\n\n\n\n\n\n\n\n\nID\nlen\nsupp\ndose\n\n\n\n\n0\n1\n4.2\nVC\n0.5\n\n\n10\n11\n16.5\nVC\n1.0\n\n\n20\n21\n23.6\nVC\n2.0\n\n\n30\n31\n15.2\nOJ\n0.5\n\n\n40\n41\n19.7\nOJ\n1.0\n\n\n50\n51\n25.5\nOJ\n2.0\n\n\n\n\n\n\n\n\n \nDie Methode pd.DataFrame.info() erzeugt eine Beschreibung des Datensatzes.\n\nmeerschweinchen.info()\n\n&lt;class 'pandas.core.frame.DataFrame'&gt;\nRangeIndex: 60 entries, 0 to 59\nData columns (total 4 columns):\n #   Column  Non-Null Count  Dtype   \n---  ------  --------------  -----   \n 0   ID      60 non-null     int32   \n 1   len     60 non-null     float64 \n 2   supp    60 non-null     category\n 3   dose    60 non-null     float64 \ndtypes: category(1), float64(2), int32(1)\nmemory usage: 1.5 KB\n\n\nDie Dimensionen einer Series oder eines DataFrame können mit dem Attribut shape abgerufen werden.\n\nprint(meerschweinchen.shape)\n\n(60, 4)\n\n\nMit den Methoden .head(n=5) und .tail(n=5) können die ersten bzw. letzten n Zeilen eines DataFrame oder einer Series ausgegeben werden. Über den optionalen Paramenter n kann die Anzahl der angezeigten Zeilen gesteuert werden.\n\nprint(meerschweinchen.head(3), \"\\n\")\nprint(meerschweinchen.tail(3))\n\n   ID   len supp  dose\n0   1   4.2   VC   0.5\n1   2  11.5   VC   0.5\n2   3   7.3   VC   0.5 \n\n    ID   len supp  dose\n57  58  27.3   OJ   2.0\n58  59  29.4   OJ   2.0\n59  60  23.0   OJ   2.0\n\n\nDie Methode pd.DataFrame.describe() erzeugt eine beschreibende Statistik für einen DataFrame. Standardmäßig werden alle numerischen Spalten berücksichtigt. Mit dem Parameter include können die zu berücksichtigenden Spalten vorgegeben werden. include = all berücksichtigt alle Spalten, was nicht unbedingt sinnvoll ist, da auf diese Weise auch die Spalte mit den ID-Nummern der Meerschweinchen ausgewertet wird.\n\nprint(meerschweinchen.describe(include = 'all'))\n\n               ID        len supp       dose\ncount   60.000000  60.000000   60  60.000000\nunique        NaN        NaN    2        NaN\ntop           NaN        NaN   OJ        NaN\nfreq          NaN        NaN   30        NaN\nmean    30.500000  18.813333  NaN   1.166667\nstd     17.464249   7.649315  NaN   0.628872\nmin      1.000000   4.200000  NaN   0.500000\n25%     15.750000  13.075000  NaN   0.500000\n50%     30.500000  19.250000  NaN   1.000000\n75%     45.250000  25.275000  NaN   2.000000\nmax     60.000000  33.900000  NaN   2.000000\n\n\nMit dem Parameter include kann eine Liste zu berücksichtigender Datentypen übergeben werden. Der Parameter exclude schließt auf die gleiche Weise Datentypen von der Ausgabe aus.\n\nprint(meerschweinchen.describe(include = ['float']))\n\n             len       dose\ncount  60.000000  60.000000\nmean   18.813333   1.166667\nstd     7.649315   0.628872\nmin     4.200000   0.500000\n25%    13.075000   0.500000\n50%    19.250000   1.000000\n75%    25.275000   2.000000\nmax    33.900000   2.000000\n\n\n\nprint(meerschweinchen.describe(include = ['category']))\n\n       supp\ncount    60\nunique    2\ntop      OJ\nfreq     30\n\n\nDie Methode pd.DataFrame.count() zählt alle vorhandenen Werte in jeder Spalte oder mit pd.DataFrame.count(axis = 'columns') in jeder Zeile.\n\nmeerschweinchen.count(axis = 'rows') # der Standardwert von axis ist 'rows'\n\nID      60\nlen     60\nsupp    60\ndose    60\ndtype: int64\n\n\nDie Methode pd.unique() listet alle einzigartigen Werte einer Series auf.\n\nmeerschweinchen['dose'].unique()\n\narray([0.5, 1. , 2. ])",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Einleitung</span>"
    ]
  },
  {
    "objectID": "einleitung.html#slicing-1",
    "href": "einleitung.html#slicing-1",
    "title": "1  Einleitung",
    "section": "1.8 Slicing",
    "text": "1.8 Slicing\nSlicing mit dem Slice Operator []funktioniert ganz normal… die Auswahl einer Spalte oder einer Zeile (?!) aus einem df wird als Series zurückgegeben. (wie behält man die spaltenbeschriftung?). Verkettetes Slicing wird nicht mehr empfohlen - siehe m-EsD\nPerformanter, weil auf den tatsächlich enthaltenen Datentyp abgestimmt, sind die pandaseigenen Werkzeuge.\n\n.loc is primarily label based, but may also be used with a boolean array.\n.iloc is primarily integer position based (from 0 to length-1 of the axis), but may also be used with a boolean array.\n\nAttribt .at\nAttribut .axes In Python stellt das Modul Pandas die DataFrame-Struktur bereit.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Einleitung</span>"
    ]
  },
  {
    "objectID": "einleitung.html#section",
    "href": "einleitung.html#section",
    "title": "1  Einleitung: Datenstrukturen in Pandas",
    "section": "1.8 ",
    "text": "1.8 \nPandas: 2-dimensionale DataFrame-Struktur im long- und wide-Format. DataFrames können mehrere Datentypen enthalten und die Größe von DataFrames ist veränderlich. Unterstützung von alphanummerischen Spalten- und Indexbeschriftungen. Direktes Abrufen von Dateien aus dem Internet möglich.\n\numfangreiche Funktionen zur Verarbeitung von Datumsinformationen und Zeitreihen\n\n## Quellen https://pandas.pydata.org/docs/user_guide/dsintro.html https://pandas.pydata.org/docs/user_guide/basics.html",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Einleitung: Datenstrukturen in Pandas</span>"
    ]
  },
  {
    "objectID": "operationen.html",
    "href": "operationen.html",
    "title": "2  Operationen",
    "section": "",
    "text": "2.1 Zeilen- und spaltenweise Operationen\nPandas erlaubt wie NumPy vektorisierte Operationen, dass heißt, Berechnungen mit einer Series oder einem DataFrame werden auf jedes Element angewendet. So können die Rechenoperatoren direkt verwendet werden.\nAuch boolsche Operationen können direkt ausgeführt werden.\nPandas umfasst eine Vielzahl von Methoden, die arithmetische, summarische, boolsche und Indexfunktionen umsetzen. Eine vollständige Übersicht finden Sie hier: https://pandas.pydata.org/docs/reference/index.html.\nIn der Regel werden die Funktionen standardmäßig spaltenweise angewendet. Mit dem Argument axis = 1 wird die jeweilige Funktion zeilenweise ausgeführt. Die Funktionen sind auch für Series verfügbar.\nIm Folgenden werden einige Methoden exemplarisch vorgestellt.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Operationen</span>"
    ]
  },
  {
    "objectID": "einleitung.html#deskriptive-datenanalyse-mit-pandas",
    "href": "einleitung.html#deskriptive-datenanalyse-mit-pandas",
    "title": "1  Einleitung",
    "section": "1.2 Deskriptive Datenanalyse mit Pandas",
    "text": "1.2 Deskriptive Datenanalyse mit Pandas\nNotiz: Der Teil ist zu großen Teilen auch im m-EsD enthalten –&gt; eine Dopplung wäre okay, ein Querverweis kann aber auch ergänzt werden.\nPandas bietet einige praktische Funktionen, um den Aufbau eines Datensatzes und die enthaltenen Daten zu beschreiben. Als Beispieldatensatz dienen Daten zur Länge zahnbildender Zellen bei Meerschweinchen, die Vitamin C direkt (VC) oder in Form von Orangensaft (OJ) in unterschiedlichen Dosen erhielten.\n\n\n\n\n\ndateipfad = \"skript/01-daten/ToothGrowth.csv\"\nmeerschweinchen = pd.read_csv(filepath_or_buffer = dateipfad, sep = ',', header = 0, \\\n  names = ['ID', 'len', 'supp', 'dose'], dtype = {'ID': 'int', 'len': 'float', 'dose': 'float', 'supp': 'category'})\n\n\n\nCode-Block 1.1\n\n\n\nCrampton, E. W. 1947. „THE GROWTH OF THE ODONTOBLASTS OF THE INCISOR TOOTH AS A CRITERION OF THE VITAMIN C INTAKE OF THE GUINEA PIG“. The Journal of Nutrition 33 (5): 491–504. https://doi.org/10.1093/jn/33.5.491\n\n \nEin Aussschnitt des Datensatzes:\n\n\n\n\n\n\n\n\n\nID\nlen\nsupp\ndose\n\n\n\n\n0\n1\n4.2\nVC\n0.5\n\n\n10\n11\n16.5\nVC\n1.0\n\n\n20\n21\n23.6\nVC\n2.0\n\n\n30\n31\n15.2\nOJ\n0.5\n\n\n40\n41\n19.7\nOJ\n1.0\n\n\n50\n51\n25.5\nOJ\n2.0\n\n\n\n\n\n\n\n \nDie Methode pd.DataFrame.info() erzeugt eine Beschreibung des Datensatzes.\n\nmeerschweinchen.info()\n\n&lt;class 'pandas.core.frame.DataFrame'&gt;\nRangeIndex: 60 entries, 0 to 59\nData columns (total 4 columns):\n #   Column  Non-Null Count  Dtype   \n---  ------  --------------  -----   \n 0   ID      60 non-null     int32   \n 1   len     60 non-null     float64 \n 2   supp    60 non-null     category\n 3   dose    60 non-null     float64 \ndtypes: category(1), float64(2), int32(1)\nmemory usage: 1.5 KB\n\n\nDie Dimensionen einer Series oder eines DataFrame können mit dem Attribut shape abgerufen werden. Der DataFrame hat 60 Zeilen und 4 Spalten.\n\nprint(meerschweinchen.shape)\n\n(60, 4)\n\n\nDie Methode pd.DataFrame.describe() erzeugt eine beschreibende Statistik für einen DataFrame. Standardmäßig werden alle numerischen Spalten berücksichtigt. Mit dem Parameter include können die zu berücksichtigenden Spalten vorgegeben werden. include = all berücksichtigt alle Spalten, was nicht unbedingt sinnvoll ist, da auf diese Weise auch die Spalte mit den ID-Nummern der Meerschweinchen ausgewertet wird.\n\nprint(meerschweinchen.describe(include = 'all'))\n\n               ID        len supp       dose\ncount   60.000000  60.000000   60  60.000000\nunique        NaN        NaN    2        NaN\ntop           NaN        NaN   OJ        NaN\nfreq          NaN        NaN   30        NaN\nmean    30.500000  18.813333  NaN   1.166667\nstd     17.464249   7.649315  NaN   0.628872\nmin      1.000000   4.200000  NaN   0.500000\n25%     15.750000  13.075000  NaN   0.500000\n50%     30.500000  19.250000  NaN   1.000000\n75%     45.250000  25.275000  NaN   2.000000\nmax     60.000000  33.900000  NaN   2.000000\n\n\nMit dem Parameter include kann eine Liste zu berücksichtigender Datentypen übergeben werden. Der Parameter exclude schließt auf die gleiche Weise Datentypen von der Ausgabe aus.\n\nprint(meerschweinchen.describe(include = ['float']))\n\n             len       dose\ncount  60.000000  60.000000\nmean   18.813333   1.166667\nstd     7.649315   0.628872\nmin     4.200000   0.500000\n25%    13.075000   0.500000\n50%    19.250000   1.000000\n75%    25.275000   2.000000\nmax    33.900000   2.000000\n\n\n\nprint(meerschweinchen.describe(include = ['category']))\n\n       supp\ncount    60\nunique    2\ntop      OJ\nfreq     30\n\n\nDie Methode pd.DataFrame.count() zählt alle nicht fehlenden Werte in jeder Spalte oder mit pd.DataFrame.count(axis = 'columns') in jeder Zeile.\n\nmeerschweinchen.count(axis = 'rows') # der Standardwert von axis ist 'rows'\n\nID      60\nlen     60\nsupp    60\ndose    60\ndtype: int64\n\n\nDie Methode pd.Series.value_counts() zählt die Anzahl der Merkmalsausprägungen in einer Series. Die Methode kann auch auf einen DataFrame angewendet werden, dann wird die Häufigkeit jeder einzigartigen Zeile gezählt (was hier nicht sinnvoll ist).\n\nmeerschweinchen['dose'].value_counts()\n\ndose\n0.5    20\n1.0    20\n2.0    20\nName: count, dtype: int64\n\n\nDie Methode pd.unique() listet alle einzigartigen Werte einer Series auf.\n\nmeerschweinchen['dose'].unique()\n\narray([0.5, 1. , 2. ])",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Einleitung</span>"
    ]
  },
  {
    "objectID": "einleitung.html#slicing-mit-pandas-methoden",
    "href": "einleitung.html#slicing-mit-pandas-methoden",
    "title": "1  Einleitung",
    "section": "1.4 Slicing mit Pandas-Methoden",
    "text": "1.4 Slicing mit Pandas-Methoden\nNotiz: .loc, .iloc, and also [] indexing can accept a callable as indexer. See more at Selection By Callable.\n\niloc",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Einleitung</span>"
    ]
  },
  {
    "objectID": "einleitung.html#loc",
    "href": "einleitung.html#loc",
    "title": "1  Einleitung",
    "section": "1.4 loc",
    "text": "1.4 loc\nMit iloc können durch die Angabe der Indizes entlang der 0. (Zeilen) und der 1. Achse (Spalten) Ausschnitte aus einem DataFrame ausgewählt werden.\nSlicing mit Slice Operator []\nSlicing mit Slice Operator, iloc, loc\nMit den Methoden .head(n=5) und .tail(n=5) können die ersten bzw. letzten n Zeilen eines DataFrame oder einer Series ausgegeben werden. Über den optionalen Paramenter n kann die Anzahl der angezeigten Zeilen gesteuert werden.\n\nprint(meerschweinchen.head(3), \"\\n\")\nprint(meerschweinchen.tail(3))\n\n   ID   len supp  dose\n0   1   4.2   VC   0.5\n1   2  11.5   VC   0.5\n2   3   7.3   VC   0.5 \n\n    ID   len supp  dose\n57  58  27.3   OJ   2.0\n58  59  29.4   OJ   2.0\n59  60  23.0   OJ   2.0",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Einleitung</span>"
    ]
  },
  {
    "objectID": "einleitung.html#aufgaben-slicing",
    "href": "einleitung.html#aufgaben-slicing",
    "title": "1  Einleitung",
    "section": "1.4 Aufgaben Slicing",
    "text": "1.4 Aufgaben Slicing\n\nGegeben ist eine Pandas Series ‘temperaturen_2021’ mit den durchschnittlichen Monatstemperaturen.\n\n\ntemperaturen_2021 = pd.Series([2, 4, 7, 12, 19, 23, 25, 23, 18, 15, 9, 5],\n                         index = ['Jan', 'Feb', 'Mär', 'Apr', 'Mai', 'Jun', \n                         'Jul', 'Aug', 'Sep', 'Okt', 'Nov', 'Dez'])\n\nWählen Sie die Temperaturen für die Frühlingsmonate (März bis Mai) aus.\n\nWählen Sie die Temperaturen für die letzten drei Monate des Jahres einmal mit Hilfe des Slicing Operators und einmal mit Hilfe der Pandas-Methoden aus.\nWählen Sie mit der Methode .loc[] die Spalte ‘dose’ und ‘len’ des DataFrame meerschweinchen aus und geben Sie die ersten 4 und die letzten 3 Zeilen aus. (Code zum Einlesen der Datei siehe Code-Block 1.1)\nDie Methoden .loc[] und .iloc[] akzepzieren auch ein boolsches Array als Eingabe. Geben Sie aus der Spalte ‘dose’ des DataFrame meerschweinchen alle Zeilen mit dem Wert 2.0 aus.\n\n\n\n\n\n\n\nTipp 1.3: Musterlösung Slicing\n\n\n\n\n\nAufgabe 1\n\nprint(temperaturen_2021.loc[['Mär', 'Apr', 'Mai']])\n\nMär     7\nApr    12\nMai    19\ndtype: int64\n\n\nAufgabe 2\n\nprint(temperaturen_2021[len(temperaturen_2021)-3:], \"\\n\")\nprint(temperaturen_2021.iloc[len(temperaturen_2021)-3:])\n\nOkt    15\nNov     9\nDez     5\ndtype: int64 \n\nOkt    15\nNov     9\nDez     5\ndtype: int64\n\n\nAufgabe 3\n\nprint(meerschweinchen.loc[ :, ['dose', 'len']].head(n = 4), \"\\n\")\nprint(meerschweinchen.loc[ :, ['dose', 'len']].tail(n = 3))\n\n   dose   len\n0   0.5   4.2\n1   0.5  11.5\n2   0.5   7.3\n3   0.5   5.8 \n\n    dose   len\n57   2.0  27.3\n58   2.0  29.4\n59   2.0  23.0\n\n\nAufgabe 4\n\n# Slice aus Series\n# print(meerschweinchen['dose'].loc[meerschweinchen['dose'] == 2.0])\n\n# Slice aus DataFrame\nprint(meerschweinchen.loc[meerschweinchen['dose'] == 2.0, ['dose']])\n\n    dose\n20   2.0\n21   2.0\n22   2.0\n23   2.0\n24   2.0\n25   2.0\n26   2.0\n27   2.0\n28   2.0\n29   2.0\n50   2.0\n51   2.0\n52   2.0\n53   2.0\n54   2.0\n55   2.0\n56   2.0\n57   2.0\n58   2.0\n59   2.0",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Einleitung</span>"
    ]
  },
  {
    "objectID": "operationen.html#aufgaben-operationen",
    "href": "operationen.html#aufgaben-operationen",
    "title": "2  Operationen",
    "section": "2.2 Aufgaben Operationen",
    "text": "2.2 Aufgaben Operationen\n\nBestimmen Sie für den Dataframe temperaturen die monatliche Mediantemperatur.\nErmitteln Sie die Monate mit einer Mediantemperatur größer gleich 21 Grad.\nGeben Sie die Indexbeschriftung dieser Monate aus.\n\n\n\n\n\n\n\nTipp 2.2: Musterlösung Aufgaben Operationen\n\n\n\n\n\n\nAufgabe\n\n\nprint(temperaturen.mean(axis = 1))\n\nJan     0.25\nFeb     2.75\nMär     6.25\nApr    10.50\nMai    17.25\nJun    22.00\nJul    23.50\nAug    21.25\nSep    17.50\nOkt    14.50\nNov     8.25\nDez     4.25\ndtype: float64\n\n\n\nAufgabe\n\n\nprint(temperaturen.mean(axis = 1).ge(21))\n\nJan    False\nFeb    False\nMär    False\nApr    False\nMai    False\nJun     True\nJul     True\nAug     True\nSep    False\nOkt    False\nNov    False\nDez    False\ndtype: bool\n\n\n\nAufgabe\n\n\nprint(temperaturen.index[temperaturen.mean(axis = 1).ge(21)], \"\\n\")\n\n# als Liste\nprint(list(temperaturen.index[temperaturen.mean(axis = 1).ge(21)]), \"\\n\")\n\nIndex(['Jun', 'Jul', 'Aug'], dtype='object') \n\n['Jun', 'Jul', 'Aug']",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Operationen</span>"
    ]
  },
  {
    "objectID": "einleitung.html#datenstrukturen-verbinden-und-löschen",
    "href": "einleitung.html#datenstrukturen-verbinden-und-löschen",
    "title": "1  Einleitung",
    "section": "1.5 Datenstrukturen verbinden und löschen",
    "text": "1.5 Datenstrukturen verbinden und löschen\ndann pd.concat, pd.DataFrame.drop DataFrames sind flexible Datenspeicher. Mit der Funktion pd.concat() können Series und DataFrames zusammengeführt werden.\n\nMit dem Argument pd.concat(ignore_index = True) wird ein neuer Index generiert.\nMit dem Argument pd.concat(axis = 1) werden die übergebenen objekte spaltenweise zusammengeführt.\n\n\nseries_1 = pd.Series([1, 2])\nseries_2 = pd.Series([4, 5])\nprint(pd.concat([series_1, series_2]), \"\\n\")\nprint(pd.concat([series_1, series_2], ignore_index = True), \"\\n\")\nprint(pd.concat([series_1, series_2], ignore_index = True, axis = 1))\n\n0    1\n1    2\n0    4\n1    5\ndtype: int64 \n\n0    1\n1    2\n2    4\n3    5\ndtype: int64 \n\n   0  1\n0  1  4\n1  2  5\n\n\nGleichermaßen können DataFrames verbunden werden.\n\ntemperaturen_2022 = pd.Series([3, 6, 9, 13, 18, 21, 24, 23, 19, 14, 8, 4],\n                         index = ['Jan', 'Feb', 'Mär', 'Apr', 'Mai', 'Jun', \n                         'Jul', 'Aug', 'Sep', 'Okt', 'Nov', 'Dez'])\n\ntemperaturen_2023 = pd.Series([-3, -1, 4, 9, 15, 20, 20, 19, 16, 15, 7, 6],\n                         index = ['Jan', 'Feb', 'Mär', 'Apr', 'Mai', 'Jun', \n                         'Jul', 'Aug', 'Sep', 'Okt', 'Nov', 'Dez'])\n\ntemperaturen_2024 = pd.Series([-1, 2, 5, 8, 17, 24, 25, 20, 17, 14, 9, 2],\n                         index = ['Jan', 'Feb', 'Mär', 'Apr', 'Mai', 'Jun', \n                         'Jul', 'Aug', 'Sep', 'Okt', 'Nov', 'Dez'])\n\n# Series zu DataFrame verbinden\ndf1 = pd.concat([temperaturen_2021, temperaturen_2022], axis = 1)\ndf2 = pd.concat([temperaturen_2023, temperaturen_2024], axis = 1)\n\n# DataFrames verbinden\ntemperaturen = pd.concat([df1, df2], axis = 1)\ntemperaturen.columns = [2021, 2022, 2023, 2024]\nprint(temperaturen)\n\n     2021  2022  2023  2024\nJan     3     3    -3    -1\nFeb     6     6    -1     2\nMär     9     9     4     5\nApr    13    13     9     8\nMai    18    18    15    17\nJun    21    21    20    24\nJul    24    24    20    25\nAug    23    23    19    20\nSep    19    19    16    17\nOkt    14    14    15    14\nNov     8     8     7     9\nDez     4     4     6     2\n\n\nder del Operator geht auch: &gt;&gt;&gt; del test[‘numbers’] (löscht eine Spalte)\nZeilen / Spalten hinzufügen oder entfernen\n\npd.DataFrame.drop([labels, axis, index, columns, level, …])\npd.DataFrame.insert(loc, column, value[, allow_duplicates])\npd.DataFrame.Index.insert : Insert new item by index.\nwie fügt man eine Zeile an position x ein?\n\nDataFrames vereinen\n\npd.DataFrame.concat()\npd.DataFrame.merge(right[, how, on, left_on, right_on, …])\nMerge DataFrame or named Series objects with a database-style join.\n\n\nnützliche Attribute\nAttribut heißt dtypes (zusätzliches beachten) T –&gt; der transponierte DataFrame https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.html Besondere: beide bringen einen Index mit… der Index kann auch aus Buchstaben oder Datumsinformationen bestehen\nDatentyp via .dtype",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Einleitung</span>"
    ]
  },
  {
    "objectID": "einleitung.html#datenstrukturen-verbinden",
    "href": "einleitung.html#datenstrukturen-verbinden",
    "title": "1  Einleitung",
    "section": "1.5 Datenstrukturen verbinden",
    "text": "1.5 Datenstrukturen verbinden\nDataFrames sind flexible Datenspeicher. Mit der Funktion pd.concat() können Series und DataFrames zusammengeführt werden.\n\nMit dem Argument pd.concat(ignore_index = True) wird ein neuer Index generiert.\nMit dem Argument pd.concat(axis = 1) werden die übergebenen objekte spaltenweise zusammengeführt.\n\n\nseries_1 = pd.Series([1, 2])\nseries_2 = pd.Series([4, 5])\nprint(pd.concat([series_1, series_2]), \"\\n\")\nprint(pd.concat([series_1, series_2], ignore_index = True), \"\\n\")\nprint(pd.concat([series_1, series_2], ignore_index = True, axis = 1))\n\n0    1\n1    2\n0    4\n1    5\ndtype: int64 \n\n0    1\n1    2\n2    4\n3    5\ndtype: int64 \n\n   0  1\n0  1  4\n1  2  5\n\n\nGleichermaßen können DataFrames verbunden werden.\n\ntemperaturen_2022 = pd.Series([3, 6, 9, 13, 18, 21, 24, 23, 19, 14, 8, 4],\n                         index = ['Jan', 'Feb', 'Mär', 'Apr', 'Mai', 'Jun', \n                         'Jul', 'Aug', 'Sep', 'Okt', 'Nov', 'Dez'])\n\ntemperaturen_2023 = pd.Series([-3, -1, 4, 9, 15, 20, 20, 19, 16, 15, 7, 6],\n                         index = ['Jan', 'Feb', 'Mär', 'Apr', 'Mai', 'Jun', \n                         'Jul', 'Aug', 'Sep', 'Okt', 'Nov', 'Dez'])\n\ntemperaturen_2024 = pd.Series([-1, 2, 5, 8, 17, 24, 25, 20, 17, 14, 9, 2],\n                         index = ['Jan', 'Feb', 'Mär', 'Apr', 'Mai', 'Jun', \n                         'Jul', 'Aug', 'Sep', 'Okt', 'Nov', 'Dez'])\n\n# Series zu DataFrame verbinden\ndf1 = pd.concat([temperaturen_2021, temperaturen_2022], axis = 1)\ndf2 = pd.concat([temperaturen_2023, temperaturen_2024], axis = 1)\n\n# DataFrames verbinden\ntemperaturen = pd.concat([df1, df2], axis = 1)\ntemperaturen.columns = [2021, 2022, 2023, 2024]\nprint(temperaturen)\n\n     2021  2022  2023  2024\nJan     2     3    -3    -1\nFeb     4     6    -1     2\nMär     7     9     4     5\nApr    12    13     9     8\nMai    19    18    15    17\nJun    23    21    20    24\nJul    25    24    20    25\nAug    23    23    19    20\nSep    18    19    16    17\nOkt    15    14    15    14\nNov     9     8     7     9\nDez     5     4     6     2",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Einleitung</span>"
    ]
  },
  {
    "objectID": "einleitung.html#einfügen-und-löschen-in-datenstrukturen",
    "href": "einleitung.html#einfügen-und-löschen-in-datenstrukturen",
    "title": "1  Einleitung",
    "section": "1.6 Einfügen und löschen in Datenstrukturen",
    "text": "1.6 Einfügen und löschen in Datenstrukturen\nAuch um Einträge zeilen- / oder spaltenweise zu ergänzen und zu löschen bringt Pandas geeignete Methoden mit.\n\npd.DataFrame.drop(labels = None, axis = 0, index = None, columns = None, inplace = False) entfernt Zeilen oder Spalten nach den mit dem Parameter labels als Einzelwert (‘Spalte 1’) oder als Liste ([‘Spalte 1’, ‘Spalte 2’]) übergebenen Beschriftungen. Der Parameter axis = 0 steuert, ob Zeilen oder Spalten (axis = 1) entfernt werden sollen. Die Parameter index und columns sind alternative Möglichkeiten, Index- oder Spaltenbeschriftungen direkt zu übergeben und ersetzen die Parameter labels und axis.\nDer Operator del aus der Pythonbasis löscht Spalten aus einem DataFrame del DataFrame['Spaltenname'].\npd.DataFrame.insert(loc, column, value) fügt eine Spalte an Position loc mit dem Spaltennamen column und dem Inhalt value ein. Falls value eine Series mit abweichendem Index ist, kann über das Attribut value = Series.values auf die enthaltenen Werte der Series zugegriffen und diese in den bestehenden Index einfgefügt werden (andernfalls gleicht Pandas die Indizes der Series und des DataFrames ab und fügt nur die Werte übereinstimmender Indizes ein).\nWerte können zeilweise mit der Methode pd.DataFrame.loc[index] = value eingefügt werden. Falls value eine Series ist, muss über das Attribut value = Series.values auf die enthaltenen Werte der Series zugegriffen werden, da Pandas andernfalls versucht, den Index der Series mit den Spaltennamen des DataFrames abzugleichen. Wird als value ein Einzelwert übergeben, füllt dieser die gesamte Zeile aus.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Einleitung</span>"
    ]
  },
  {
    "objectID": "einleitung.html#aufgaben-verbinden-und-löschen",
    "href": "einleitung.html#aufgaben-verbinden-und-löschen",
    "title": "1  Einleitung",
    "section": "1.7 Aufgaben verbinden und löschen",
    "text": "1.7 Aufgaben verbinden und löschen\nLegen Sie einen leeren DataFrame df = pd.DataFrame() an.\n\nFügen Sie Spalten ‘len’ und ‘dose’ aus dem DataFrame ‘meerschweinchen’ ein.\nLöschen Sie alle ungeraden Zeilennummern aus dem DataFrame df.\nBenutzen Sie die Indexnummern des DataFrame df, um die entsprechenden Zeilen aus der Spalte ‘ID’ des DataFrame ‘meerschweinchen’ auszuwählen. Fügen Sie diese als Spalte an Indexposition 0 in den DataFrame df ein.\n\n\n\n\n\n\n\nTipp 1.4: Musterlösung verbinden und löschen\n\n\n\n\n\n\nAufgabe\n\n\ndf = pd.DataFrame()\n\n# Alternative 1\ndf['len'] = meerschweinchen['len']\n\n# Alternative 2\ndf.insert(loc = 1, column = 'dose', value = meerschweinchen['dose'])\n\nprint(df.head(), \"\\n\", df.shape)\n\n    len  dose\n0   4.2   0.5\n1  11.5   0.5\n2   7.3   0.5\n3   5.8   0.5\n4   6.4   0.5 \n (60, 2)\n\n\n\nAufgabe\n\n\ndf = df.drop(index = range(1, len(df), 2))\n\nprint(df.head(), \"\\n\", df.shape)\n\n    len  dose\n0   4.2   0.5\n2   7.3   0.5\n4   6.4   0.5\n6  11.2   0.5\n8   5.2   0.5 \n (30, 2)\n\n\n\nAufgabe\n\n\ndf.insert(loc = 0, column = 'ID', value = meerschweinchen.loc[df.index, 'ID'])\n\nprint(df.head(), \"\\n\")\nprint(df.tail(), \"\\n\")\nprint(\"df.shape:\", df.shape)\n\n   ID   len  dose\n0   1   4.2   0.5\n2   3   7.3   0.5\n4   5   6.4   0.5\n6   7  11.2   0.5\n8   9   5.2   0.5 \n\n    ID   len  dose\n50  51  25.5   2.0\n52  53  22.4   2.0\n54  55  24.8   2.0\n56  57  26.4   2.0\n58  59  29.4   2.0 \n\ndf.shape: (30, 3)",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Einleitung</span>"
    ]
  },
  {
    "objectID": "einleitung.html#quellen",
    "href": "einleitung.html#quellen",
    "title": "1  Einleitung",
    "section": "Quellen",
    "text": "Quellen\nhttps://pandas.pydata.org/docs/user_guide/dsintro.html https://pandas.pydata.org/docs/user_guide/basics.html",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Einleitung</span>"
    ]
  },
  {
    "objectID": "operationen.html#wohin-boolsche-operatoren",
    "href": "operationen.html#wohin-boolsche-operatoren",
    "title": "2  Operationen",
    "section": "2.4 wohin? boolsche Operatoren?!",
    "text": "2.4 wohin? boolsche Operatoren?!\ndf[df[“A”] &gt; 0] https://pandas.pydata.org/docs/user_guide/10min.html#boolean-indexing\nIndexing with isin https://pandas.pydata.org/docs/user_guide/indexing.html#indexing-with-isin\nThe where() Method and Masking https://pandas.pydata.org/docs/user_guide/indexing.html#the-where-method-and-masking",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Operationen</span>"
    ]
  },
  {
    "objectID": "operationen.html#zeilen--und-spaltenweise-operationen",
    "href": "operationen.html#zeilen--und-spaltenweise-operationen",
    "title": "2  Operationen",
    "section": "",
    "text": "arithmetische Funktionen\nDie Methoden pd.DataFrame.add(), pd.DataFrame.sub(), pd.DataFrame.mul(), pd.DataFrame.div(), pd.DataFrame.floordiv(), pd.DataFrame.mod() und pd.DataFrame.pow() entsprechen den Grundrechenarten mit den Operatoren +, -, *, /, //, %, **. Sie eignen sich gut für verkettete Operationen.\n\nprint(\"Temperaturen in Fahrenheit:\")\nprint(27 * \"=\")\nprint(temperaturen.mul(9).div(5).add(32))\n\nTemperaturen in Fahrenheit:\n===========================\n     2021  2022  2023  2024\nJan  35.6  37.4  26.6  30.2\nFeb  39.2  42.8  30.2  35.6\nMär  44.6  48.2  39.2  41.0\nApr  53.6  55.4  48.2  46.4\nMai  66.2  64.4  59.0  62.6\nJun  73.4  69.8  68.0  75.2\nJul  77.0  75.2  68.0  77.0\nAug  73.4  73.4  66.2  68.0\nSep  64.4  66.2  60.8  62.6\nOkt  59.0  57.2  59.0  57.2\nNov  48.2  46.4  44.6  48.2\nDez  41.0  39.2  42.8  35.6\n\n\nAußerdem kann mit dem Parameter fill_value ein Füllwert für fehlende Werte spezifiziert werden (dieser wird vor der Operation eingesetzt). Wie NumPys np.nan umfasst auch Pandas einen speziellen fehlenden Wert: pd.NA (achten Sie auf den Datentyp der Ausgabe). Mit fehlenden Werten werden wir uns später ausführlicher beschäftigen.\n\nmissing_value = pd.Series([1, pd.NA, 3])\nprint(missing_value.add(1, fill_value = -999), \"\\n\")\nprint(missing_value.add(1, fill_value = np.nan), \"\\n\")\nprint(missing_value.add(1, fill_value = pd.NA))\n\n0      2\n1   -998\n2      4\ndtype: int64 \n\n0    2.0\n1    NaN\n2    4.0\ndtype: float64 \n\n0       2\n1    &lt;NA&gt;\n2       4\ndtype: object\n\n\n\n\nsummarische Funktionen\n\npd.DataFrame.mean() ermittelt den Durchschnitt.\npd.DataFrame.median() ermittelt den Median.\npd.DataFrame.mode() ermittelt den Modus.\npd.DataFrame.sum() ermittelt die Summe.\npd.DataFrame.cumsum() ermittelt die kummulierte Summe.\npd.DataFrame.min() und pd.DataFrame.max() ermitteln Minimum bzw. Maximum.\npd.DataFrame.cummin() und pd.DataFrame.cummax() ermittelt das kummulierte Minimum bzw. Maximum.\n\n\n# spaltenweise\nprint(\"Mittlere Jahrestemperaturen\")\nprint(27 * \"=\")\nprint(temperaturen.mean(), \"\\n\")\n\n# zeilenweise\nprint(\"Monatliche Mindesttemperatur\")\nprint(28 * \"=\")\nprint(temperaturen.min(axis = 1))\n\nMittlere Jahrestemperaturen\n===========================\n2021    13.500000\n2022    13.500000\n2023    10.583333\n2024    11.833333\ndtype: float64 \n\nMonatliche Mindesttemperatur\n============================\nJan    -3\nFeb    -1\nMär     4\nApr     8\nMai    15\nJun    20\nJul    20\nAug    19\nSep    16\nOkt    14\nNov     7\nDez     2\ndtype: int64\n\n\n\n\nboolsche Funktionen\nPandas bietet wie die Pythonbasis verschiedene boolsche Funktionen.\npd.DataFrame.isin(values) prüft für jedes Element des DataFrame, ob dieses in values enthalten ist. Mit dem Operator ~ kann geprüft werden, ob die Elemente eines DataFrame nicht in values enthalten sind: ~pd.DataFrame.isin(values).\nDie Funktionsausführung ist abhängig vom Datentyp des in values übergebenen Objekts.\n\nWenn values eine Liste oder ein NumPy-Array ist, ist das Ergebnis True, wenn es eine Übereinstimmung mit einem der enthaltenen Elemente gibt.\nIst value eine Series oder ein DataFrame, wird die Übereinstimmung positionsbasiert überprüft (siehe Beispiel).\n\n\n\n\n\n\n\nBeispiel 2.1: klassenabhängige Funktionsausführung\n\n\n\n\n\n\nEinzelwerte oder ListeNumPy-ArraySeriesDataFrame\n\n\nFür Einzelwerte oder eine Liste wird die Übereinstimmung elementweise überprüft.\n\nprint(temperaturen, \"\\n\")\n\nprint(temperaturen.isin([2, 3]))\n\n     2021  2022  2023  2024\nJan     2     3    -3    -1\nFeb     4     6    -1     2\nMär     7     9     4     5\nApr    12    13     9     8\nMai    19    18    15    17\nJun    23    21    20    24\nJul    25    24    20    25\nAug    23    23    19    20\nSep    18    19    16    17\nOkt    15    14    15    14\nNov     9     8     7     9\nDez     5     4     6     2 \n\n      2021   2022   2023   2024\nJan   True   True  False  False\nFeb  False  False  False   True\nMär  False  False  False  False\nApr  False  False  False  False\nMai  False  False  False  False\nJun  False  False  False  False\nJul  False  False  False  False\nAug  False  False  False  False\nSep  False  False  False  False\nOkt  False  False  False  False\nNov  False  False  False  False\nDez  False  False  False   True\n\n\n\n\nFür ein NumPy-Array wird die Übereinstimmung elementweise überprüft (vergleiche zum nächsten Reiter).\n\nprint(type(temperaturen[2021].values), \"\\n\")\n\nprint(temperaturen.isin(temperaturen[2021].values))\n\n&lt;class 'numpy.ndarray'&gt; \n\n     2021   2022   2023   2024\nJan  True  False  False  False\nFeb  True  False  False   True\nMär  True   True   True   True\nApr  True  False   True  False\nMai  True   True   True  False\nJun  True  False  False  False\nJul  True  False  False   True\nAug  True   True   True  False\nSep  True   True  False  False\nOkt  True  False   True  False\nNov  True  False   True   True\nDez  True   True  False   True\n\n\n\n\nFür eine Series wird die Übereinstimmung positionsweise geprüft (vergleiche zum vorherigen Reiter). Der Index muss übereinstimmen.\n\nprint(temperaturen.isin(temperaturen[2021]), \"\\n\")\n\ntemperaturen_2021_falscher_index = pd.Series([2, 4, 7, 12, 19, 23, 25, 23, 18, 15, 9, 5])\ntemperaturen_2021_falscher_index.index = ['A', 'B', 'C', 'D', 'E', 'F', 'Jul', 'Aug', 'Sep', 'Okt', 'Nov', 'Dez']\n\nprint(\"Der Index der Series lautet:\\n['A', 'B', 'C', 'D', 'E', 'F', 'Jul', 'Aug', 'Sep', 'Okt', 'Nov', 'Dez']. Das Ergebnis an den Indexpositionen A-F ist immer False.\")\nprint(temperaturen.isin(temperaturen_2021_falscher_index))\n\n     2021   2022   2023   2024\nJan  True  False  False  False\nFeb  True  False  False  False\nMär  True  False  False  False\nApr  True  False  False  False\nMai  True  False  False  False\nJun  True  False  False  False\nJul  True  False  False   True\nAug  True   True  False  False\nSep  True  False  False  False\nOkt  True  False   True  False\nNov  True  False  False   True\nDez  True  False  False  False \n\nDer Index der Series lautet:\n['A', 'B', 'C', 'D', 'E', 'F', 'Jul', 'Aug', 'Sep', 'Okt', 'Nov', 'Dez']. Das Ergebnis an den Indexpositionen A-F ist immer False.\n      2021   2022   2023   2024\nJan  False  False  False  False\nFeb  False  False  False  False\nMär  False  False  False  False\nApr  False  False  False  False\nMai  False  False  False  False\nJun  False  False  False  False\nJul   True  False  False   True\nAug   True   True  False  False\nSep   True  False  False  False\nOkt   True  False   True  False\nNov   True  False  False   True\nDez   True  False  False  False\n\n\n\n\nFür einen DataFrame wird die Übereinstimmung positionsweise geprüft. Index und Spaltennamen müssen übereinstimmen (Index siehe Reiter Series).\n\ntemperaturen_2021_df = pd.DataFrame(temperaturen[2021])\nprint(temperaturen.isin(temperaturen_2021_df), \"\\n\")\n\ntemperaturen_2021_df.columns = [2035]\nprint(temperaturen.isin(temperaturen_2021_df), \"\\n\")\n\n     2021   2022   2023   2024\nJan  True  False  False  False\nFeb  True  False  False  False\nMär  True  False  False  False\nApr  True  False  False  False\nMai  True  False  False  False\nJun  True  False  False  False\nJul  True  False  False  False\nAug  True  False  False  False\nSep  True  False  False  False\nOkt  True  False  False  False\nNov  True  False  False  False\nDez  True  False  False  False \n\n      2021   2022   2023   2024\nJan  False  False  False  False\nFeb  False  False  False  False\nMär  False  False  False  False\nApr  False  False  False  False\nMai  False  False  False  False\nJun  False  False  False  False\nJul  False  False  False  False\nAug  False  False  False  False\nSep  False  False  False  False\nOkt  False  False  False  False\nNov  False  False  False  False\nDez  False  False  False  False \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTipp 2.1: Überraschungen vermeiden\n\n\n\nEine klassenabhängige Funktionsausführung kann, wenn das Verhalten unbemerkt bleibt, die Ergebnisse einer Datenanalyse verfälschen. Um dies zu verhindern, sollten Sie 3 allgemeine Ratschläge befolgen:\n\nSchauen Sie in die Dokumentation der jeweiligen Funktion. Python und viele Module entwickeln sich dynamisch, sodass sich das Verhalten einer Funktion verändern kann.\nGehen Sie schrittweise vor und lassen sich die Zwischenergebnisse von Arbeitsschritten mit der Funktion print() ausgeben.\nBei großen Datenmengen ist es häufig einfacher, mit eigens erzeugten Testdaten zu arbeiten. Ein zehnzeiliger DataFrame mit den Datentypen und der Struktur der Arbeitsdaten, ist leichter zu überblicken. Nutzen Sie einen solchen Testdatensatz um die von Ihnen verwendeten Funktionen zu überprüfen.\n\n\n\nEine Gruppe von Funktionen setzt logische Vergleiche um.\n\n\n\nFunktion\nVergleich\n\n\n\n\npd.DataFrame.lt(other)\nkleiner\n\n\npd.DataFrame.le(other)\nkleiner gleich\n\n\npd.DataFrame.eq(other)\ngleich\n\n\npd.DataFrame.ne(other)\nungleich\n\n\npd.DataFrame.ge(other)\ngrößer gleich\n\n\npd.DataFrame.gt(other)\ngrößer\n\n\n\n\nprint(temperaturen.le(2), \"\\n\")\nprint(temperaturen[2021].gt(5))\n\n      2021   2022   2023   2024\nJan   True  False   True   True\nFeb  False  False   True   True\nMär  False  False  False  False\nApr  False  False  False  False\nMai  False  False  False  False\nJun  False  False  False  False\nJul  False  False  False  False\nAug  False  False  False  False\nSep  False  False  False  False\nOkt  False  False  False  False\nNov  False  False  False  False\nDez  False  False  False   True \n\nJan    False\nFeb    False\nMär     True\nApr     True\nMai     True\nJun     True\nJul     True\nAug     True\nSep     True\nOkt     True\nNov     True\nDez    False\nName: 2021, dtype: bool\n\n\n\n\nVerwendung der Methoden .agg() und .apply()\nPandas bringt zwei eigene Methoden mit, um Operationen zeilen- oder spaltenweise auszuführen. DataFrame.agg() (oder auch DataFrame.aggregate()) aggregiert einen DataFrame zeilen- oder spaltenweise durch eine Funktion. Die Pandas-Methode DF.apply() wendet eine Funktion zeilen- oder spaltenweise auf einen DataFrame an. Die Methoden sind also sehr ähnlich und führen in den meisten Fällen zum selben Ergebnis.\nBeide Funktionen führen mit dem Argument axis = 1 Operationen zeilenweise aus.\n\nFunktionFunktionsnameListe von FunktionenDictionary von Funktionen\n\n\n\ndef my_plus_ten(x):\n  y = x + 10\n  return y\n\nprint(temperaturen.agg(my_plus_ten), \"\\n\")\nprint(temperaturen.apply(my_plus_ten))\n\n     2021  2022  2023  2024\nJan    12    13     7     9\nFeb    14    16     9    12\nMär    17    19    14    15\nApr    22    23    19    18\nMai    29    28    25    27\nJun    33    31    30    34\nJul    35    34    30    35\nAug    33    33    29    30\nSep    28    29    26    27\nOkt    25    24    25    24\nNov    19    18    17    19\nDez    15    14    16    12 \n\n     2021  2022  2023  2024\nJan    12    13     7     9\nFeb    14    16     9    12\nMär    17    19    14    15\nApr    22    23    19    18\nMai    29    28    25    27\nJun    33    31    30    34\nJul    35    34    30    35\nAug    33    33    29    30\nSep    28    29    26    27\nOkt    25    24    25    24\nNov    19    18    17    19\nDez    15    14    16    12\n\n\n\n\n\nprint(temperaturen.agg(\"sum\"), \"\\n\")\nprint(temperaturen.apply(\"sum\"))\n\n2021    162\n2022    162\n2023    127\n2024    142\ndtype: int64 \n\n2021    162\n2022    162\n2023    127\n2024    142\ndtype: int64\n\n\n\n\n\nprint(temperaturen.agg([\"sum\", \"mean\", \"median\"]), \"\\n\")\nprint(temperaturen.apply([\"sum\", \"mean\", \"median\"]))\n\n         2021   2022        2023        2024\nsum     162.0  162.0  127.000000  142.000000\nmean     13.5   13.5   10.583333   11.833333\nmedian   13.5   13.5   12.000000   11.500000 \n\n         2021   2022        2023        2024\nsum     162.0  162.0  127.000000  142.000000\nmean     13.5   13.5   10.583333   11.833333\nmedian   13.5   13.5   12.000000   11.500000\n\n\n\n\n\nprint(temperaturen.agg({2021: \"sum\", 2022: \"mean\", 2023: \"median\", 2024: \"min\"}), \"\\n\")\nprint(temperaturen.apply({2021: \"sum\", 2022: \"mean\", 2023: \"median\", 2024: \"min\"}), \"\\n\")\n\n2021    162.0\n2022     13.5\n2023     12.0\n2024     -1.0\ndtype: float64 \n\n2021    162.0\n2022     13.5\n2023     12.0\n2024     -1.0\ndtype: float64 \n\n\n\n\n\n\nBesonders nützlich ist die Möglichkeit, Funktionen, die normalerweise auf eine Series angewendet werden, auf jedes Element der Series anzuwenden. Dafür wird die lambda Syntax verwendet: lambda x: x + 1 . lambda ist ein Platzhalter und kann als “für jedes x tue:” gelesen werden. So kann beispielsweise die Anzahl der Zeichen in jeder Zeile bestimmt werden.\n\n# Auf die Series angewendet\nprint(len(str(temperaturen[2021])), \"\\n\")\n\n# Elementweise angewendet\nprint(temperaturen[2021].agg(lambda x: len(str(x))), \"\\n\") # deprecated\nprint(temperaturen[2021].apply(lambda x: len(str(x))), \"\\n\")\n\n144 \n\nJan    1\nFeb    1\nMär    1\nApr    2\nMai    2\nJun    2\nJul    2\nAug    2\nSep    2\nOkt    2\nNov    1\nDez    1\nName: 2021, dtype: int64 \n\nJan    1\nFeb    1\nMär    1\nApr    2\nMai    2\nJun    2\nJul    2\nAug    2\nSep    2\nOkt    2\nNov    1\nDez    1\nName: 2021, dtype: int64 \n\n\n\nDetails zur Verwendung des Lambda-Ausdrucks finden Sie in der Dokumentation.\nDer Vollständigkeit wegen ist zu erwähnen, dass mit den Methoden .map() und .transform() weitere, sehr ähnliche Alternativen bestehen. Bei Interesse können Sie die Unterschiede in diesem Artikel nachlesen.\n\n# print(temperaturen[2021].map(lambda x: len(str(x))))\n# print(temperaturen[2021].transform(lambda x: len(str(x))), \"\\n\")",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Operationen</span>"
    ]
  },
  {
    "objectID": "operationen.html#groupby-sollte-in-diesem-kapitel-vorgestellt-werden",
    "href": "operationen.html#groupby-sollte-in-diesem-kapitel-vorgestellt-werden",
    "title": "2  Operationen",
    "section": "2.4 GroupBy sollte in diesem Kapitel vorgestellt werden",
    "text": "2.4 GroupBy sollte in diesem Kapitel vorgestellt werden\nhttps://pandas.pydata.org/docs/reference/groupby.html\n–&gt; das GroupBy-Objekt kann man sich leider nicht angucken oder geht das irgendwie?",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Operationen</span>"
    ]
  },
  {
    "objectID": "operationen.html#sortieren",
    "href": "operationen.html#sortieren",
    "title": "2  Operationen",
    "section": "2.5 Sortieren",
    "text": "2.5 Sortieren\nDie Methode DataFrame.sort_index(axis = 0, ascending = True, inplace = False) sortiert entlang einer Achse, standardmäßig aufsteigend nach dem Index. Durch die Übergabe des Arguments axis = 1 werden die Spalten sortiert. Mit dem Argument ascending = False wird absteigend sortiert. Das Argument inplace = True sorgt, wie gewohnt, dafür, dass das Ergebnis des Sortiervorgangs direkt im Objekt gespeichert wird.\n\nprint(temperaturen.sort_index(), \"\\n\")\nprint(temperaturen.sort_index(axis = 1, ascending = False))\n\n     2021  2022  2023  2024\nApr    12    13     9     8\nAug    23    23    19    20\nDez     5     4     6     2\nFeb     4     6    -1     2\nJan     2     3    -3    -1\nJul    25    24    20    25\nJun    23    21    20    24\nMai    19    18    15    17\nMär     7     9     4     5\nNov     9     8     7     9\nOkt    15    14    15    14\nSep    18    19    16    17 \n\n     2024  2023  2022  2021\nJan    -1    -3     3     2\nFeb     2    -1     6     4\nMär     5     4     9     7\nApr     8     9    13    12\nMai    17    15    18    19\nJun    24    20    21    23\nJul    25    20    24    25\nAug    20    19    23    23\nSep    17    16    19    18\nOkt    14    15    14    15\nNov     9     7     8     9\nDez     2     6     4     5\n\n\nDie Methode DataFrame.sort_values(by, *, axis = 0, ascending = True, inplace = False) sortiert Werte entlang einer Achse, standardmäßig entlang des Index (axis = 0). Dem Parameter by sind laut Dokumentation der Spaltenname als string bzw. eine Liste von Spaltennamen als string zu übergeben, nach denen sortiert werden soll. Wie im folgenden Code-Beispiel zu sehen ist, muss die numerische Spaltenbeschriftung auch entsprechend übergeben werden.\nWird mit dem Argument axis = 1 entlang der zweiten Dimension sortiert, werden entsprechend Indexbeschriftungen übergeben.\n\n# Sortieren nach numerischen Spaltenbeschriftungen\nprint(temperaturen.sort_values(by = 2021), \"\\n\")\nprint(temperaturen.sort_values(by = [2021, 2023]), \"\\n\")\n\n# Sortieren nach als string übergebenen Spaltenbeschriftungen\n# führt zu KeyError, die Fehlermeldung wird nicht vollständig abgefangen\ntry:\n  print(temperaturen.sort_values(by = '2021'))\nexcept Exception as error:\n  print(error)\n\n     2021  2022  2023  2024\nJan     2     3    -3    -1\nFeb     4     6    -1     2\nDez     5     4     6     2\nMär     7     9     4     5\nNov     9     8     7     9\nApr    12    13     9     8\nOkt    15    14    15    14\nSep    18    19    16    17\nMai    19    18    15    17\nJun    23    21    20    24\nAug    23    23    19    20\nJul    25    24    20    25 \n\n     2021  2022  2023  2024\nJan     2     3    -3    -1\nFeb     4     6    -1     2\nDez     5     4     6     2\nMär     7     9     4     5\nNov     9     8     7     9\nApr    12    13     9     8\nOkt    15    14    15    14\nSep    18    19    16    17\nMai    19    18    15    17\nAug    23    23    19    20\nJun    23    21    20    24\nJul    25    24    20    25 \n\n'2021'",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Operationen</span>"
    ]
  },
  {
    "objectID": "operationen.html#suchen-und-ersetzen",
    "href": "operationen.html#suchen-und-ersetzen",
    "title": "2  Operationen",
    "section": "2.3 Suchen und ersetzen",
    "text": "2.3 Suchen und ersetzen\nUm die Indexposition eines bestimmten Werts zu bestimmen, kann die Numpy-Funktion np.where() verwendet werden. Diese gibt zwei Arrays mit den jeweiligen Zeilen- und Spaltennummern zurück.\n\nprint(np.where(temperaturen == 4))\n\n(array([ 1,  2, 11], dtype=int64), array([0, 2, 1], dtype=int64))\n\n\nUnter anderem befindet sich der Wert 4 in Zeile 1 in Spalte 0 oder auch in Zeile 2 in Spalte 2.\n\nprint(temperaturen.iloc[1, 0])\nprint(temperaturen.iloc[2, 2])\n\n4\n4\n\n\nPandas bietet zwei Methoden, um Werte zu ersetzen.\n\npd.DataFrame.replace(to_replace, value, *, inplace = False) ersetzt to_replace mit value. Mit dem Argument inplace = True erfolgt dies direkt im Objekt.\npd.where(cond, other = nan, inplace = False) behält cond und ersetzt alle anderen Werte mit other (standardmäßig ein Platzhalter für fehlende Werte). Mit dem Argument inplace = True erfolgt dies direkt im Objekt.\n\nDie Syntax beider Funktionen unterscheidet sich leicht, wie im folgenden Beispiel zu sehen ist.\n\nprint(temperaturen.replace(to_replace = 25, value = 1000), \"\\n\")\nprint(temperaturen.where(temperaturen == 25, other = 1000))\n\n     2021  2022  2023  2024\nJan     2     3    -3    -1\nFeb     4     6    -1     2\nMär     7     9     4     5\nApr    12    13     9     8\nMai    19    18    15    17\nJun    23    21    20    24\nJul  1000    24    20  1000\nAug    23    23    19    20\nSep    18    19    16    17\nOkt    15    14    15    14\nNov     9     8     7     9\nDez     5     4     6     2 \n\n     2021  2022  2023  2024\nJan  1000  1000  1000  1000\nFeb  1000  1000  1000  1000\nMär  1000  1000  1000  1000\nApr  1000  1000  1000  1000\nMai  1000  1000  1000  1000\nJun  1000  1000  1000  1000\nJul    25  1000  1000    25\nAug  1000  1000  1000  1000\nSep  1000  1000  1000  1000\nOkt  1000  1000  1000  1000\nNov  1000  1000  1000  1000\nDez  1000  1000  1000  1000",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Operationen</span>"
    ]
  },
  {
    "objectID": "operationen.html#funktionen-für-funktionen--",
    "href": "operationen.html#funktionen-für-funktionen--",
    "title": "2  Operationen",
    "section": "2.9 Funktionen für Funktionen :-)",
    "text": "2.9 Funktionen für Funktionen :-)\npipe, apply usw. https://pandas.pydata.org/docs/user_guide/basics.html#function-application\nFür die meisten Funktionen stehen Methoden zur Verfügung. –&gt; Sehr viele –&gt; Tipp: In der Dokumentation nachschlagen.\n\n# meerschweinchen['len'].apply(lambda x: len(str(x)))\nmeerschweinchen['len'].apply(\"mean\")\n\n18.813333333333336",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Operationen</span>"
    ]
  },
  {
    "objectID": "operationen.html#groupby",
    "href": "operationen.html#groupby",
    "title": "2  Operationen",
    "section": "2.7 GroupBy",
    "text": "2.7 GroupBy\nDie Methode pd.groupby() teilt einen DataFrame (oder eine Series) in Gruppen auf und gibt ein GroupBy-Objekt zurück. Das GroupBy-Objekt hat dieselben Spalten- und Zeilenbeschriftungen, wie der DataFrame, das GroupBy-Objekt ist aber nach der Gruppenaufteilung sortiert. Operationen, die auf das GroupBy-Objekt angewendet werden, werden für jede Gruppe separat ausgeführt.\nDies kann am Datensatz ‘meerschweinchen’ im folgenden Panel nachvollzogen werden.\n\nReiter: Der Datensatz enthält 60 Einträge. Die ersten 30 Einträge haben in der Spalte ‘supp’ die Ausprägung VC für Vitamin C, die letzten 30 Einträge die Ausprägung OJ für Orangensaft.\nReiter: Mit der Methode pd.groupby('supp') kann der Datensatz nach den Merkmalsausprägungen in der Spalte ‘dose’ (0.5, 1 und 2) gruppiert werden.\nReiter: Auf das Groupby-Objekt können Operationen ausgeführt werden. Beispielsweise kann die Spalte ‘len’ ausgewählt und mit der Methode .mean() die mittlere Länge der zahnbildenden Zelle bestimmt werden.\nReiter: Ebenso kann nach den Ausprägungen mehrerer Merkmale gruppiert werden, indem diese als Liste übergeben werden pd.groupby(by = ['supp', 'dose']).\n\n\nDataFrame meerschweinchenmeerschweinchen gruppiert nach VerabreichungsartLänge nach VerabreichungsartLänge nach Verabreichungsart und Dosis\n\n\n\nprint(meerschweinchen.head(n = 12))\n\n    ID   len supp  dose\n0    1   4.2   VC   0.5\n1    2  11.5   VC   0.5\n2    3   7.3   VC   0.5\n3    4   5.8   VC   0.5\n4    5   6.4   VC   0.5\n5    6  10.0   VC   0.5\n6    7  11.2   VC   0.5\n7    8  11.2   VC   0.5\n8    9   5.2   VC   0.5\n9   10   7.0   VC   0.5\n10  11  16.5   VC   1.0\n11  12  16.5   VC   1.0\n\n\n\n\nFür die Methode .head() wurde das Argument n halbiert, um die gleiche Zeilenzahl in der Ausgabe anzeigen zu lassen, da auch diese Methode für jede der beiden Gruppen (VC und OJ) ausgeführt wird.\n\nprint(meerschweinchen.groupby('supp').head(n = 6))\n\n    ID   len supp  dose\n0    1   4.2   VC   0.5\n1    2  11.5   VC   0.5\n2    3   7.3   VC   0.5\n3    4   5.8   VC   0.5\n4    5   6.4   VC   0.5\n5    6  10.0   VC   0.5\n30  31  15.2   OJ   0.5\n31  32  21.5   OJ   0.5\n32  33  17.6   OJ   0.5\n33  34   9.7   OJ   0.5\n34  35  14.5   OJ   0.5\n35  36  10.0   OJ   0.5\n\n\n\n\n\nprint(meerschweinchen.groupby(by = 'supp')['len'].mean())\n\nsupp\nOJ    20.663333\nVC    16.963333\nName: len, dtype: float64\n\n\n\n\n\nprint(meerschweinchen.groupby(by = ['supp', 'dose'])['len'].mean())\n\nsupp  dose\nOJ    0.5     13.23\n      1.0     22.70\n      2.0     26.06\nVC    0.5      7.98\n      1.0     16.77\n      2.0     26.14\nName: len, dtype: float64",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Operationen</span>"
    ]
  },
  {
    "objectID": "operationen.html#meerschweinchen-groupbyby-dose",
    "href": "operationen.html#meerschweinchen-groupbyby-dose",
    "title": "2  Operationen",
    "section": "2.5 meerschweinchen GroupBy(by = dose)",
    "text": "2.5 meerschweinchen GroupBy(by = dose)\n\nprint(meerschweinchen.groupby('supp').head(n = 6))\n\n    ID   len supp  dose\n0    1   4.2   VC   0.5\n1    2  11.5   VC   0.5\n2    3   7.3   VC   0.5\n3    4   5.8   VC   0.5\n4    5   6.4   VC   0.5\n5    6  10.0   VC   0.5\n30  31  15.2   OJ   0.5\n31  32  21.5   OJ   0.5\n32  33  17.6   OJ   0.5\n33  34   9.7   OJ   0.5\n34  35  14.5   OJ   0.5\n35  36  10.0   OJ   0.5\n\n\nC:\\Users\\mapoe004\\AppData\\Local\\Temp\\ipykernel_21032\\3864109705.py:1: FutureWarning: The default of observed=False is deprecated and will be changed to True in a future version of pandas. Pass observed=False to retain current behavior or observed=True to adopt the future default and silence this warning.\n  print(meerschweinchen.groupby('supp').head(n = 6))\n\n\n:::\neventl. als 2.2 https://pandas.pydata.org/docs/reference/groupby.html\nhier kann man wieder gut mit dem Datensatz meerschweinchen arbeiten –&gt; GroupBy dose, mean of len.. dann groupby suppdose und supp\n–&gt; das GroupBy-Objekt kann man sich leider nicht angucken oder geht das irgendwie?\n\nprint(meerschweinchen.groupby(by = 'supp')['len'].mean(), \"\\n\")\n\nprint(meerschweinchen.groupby(by = ['supp', 'dose'])['len'].mean(), \"\\n\")\n\nprint(meerschweinchen.groupby(by = ['supp', 'dose']).head())\n\nsupp\nOJ    20.663333\nVC    16.963333\nName: len, dtype: float64 \n\nsupp  dose\nOJ    0.5     13.23\n      1.0     22.70\n      2.0     26.06\nVC    0.5      7.98\n      1.0     16.77\n      2.0     26.14\nName: len, dtype: float64 \n\n    ID   len supp  dose\n0    1   4.2   VC   0.5\n1    2  11.5   VC   0.5\n2    3   7.3   VC   0.5\n3    4   5.8   VC   0.5\n4    5   6.4   VC   0.5\n10  11  16.5   VC   1.0\n11  12  16.5   VC   1.0\n12  13  15.2   VC   1.0\n13  14  17.3   VC   1.0\n14  15  22.5   VC   1.0\n20  21  23.6   VC   2.0\n21  22  18.5   VC   2.0\n22  23  33.9   VC   2.0\n23  24  25.5   VC   2.0\n24  25  26.4   VC   2.0\n30  31  15.2   OJ   0.5\n31  32  21.5   OJ   0.5\n32  33  17.6   OJ   0.5\n33  34   9.7   OJ   0.5\n34  35  14.5   OJ   0.5\n40  41  19.7   OJ   1.0\n41  42  23.3   OJ   1.0\n42  43  23.6   OJ   1.0\n43  44  26.4   OJ   1.0\n44  45  20.0   OJ   1.0\n50  51  25.5   OJ   2.0\n51  52  26.4   OJ   2.0\n52  53  22.4   OJ   2.0\n53  54  24.5   OJ   2.0\n54  55  24.8   OJ   2.0\n\n\nC:\\Users\\mapoe004\\AppData\\Local\\Temp\\ipykernel_21032\\2871032974.py:1: FutureWarning: The default of observed=False is deprecated and will be changed to True in a future version of pandas. Pass observed=False to retain current behavior or observed=True to adopt the future default and silence this warning.\n  print(meerschweinchen.groupby(by = 'supp')['len'].mean(), \"\\n\")\nC:\\Users\\mapoe004\\AppData\\Local\\Temp\\ipykernel_21032\\2871032974.py:3: FutureWarning: The default of observed=False is deprecated and will be changed to True in a future version of pandas. Pass observed=False to retain current behavior or observed=True to adopt the future default and silence this warning.\n  print(meerschweinchen.groupby(by = ['supp', 'dose'])['len'].mean(), \"\\n\")\nC:\\Users\\mapoe004\\AppData\\Local\\Temp\\ipykernel_21032\\2871032974.py:5: FutureWarning: The default of observed=False is deprecated and will be changed to True in a future version of pandas. Pass observed=False to retain current behavior or observed=True to adopt the future default and silence this warning.\n  print(meerschweinchen.groupby(by = ['supp', 'dose']).head())",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Operationen</span>"
    ]
  },
  {
    "objectID": "operationen.html#aufgaben-suchen-und-ersetzen",
    "href": "operationen.html#aufgaben-suchen-und-ersetzen",
    "title": "2  Operationen",
    "section": "2.4 Aufgaben suchen und ersetzen",
    "text": "2.4 Aufgaben suchen und ersetzen\n\nBestimmen Sie die Position der Werte im DataFrame ‘temperaturen’, die kleiner als 0 sind und geben Sie die Werte aus.\nErsetzen Sie alle Werte im DataFrame temperaturen, die kleiner sind als 0 durch den Wert 0 und geben Sie das Ergebnis aus.\n\n\n\n\n\n\n\nTipp 2.3: Musterlösung suchen und ersetzen\n\n\n\n\n\n\nAufgabe\n\n\nprint(np.where(temperaturen &lt;= 0))\nprint(\"Anzahl Werte:\", len(np.where(temperaturen &lt;= 0)[0]))\n\nfor i in range(len(np.where(temperaturen &lt;= 0)[0])):\n  print(temperaturen.iloc[np.where(temperaturen &lt;= 0)[0][i], np.where(temperaturen &lt;= 0)[1][i]])\n\n(array([0, 0, 1], dtype=int64), array([2, 3, 2], dtype=int64))\nAnzahl Werte: 3\n-3\n-1\n-1\n\n\n\nAufgabe\n\n\nprint(temperaturen.where(temperaturen &gt; 0, other = 0))\n\n     2021  2022  2023  2024\nJan     2     3     0     0\nFeb     4     6     0     2\nMär     7     9     4     5\nApr    12    13     9     8\nMai    19    18    15    17\nJun    23    21    20    24\nJul    25    24    20    25\nAug    23    23    19    20\nSep    18    19    16    17\nOkt    15    14    15    14\nNov     9     8     7     9\nDez     5     4     6     2",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Operationen</span>"
    ]
  },
  {
    "objectID": "operationen.html#aufgaben-sortieren",
    "href": "operationen.html#aufgaben-sortieren",
    "title": "2  Operationen",
    "section": "2.6 Aufgaben Sortieren",
    "text": "2.6 Aufgaben Sortieren\n\nSortieren Sie den DataFrame meerschweinchen absteigend nach der Zahnlänge (‘len’). Welches Meerschweinchen hat die längste zahnbildende Zelle (gesucht ist die ID)?\nWelches Meerschweinchen, welches die Dosis 1.0 erhielt, hat die längste zahnbildende Zelle (gesucht ist die ID)?\n\n\n\n\n\n\n\nTipp 2.4: Musterlösung Sortieren\n\n\n\n\n\n\nAufgabe\n\n\nprint(meerschweinchen.sort_values(by = 'len', ascending = False).head(), \"\\n\")\n\nprint(\"Die ID lautet:\", meerschweinchen.sort_values(by = 'len', ascending = False).iloc[0, 0])\n\n    ID   len supp  dose\n22  23  33.9   VC   2.0\n25  26  32.5   VC   2.0\n55  56  30.9   OJ   2.0\n29  30  29.5   VC   2.0\n58  59  29.4   OJ   2.0 \n\nDie ID lautet: 23\n\n\n\nAufgabe\n\n\ndose_1 = meerschweinchen[meerschweinchen['dose'] == 1.0]\n\nprint(dose_1.sort_values(by = 'len', ascending = False).head(), \"\\n\")\n\nprint(\"Die ID lautet:\", dose_1.sort_values(by = 'len', ascending = False).iloc[0, 0])\n\n    ID   len supp  dose\n49  50  27.3   OJ   1.0\n43  44  26.4   OJ   1.0\n46  47  25.8   OJ   1.0\n45  46  25.2   OJ   1.0\n42  43  23.6   OJ   1.0 \n\nDie ID lautet: 50",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Operationen</span>"
    ]
  },
  {
    "objectID": "operationen.html#aufgaben-groupby",
    "href": "operationen.html#aufgaben-groupby",
    "title": "2  Operationen",
    "section": "2.8 Aufgaben GroupBy",
    "text": "2.8 Aufgaben GroupBy\nDer Datensatz Motor Trend Car Road Tests (mtcars) stammt aus der us-amerikanischen Zeitschrift Motor Trend von 1974 und enthalt Daten für 32 Autos.\n\n\n\nmtcars = pd.read_csv(filepath_or_buffer = \"C:/Users/mapoe004/Desktop/Arbeitsordner Maik Poetzsch/BCD/Bausteine/Werkzeugbausteine/w-Pandas/w-pandas/aufgaben/01-daten/mtcars.csv\", sep = \",\")\nmtcars.rename(columns = {'Unnamed: 0': 'car'}, inplace = True)\n\nmtcars.head()\n\n\n\n\n\n\n\n\ncar\nmpg\ncyl\ndisp\nhp\ndrat\nwt\nqsec\nvs\nam\ngear\ncarb\n\n\n\n\n0\nMazda RX4\n21.0\n6\n160.0\n110\n3.90\n2.620\n16.46\n0\n1\n4\n4\n\n\n1\nMazda RX4 Wag\n21.0\n6\n160.0\n110\n3.90\n2.875\n17.02\n0\n1\n4\n4\n\n\n2\nDatsun 710\n22.8\n4\n108.0\n93\n3.85\n2.320\n18.61\n1\n1\n4\n1\n\n\n3\nHornet 4 Drive\n21.4\n6\n258.0\n110\n3.08\n3.215\n19.44\n1\n0\n3\n1\n\n\n4\nHornet Sportabout\n18.7\n8\n360.0\n175\n3.15\n3.440\n17.02\n0\n0\n3\n2\n\n\n\n\n\n\n\n\n\n\n\nSpalte\nBedeutung\n\n\n\n\nmpg\nKraftstoffverbrauch in Meilen pro Gallone\n\n\ncyl\nAnzahl Zylinder\n\n\ndisp\nHubraum in Kubikzoll\n\n\nhp\nPferdestärken\n\n\ndrat\nHinterachsübersetzung\n\n\nwt\nGewicht in 1000 Pfund\n\n\nqsec\nZeit auf der Viertelmeile\n\n\nvs\nMotor (0 = V-Motor, 1 = Reihenmotor)\n\n\nam\nSchaltung (0 = Automatik, 1 = Handschaltung)\n\n\ngear\nAnzahl der Vorwärtsgänge\n\n\ncarb\nAnzahl der Vergaser\n\n\n\nHenderson and Velleman 1981. Building multiple regression models interactively. Biometrics 37: 391–411. Der Datensatz ist abrufbar auf GitHub und in R verfügbar.\n\n \n\nGruppieren Sie den Datensatz nach der Anzahl Zylinder und ermitteln Sie den durchschnittlichen Kraftstoffverbrauch für jede Gruppe.\nWie viele Liter auf 100 Kilometer sind es?\nGruppieren Sie den Datensatz nach der Anzahl der Zylinder und der Vergaser. Welche Gruppe ist am schnellsten auf der Viertelmeile?\n\n\n\n\n\n\n\nTipp 2.5: Musterlösung GroupBy\n\n\n\n\n\n\nAufgabe\n\n\nmtcars.groupby(by = 'cyl')['mpg'].mean() \n\ncyl\n4    26.663636\n6    19.742857\n8    15.100000\nName: mpg, dtype: float64\n\n\n\nAufgabe\n\n\n# 1 Meile = 1.60934 Kilometer\n# 1 Gallone = 3.78541 Liter\n\nmpg = mtcars.groupby(by = 'cyl')['mpg'].mean()\n\nliter_100km = 1 / mpg.mul(1.60934).div(3.78541).div(100)\n\nprint(liter_100km)\n\ncyl\n4     8.821567\n6    11.913932\n8    15.577156\nName: mpg, dtype: float64\n\n\n\nAufgabe\n\n\nprint(mtcars.groupby(by = ['cyl', 'carb'])['qsec'].mean(), \"\\n\")\nprint(mtcars.groupby(by = ['cyl', 'carb'])['qsec'].mean().index[-1], \"\\n\")\n\ncyl  carb\n4    1       19.378000\n     2       18.936667\n6    1       19.830000\n     4       17.670000\n     6       15.500000\n8    2       17.060000\n     3       17.666667\n     4       16.495000\n     8       14.600000\nName: qsec, dtype: float64 \n\n(8, 8) \n\n\n\nDie Gruppe mit 8 Zylindern und 8 Vergasern ist am schnellsten. (Hinweis: Es handelt sich hierbei um einen sogenannten MultiIndex.)",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Operationen</span>"
    ]
  }
]