[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Bausteine Computergestützter Datenanalyse",
    "section": "",
    "text": "Werkzeugbaustein Pandas",
    "crumbs": [
      "Werkzeugbaustein Pandas"
    ]
  },
  {
    "objectID": "index.html#voraussetzungen",
    "href": "index.html#voraussetzungen",
    "title": "Bausteine Computergestützter Datenanalyse",
    "section": "Voraussetzungen",
    "text": "Voraussetzungen",
    "crumbs": [
      "Werkzeugbaustein Pandas"
    ]
  },
  {
    "objectID": "index.html#lernziele",
    "href": "index.html#lernziele",
    "title": "Bausteine Computergestützter Datenanalyse",
    "section": "Lernziele",
    "text": "Lernziele",
    "crumbs": [
      "Werkzeugbaustein Pandas"
    ]
  },
  {
    "objectID": "einleitung.html",
    "href": "einleitung.html",
    "title": "1  Einleitung",
    "section": "",
    "text": "1.1 Die Datenstrukturen Series und DataFrame\nPandas führt die zwei Klassen Series und DataFrame ein.\nBeide Datenstrukturen verfügen über einen Index, der in der Ausgabe angezeigt wird.\nDer Index beginnt wie in der Pythonbasis bei 0.\n0    Frühschicht\n1    Frühschicht\n2    Spätschicht\ndtype: string\nDer Index ist standardmäßig numerisch, kann aber mit beliebigen Werten versehen werden.\nDer Index kann angepasst werden.\nMontag      Frühschicht\nDienstag    Frühschicht\nMittwoch    Spätschicht\ndtype: string",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Einleitung</span>"
    ]
  },
  {
    "objectID": "einleitung.html#die-datenstrukturen-series-und-dataframe",
    "href": "einleitung.html#die-datenstrukturen-series-und-dataframe",
    "title": "1  Einleitung",
    "section": "",
    "text": "Series sind eindimensionale Arrays, die genau einen Datentyp haben.\nDataFrame sind zweidimensionale Arrays, die spaltenweise aus Series bestehen und so verschiedene Datentypen enthalten können. (Durch hierarchische Indexierung sind mehrdimensionale Datenstrukturen möglich, siehe MultiIndex.)\n\n\n\n\n\n\nSeries\nSeries werden mit der Funktion pd.Series(data) erstellt. data kann ein Einzelwert, ein Sammeltyp oder ein NumPy-Array sein.\n\neinzelwert_series = pd.Series('Hallo Welt!')\nprint(f\"Series aus Einzelwert:\\n{einzelwert_series}\")\n\nnumerische_series = pd.Series([1, 2, 3])\nprint(f\"\\nSeries aus Liste:\\n{numerische_series}\")\n\nalphanumerische_series = pd.Series(('a', '5', 'g'))\nprint(f\"\\nSeries aus Tupel:\\n{alphanumerische_series}\")\n\nboolean_series = pd.Series(np.array([True, False, True])) # NumPy-Array\nprint(f\"\\nSeries aus NumPy-Array:\\n{boolean_series}\")\n\nSeries aus Einzelwert:\n0    Hallo Welt!\ndtype: object\n\nSeries aus Liste:\n0    1\n1    2\n2    3\ndtype: int64\n\nSeries aus Tupel:\n0    a\n1    5\n2    g\ndtype: object\n\nSeries aus NumPy-Array:\n0     True\n1    False\n2     True\ndtype: bool\n\n\nBeim Anlegen einer pd.Series können verschiedene Parameter übergeben werden:\n\npd.Series(data, dtype = 'float') legt den Datentyp der Series fest.\npd.Series(data, index = ['A1', 'B2', 'C3']) übergibt Werte für den Index.\npd.Series(data, name = 'der Name') legt einen Namen für die Series fest.\n\n\nnumerische_series = pd.Series([1, 2, 3], dtype = 'float', index = ['A1', 'B2', 'C3'],name = 'Gleitkommazahlen')\nprint(numerische_series)\n\nA1    1.0\nB2    2.0\nC3    3.0\nName: Gleitkommazahlen, dtype: float64\n\n\nFür eine bestehende Series können Name und Index über entsprechende Attribute aufgerufen und geändert werden. Um den Datentyp zu ändern, wird die Methode pd.Series.astype() verwendet.\n\nprint(f\"Name der Series: {numerische_series.name}\")\nnumerische_series.name = 'Fließkommazahlen'\n\nprint(f\"Index der Series: {numerische_series.index}\")\nnumerische_series.index =  ['eins', 'zwei', 'drei']\n\nnumerische_series = numerische_series.astype('string')\nprint(f\"\\nDie geänderte Series:\\n{numerische_series}\")\n\nName der Series: Gleitkommazahlen\nIndex der Series: Index(['A1', 'B2', 'C3'], dtype='object')\n\nDie geänderte Series:\neins    1.0\nzwei    2.0\ndrei    3.0\nName: Fließkommazahlen, dtype: string\n\n\nDie Series ‘numerische_series’ hat nun den Datentyp string, der Name des Objekts ist also nicht mehr selbsterklärend. Ändern Sie den Datentyp des Objekts in Ganzzahl und wählen Sie einen passenden Namen für die Series aus. Eine Übersicht der in Pandas verfügbaren Datentypen finden Sie in der Pandas-Dokumentation.\n\n\n\n\n\n\nTipp 1.1: Musterlösung dtype\n\n\n\n\n\n\nnumerische_series.name = 'Ganzzahlen'\nnumerische_series = numerische_series.astype('float')\nnumerische_series = numerische_series.astype('int')\n\nprint(numerische_series)\n\neins    1\nzwei    2\ndrei    3\nName: Ganzzahlen, dtype: int32\n\n\n\n\n\n\n\n\n\n\n\nHinweis 1.1: Pandas-Datentyp string\n\n\n\n\n\nPandas nutzt wie die Pythonbasis den Datentyp ‘string’, der unveränderlich (immutable) ist. Das bedeutet, es gibt keine Methode, die eine angelegte Zeichenkette verändern kann. Operationen mit diesem Datentyp geben ein neues Objekt mit dem Datentyp ‘string’ zurück.\nDie Übergabe des Datentyps ‘str’ führt zur Verwendung des NumPy-Datentyps string (dtype = ‘str’), der veränderlich (mutable) ist.\nJe nach Situation kann die Verwendung des einen oder des anderen Datentyps nützlich sein. Beispielsweise kann der NumPy-Datentyp ‘str’ mit der Methode pd.Series.sum() verkettet werden.\n\n# mit NumPy-Datentyp 'str'\nstring_series = pd.Series(['H', 'a', 'l', 'l', 'o', '!'], dtype = 'str')\nprint(f\"Mit NumPy-Datentyp 'str': {string_series.sum()}\")\n\n# mit Pandas-Datentyp 'string'\ntry:\n  string_series.astype('string').sum()\nexcept Exception as error:\n  print(\"\\nMit Pandas-Datentyp 'string':\")\n  print(error)\n\nMit NumPy-Datentyp 'str': Hallo!\n\nMit Pandas-Datentyp 'string':\nCannot perform reduction 'sum' with string dtype\n\n\n\n\n\n\n\nDataFrame\nEin DataFrame wird mit der Funktion pd.DataFrame([data]) angelegt. data ist listenartig, kann aber aus einem Einzelwert, einer Series, einem Numpy-Array oder aus mehreren Series und Sammeltypen bestehen.\n\neinzelwert_df = pd.DataFrame(['Hallo Welt!'])\nprint(einzelwert_df, \"\\n\")\n\ndf_aus_listen = pd.DataFrame([[1, 2, 3], [4, 5, 6]])\nprint(df_aus_listen, \"\\n\")\n\ndf_aus_series = pd.DataFrame([alphanumerische_series, boolean_series])\nprint(df_aus_series, \"\\n\")\n\ndf_aus_verschieden = pd.DataFrame([np.array([True, False, True]), alphanumerische_series, [1, 2, 3]]) # NumPy-Array\nprint(df_aus_verschieden)\n\n             0\n0  Hallo Welt! \n\n   0  1  2\n0  1  2  3\n1  4  5  6 \n\n      0      1     2\n0     a      5     g\n1  True  False  True \n\n      0      1     2\n0  True  False  True\n1     a      5     g\n2     1      2     3\n\n\nBeim Anlegen eines DataFrames können ebenfalls verschiedene Parameter übergeben werden:\n\npd.DataFrame(data, dtype = 'float') legt den Datentyp des DataFrames für alle Werte fest. Wird der Parameter nicht übergeben, wählt Pandas einen passenden Datentyp aus.\npd.DataFrame(data, index = ['A1', 'B2', 'C3']) übergibt Werte für den Index.\npd.DataFrame(data, columns = ['Spalte1', 'Spalte2']) übergibt Werte für die Spaltenbeschriftung.\n\nUm Daten spaltenweise einzutragen, kann der DataFrame zum einen mit dem Attribut DataFrame.T transponiert werden. Dabei müssen die Spaltenbeschriftungen als Argument index und die Indexbeschriftung als Argument columns übergeben werden.\n\ndf_transponiert = pd.DataFrame([[1, 2, 3], [True, False, True]], index = ['Spalte 1', 'Spalte 2'], columns = ['Zeile 1', 'Zeile 2', 'Zeile 3']).T\nprint(df_transponiert)\n\n        Spalte 1 Spalte 2\nZeile 1        1     True\nZeile 2        2    False\nZeile 3        3     True\n\n\nEine direkte Zuordnung der Beschriftungen ist möglich, indem zuerst der transponierte DataFrame angelegt und anschließend über die Attribute .index und .columns die Beschriftungen eingetragen werden.\n\ndf_transponiert = pd.DataFrame([[1, 2, 3], [True, False, True]]).T\ndf_transponiert.columns = ['Spalte 1', 'Spalte 2']\ndf_transponiert.index = ['Zeile 1', 'Zeile 2', 'Zeile 3']\nprint(df_transponiert)\n\n        Spalte 1 Spalte 2\nZeile 1        1     True\nZeile 2        2    False\nZeile 3        3     True\n\n\nDas Anlegen von transponierten DataFrames hat den Nachteil, dass Pandas die Datentypen der eingegebenen Daten spaltenweise verwaltet. Bei der zeilenweise erfolgenden Eingabe von Daten unterschiedlichen Datentyps wird ein für alle Spalten passender Datentyp gewählt. Im folgenden Beispiel wird deshalb von Pandas der Datentyp object für gemischte Datentypen gewählt.\n\ndf_transponiert = pd.DataFrame([[1, 2, 3], ['a', 'b', 'c']], index = ['Zahlen', 'Buchstaben']).T\nprint(df_transponiert)\nprint(f\"\\n{df_transponiert.dtypes}\")\n\n  Zahlen Buchstaben\n0      1          a\n1      2          b\n2      3          c\n\nZahlen        object\nBuchstaben    object\ndtype: object\n\n\nZum anderen kann ein DataFrame direkt aus einem Dictionary erzeugt werden. Dabei werden die Schlüssel als Spaltenbeschriftung verwendet.\n\ndf = pd.DataFrame({'Spalte 1': [1, 2, 3], 'Spalte 2': [4.1, 5.6, 6.0]}, index = ['oben', 'mitte', 'unten'])\nprint(df)\n\n       Spalte 1  Spalte 2\noben          1       4.1\nmitte         2       5.6\nunten         3       6.0\n\n\n\n\n\n\n\n\nTipp 1.2: Der Index\n\n\n\n\n\nIn den meisten Fällen ist der von 0 bis n-1 reichende Index am praktischsten. Der numerische Index hilft bei der Auswahl von Indexbereichen (Slicing) und der Arbeit mit mehreren Datenstrukturen. Probieren Sie einmal aus, was passiert, wenn Sie einen DataFrame aus zwei Series mit unterschiedlichen Indizes erstellen.\nAuch widerspricht das Auslagern beschreibender oder gemessener Variablen in den Index dem Konzept tidy data, einem System zum Strukturieren von Datensätzen, das Sie im Methodenbaustein Einlesen strukturierter Datensätze kennenlernen.\n\n\n\nBestehende DataFrames können ähnlich wie Series modifiziert werden. Um den Datentyp einer oder mehrerer Spalten zu ändern, wird die Methode pd.DataFrame.astype() verwendet.\nEine Spalte kann neu angelegt werden. In diesem Beispiel ordnet Pandas Spalte 1 den unspezifischen Datenyp object zu. Die Spalte kann wie eine Series neu angelegt werden.\n\ndf = pd.DataFrame({'Spalte 1': ['1', '2', '3'], 'Spalte 2': [True, False, True]})\nprint(f\"Die Datentypen von df:\\n{df.dtypes}\")\n\n# Datentyp von Spalte 1 ändern\ndf['Spalte 1'] = df['Spalte 1'].astype('string')\nprint(f\"\\nDie Datentypen von df:\\n{df.dtypes}\")\n\nDie Datentypen von df:\nSpalte 1    object\nSpalte 2      bool\ndtype: object\n\nDie Datentypen von df:\nSpalte 1    string[python]\nSpalte 2              bool\ndtype: object\n\n\nEbenso kann allen Spalten eines DataFrames ein Datentyp zugewiesen werden.\n\ndf = df.astype('string')\nprint(f\"\\nDie Datentypen von df:\\n{df.dtypes}\")\n\n\nDie Datentypen von df:\nSpalte 1    string[python]\nSpalte 2    string[python]\ndtype: object\n\n\nUm unterschiedliche Datentypen zuzweisen, wird ein Dictionary verwendet.\n\ndf = df.astype({'Spalte 1': 'int', 'Spalte 2': 'bool'})\nprint(f\"\\nDie Datentypen von df:\\n{df.dtypes}\")\n\n\nDie Datentypen von df:\nSpalte 1    int32\nSpalte 2     bool\ndtype: object\n\n\nSpaltennamen und Index eines bestehenden DataFrame können über entsprechende Attribute oder Methoden verändert werden. Die Spaltennamen können über das Attribut pd.DataFrame.columns geändert werden. Dabei muss die Länge der Liste der Spaltenanzahl entsprechen. Der Index kann über das Attribut pd.DataFrame.index geändert werden. Dabei muss die Länge der Liste der Anzahl Zeilen entsprechen.\n\n# ändern der Spaltennamen über das Attribut .columns\ndf.columns = ['Spalte1', 'Spalte2']\ndf.index = [1, 2, 3]\nprint(df)\n\n   Spalte1  Spalte2\n1        1     True\n2        2     True\n3        3     True\n\n\nMit der Methode pd.DataFrame.rename(columns = {\"alt1\": \"neu1\", \"alt2\": \"neu2\"}, index = {\"alt1\": \"neu1\", \"alt2\": \"neu2\"}, inplace = True) können Spalten- und Zeilenbeschriftungen in Form eines Dictionarys übergeben werden. Auf diese Weise können alle oder ausgewählte Beschriftungen geändert werden. Durch den Parameter inplace = True erfolgt die Zuweisung direkt ohne Neuzuweisung des Objekts.\n\ndf.rename(columns = {'Spalte1': 'Spalte_1', 'Spalte2': 'Spalte_2'}, index = {1: 'A1', 2: 'B2', 3: 'C3'}, inplace = True)\nprint(df)\n\n    Spalte_1  Spalte_2\nA1         1      True\nB2         2      True\nC3         3      True\n\n\nMit der Methode pd.DataFrame.reset_index(inplace = True, drop = True) wird der Index auf die Standardwerte zurückgesetzt. Wird der Parameter drop = False gesetzt, wird der alte Index als Spalte an Indexposition 0 in den DataFrame eingefügt.\n\ndf.reset_index(inplace = True, drop = True)\nprint(df)\n\n   Spalte_1  Spalte_2\n0         1      True\n1         2      True\n2         3      True",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Einleitung</span>"
    ]
  },
  {
    "objectID": "einleitung.html#slicing",
    "href": "einleitung.html#slicing",
    "title": "1  Einleitung",
    "section": "1.3 Slicing",
    "text": "1.3 Slicing\nHinweis: dieser Abschnitt kommt ähnlich auch im m-EsD vor.\n\n\n\n\nzweidimensionaler Datensatz\n\n\nslicing von Marc Fehr ist lizensiert unter CC-BY-4.0 und abrufbar auf GitHub. Die Grafik wurde auf den gezeigten Teil beschnitten und die obenstehende Beschriftung entfernt. 2024\n\n \nPandas bringt eigene Werkzeuge für die Auswahl von Indexbereichen mit. Der aus der Pythonbasis bekannt Slice Operator wird deshalb nur kurz vorgestellt.\n\nSlice Operator\nMit dem Slice Operator können wie bei einer Liste Indexbereiche aus einer Series ausgewählt werden.\n\nzehn_zahlen = pd.Series(range(0, 10))\nprint(zehn_zahlen[3:6])\n\n3    3\n4    4\n5    5\ndtype: int64\n\n\nMit dem Slice Operator werden die Zeilen eines DataFrames ausgewählt.\n\nprint(meerschweinchen[7:12])\n\n    ID   len supp  dose\n7    8  11.2   VC   0.5\n8    9   5.2   VC   0.5\n9   10   7.0   VC   0.5\n10  11  16.5   VC   1.0\n11  12  16.5   VC   1.0\n\n\nDurch Angabe eines Spaltennamens wird die entsprechende Spalte ausgewählt, die als Series zurückgegeben wird. Durch das Anfügen eines zweiten Slice Operators ist es möglich, wie bei einem eindimensionalen Datensatz die Werte in einem bestimmten Indexbereich abzurufen. Dies wird verkettete Indexierung genannt.\n\nprint(meerschweinchen['dose'][10:15], \"\\n\")\nprint(type(meerschweinchen['dose'][10:15]))\n\n10    1.0\n11    1.0\n12    1.0\n13    1.0\n14    1.0\nName: dose, dtype: float64 \n\n&lt;class 'pandas.core.series.Series'&gt;\n\n\n\n\n\n\n\n\nHinweis 1.2: Verkettete Indexierung\n\n\n\nDie verkettete Indexierung erzeugt in Pandas abhängig vom Kontext eine Kopie des Objekts oder greift auf den Speicherbereich des Objekts zu. Mit Pandas 3.0 wird die verkettete Indexierung nicht mehr unterstützt, das Anlegen einer Kopie wird zum Standard werden. Weitere Informationen erhalten Sie im zitierten Link.\n\n\n\n\n\n\n \n\n\n“Whether a copy or a reference is returned for a setting operation, may depend on the context. This is sometimes called chained assignment and should be avoided. See Returning a View versus Copy.”\n\n\n \n\n\n\n(Pandas Dokumentation)\n\n\n\n\nSlicing mit Pandas-Methoden\nFür das Slicing von Series und DataFrames werden in Pandas die Methoden .iloc[] und .loc[] verwendet.\n\n.loc[] arbeitet mit Index- oder Spaltenbeschriftungen, akzeptiert aber auch ein boolsches Array.\n.iloc[] arbeitet mit Ganzzahlen, akzeptiert aber auch ein boolsches Array.\n\nFür das Slicing von Series wird eine Bereichsangabe übergeben, bspw. pd.Series.iloc[5:8]. Für das Slicing von DataFrames werden zwei durch ein Komma getrennte Bereichsangaben übergeben, wobei an erster Stelle die Zeilen und an zweiter Stelle die Spalten ausgewählt werden, bspw. pd.Series.iloc[5, 2:4]. Um alle Zeilen oder Spalten auszuwählen kann der Doppelpunkt verwendet werden, etwa pd.Series.iloc[5, :].\n\nBeschriftungsbasiertes Slicing mit .loc[]\nFür eine Series interpretiert .loc übergebene Zeichen als Indexbeschriftung. Buchstaben und andere Zeichen werden wie strings in Anführungszeichen übergeben, bspw. .loc['e'], Zahlen ohne Anführungszeichen. Neben Einzelwerten (‘a’ oder 0) können Listen oder Arrays ([‘a’, ‘b’, ‘c’] oder [1, 2, 3]) und Slices übergeben werden (‘a’:‘c’ oder 0:2). Das Slicing mit einem Einzelwert führt zur Rückgabe eines Einzelwerts (sog. Skalar).\nAnders als die Pythonbasis und das Slicing mit .iloc[] zählt Pandas beim beschriftungsbasiertem Slicing inklusiv, gibt also die letzte ausgewählte Position mit aus.\n\n# Nummern\nzehn_zahlen = pd.Series(range(0, 10))\nprint(\"Rückgabe eines Einzelwerts:\", zehn_zahlen.loc[5]) # Einzelwert\nprint(zehn_zahlen.loc[[2, 4, 7]]) # Liste\nprint(zehn_zahlen.loc[5:7], \"\\n\") # Slice\n\n# Buchstaben und andere Zeichen\nsechs_zahlen = pd.Series(list(range(0, 6)), index = ['a', 'b', 'c', 'd', 'e', 'f'])\nprint(\"Rückgabe eines Einzelwerts:\", sechs_zahlen.loc['c']) # Einzelwert\nprint(sechs_zahlen.loc[['c', 'f', 'a']]) # Liste\nprint(sechs_zahlen.loc['c':'e']) # Slice\n\nRückgabe eines Einzelwerts: 5\n2    2\n4    4\n7    7\ndtype: int64\n5    5\n6    6\n7    7\ndtype: int64 \n\nRückgabe eines Einzelwerts: 2\nc    2\nf    5\na    0\ndtype: int64\nc    2\nd    3\ne    4\ndtype: int64\n\n\nDie Interpretation als Beschriftung bedeutet, dass bei einem nicht numerischen Index, übergebene Zahlen nicht gefunden werden.\n\ntry:\n  print(sechs_zahlen.loc[2:4])\nexcept Exception as error:\n  print(error)\n\ncannot do slice indexing on Index with these indexers [2] of type int\n\n\nFür DataFrames funktioniert das Slicing genauso.\n\nprint(meerschweinchen.loc[18:22, ['len', 'dose']])\n\n     len  dose\n18  18.8   1.0\n19  15.5   1.0\n20  23.6   2.0\n21  18.5   2.0\n22  33.9   2.0\n\n\n\n\n\nIndexbasiertes Slicing mit .iloc[]\nDie Methode .iloc[] ermöglicht die Auswahl von Ausschnitten basierend auf Indexpositionen. Die Methode akzeptiert die gleichen Eingaben wie die Methode .loc[]. Beim Slicing mit der Methode .iloc[] zählt Pandas wie die Pythonbasis exklusiv.\nDas Slicing mit Einzelwerten führt ebenfalls zur Ausgabe eines Einzelwertes\n\nprint(\"Rückgabe eines Einzelwerts:\", meerschweinchen.iloc[27, 2]) # Einzelwerte\nprint(meerschweinchen.iloc[[27, 29, 52], 2:4]) # Liste und Slice\n\nRückgabe eines Einzelwerts: VC\n   supp  dose\n27   VC   2.0\n29   VC   2.0\n52   OJ   2.0\n\n\nNotiz: .loc, .iloc, and also [] indexing can accept a callable as indexer. See more at Selection By Callable.\n\nDie Methoden .head() und .tail()\nVereinfachte Varianten des numerisches Slicings sind die Methoden .head(n=5) und .tail(n=5), mit denen die ersten bzw. letzten n Zeilen eines DataFrame oder einer Series ausgegeben werden können. Über den optionalen Paramenter n kann die Anzahl der angezeigten Zeilen gesteuert werden. Die Methoden eignen sich gut, um sich einen ersten Eindruck von einem Datensatz zu verschaffen.\n\nprint(meerschweinchen.head(3), \"\\n\")\nprint(meerschweinchen.tail(3))\n\n   ID   len supp  dose\n0   1   4.2   VC   0.5\n1   2  11.5   VC   0.5\n2   3   7.3   VC   0.5 \n\n    ID   len supp  dose\n57  58  27.3   OJ   2.0\n58  59  29.4   OJ   2.0\n59  60  23.0   OJ   2.0\n\n\nEbenso können Series damit betrachtet werden.\n\nprint(meerschweinchen['len'].tail(3))\n\n57    27.3\n58    29.4\n59    23.0\nName: len, dtype: float64",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Einleitung</span>"
    ]
  },
  {
    "objectID": "einleitung.html#nützliche-methoden",
    "href": "einleitung.html#nützliche-methoden",
    "title": "1  Einleitung",
    "section": "1.3 nützliche Methoden",
    "text": "1.3 nützliche Methoden\nhierhier: erst Slicing, dann pd.concat, pd.DataFrame.drop\nZeilen / Spalten hinzufügen oder entfernen\n\npd.DataFrame.drop([labels, axis, index, columns, level, …])\npd.DataFrame.insert(loc, column, value[, allow_duplicates])\npd.DataFrame.Index.insert : Insert new item by index.\nwie fügt man eine Zeile an position x ein?\n\nDataFrames vereinen\n\npd.DataFrame.concat()\npd.DataFrame.merge(right[, how, on, left_on, right_on, …])\nMerge DataFrame or named Series objects with a database-style join.\n\nNamen ändern - reset_index([level, drop, inplace, …])\nReset the index, or a level of it.\n\nrename([mapper, index, columns, axis, copy, …]\nRename columns or index labels.\n\nWerte ersetzen\n\nwhere(cond[, other, inplace, axis, level])\nReplace values where the condition is False.\n\nDrop specified labels from rows or columns. Was passiert eigentlich mit dem Index, wenn man nun die Series mit unterschiedlichen Indizes zusammenbindet? –&gt; der df wird länger / breiter\n… reset_index(drop = True)\n\nnützliche Attribute\nAttribut heißt dtypes (zusätzliches beachten) T –&gt; der transponierte DataFrame https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.html Besondere: beide bringen einen Index mit… der Index kann auch aus Buchstaben oder Datumsinformationen bestehen\nDatentyp via .dtype",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Einleitung</span>"
    ]
  },
  {
    "objectID": "einleitung.html#operationen",
    "href": "einleitung.html#operationen",
    "title": "1  Einleitung",
    "section": "1.2 Operationen",
    "text": "1.2 Operationen\nWie NumPy erlaubt Pandas vektorisierte Operationen.\n\n# Index zurücksetzen\nnumerische_series.reset_index(inplace = True, drop = True)\n\nprint(numerische_series + 1, \"\\n\")\nprint(numerische_series * numerische_series, \"\\n\")\n\nprint(numerische_series // 2 == 0)\n\n0    2\n1    3\n2    4\nName: Ganzzahlen, dtype: int32 \n\n0    1\n1    4\n2    9\nName: Ganzzahlen, dtype: int32 \n\n0     True\n1    False\n2    False\nName: Ganzzahlen, dtype: bool\n\n\nFür die meisten Funktionen stehen Methoden zur Verfügung. –&gt; Sehr viele –&gt; Tipp: In der Dokumentation nachschlagen.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Einleitung</span>"
    ]
  },
  {
    "objectID": "einleitung.html#datenstrukturen-beschreiben-und-ausschnitte-auswählen",
    "href": "einleitung.html#datenstrukturen-beschreiben-und-ausschnitte-auswählen",
    "title": "1  Einleitung",
    "section": "1.2 Datenstrukturen beschreiben und Ausschnitte auswählen",
    "text": "1.2 Datenstrukturen beschreiben und Ausschnitte auswählen\n.columns() .head() / .tail() .columns .shape - Länge der Dimensionen .info() (siehe m-EsD)\nSlicing mit Slice Operator, iloc, loc",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Einleitung</span>"
    ]
  },
  {
    "objectID": "einleitung.html#löschen-und-verbinden",
    "href": "einleitung.html#löschen-und-verbinden",
    "title": "1  Einleitung",
    "section": "1.5 Löschen und verbinden",
    "text": "1.5 Löschen und verbinden\nDataFrames sind flexible Datenspeicher. Mit der Funktion pd.concat() können Series und DataFrames zusammengeführt werden. dann pd.concat, pd.DataFrame.drop\n\nseries_1 = pd.Series([1, 2, 3])\nseries_2 = pd.Series([4, 5, 6])\nprint(pd.concat([series_1, series_2]))\n\n0    1\n1    2\n2    3\n0    4\n1    5\n2    6\ndtype: int64\n\n\nTemperaturseries für mehrere Jahre verbinden\n\ntemperaturen_2022 = pd.Series([3, 6, 9, 13, 18, 21, 24, 23, 19, 14, 8, 4],\n                         index = ['Jan', 'Feb', 'Mär', 'Apr', 'Mai', 'Jun', \n                         'Jul', 'Aug', 'Sep', 'Okt', 'Nov', 'Dez'])\n\ntemperaturen_2023 = pd.Series([-3, -1, 4, 9, 15, 20, 20, 19, 16, 15, 7, 6],\n                         index = ['Jan', 'Feb', 'Mär', 'Apr', 'Mai', 'Jun', \n                         'Jul', 'Aug', 'Sep', 'Okt', 'Nov', 'Dez'])\n\ntemperaturen_2024 = pd.Series([-1, 2, 5, 8, 17, 24, 25, 20, 17, 14, 9, 2],\n                         index = ['Jan', 'Feb', 'Mär', 'Apr', 'Mai', 'Jun', \n                         'Jul', 'Aug', 'Sep', 'Okt', 'Nov', 'Dez'])\n\nder del Operator geht auch: &gt;&gt;&gt; del test[‘numbers’] (löscht eine Spalte)\nZeilen / Spalten hinzufügen oder entfernen\n\npd.DataFrame.drop([labels, axis, index, columns, level, …])\npd.DataFrame.insert(loc, column, value[, allow_duplicates])\npd.DataFrame.Index.insert : Insert new item by index.\nwie fügt man eine Zeile an position x ein?\n\nDataFrames vereinen\n\npd.DataFrame.concat()\npd.DataFrame.merge(right[, how, on, left_on, right_on, …])\nMerge DataFrame or named Series objects with a database-style join.\n\n\nnützliche Attribute\nAttribut heißt dtypes (zusätzliches beachten) T –&gt; der transponierte DataFrame https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.html Besondere: beide bringen einen Index mit… der Index kann auch aus Buchstaben oder Datumsinformationen bestehen\nDatentyp via .dtype",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Einleitung</span>"
    ]
  },
  {
    "objectID": "einleitung.html#funktionen-für-die-deskriptive-datenanalyse",
    "href": "einleitung.html#funktionen-für-die-deskriptive-datenanalyse",
    "title": "1  Einleitung",
    "section": "1.2 Funktionen für die deskriptive Datenanalyse",
    "text": "1.2 Funktionen für die deskriptive Datenanalyse\nNotiz: Der Teil ist zu großen Teilen auch im m-EsD enthalten –&gt; eine Dopplung wäre okay, ein Querverweis kann aber auch ergänzt werden.\nPandas bietet einige praktische Funktionen, um den Aufbau eines Datensatzes zu beschreiben. Als Beispieldatensatz dienen Daten zur Länge zahnbildender Zellen bei Meerschweinchen, die Vitamin C direkt (VC) oder in Form von Orangensaft (OJ) in unterschiedlichen Dosen erhielten.\n\nCrampton, E. W. 1947. „THE GROWTH OF THE ODONTOBLASTS OF THE INCISOR TOOTH AS A CRITERION OF THE VITAMIN C INTAKE OF THE GUINEA PIG“. The Journal of Nutrition 33 (5): 491–504. https://doi.org/10.1093/jn/33.5.491\n\n \nEin Aussschnitt des Datensatzes:\n\n\n\n\n\n\n\n\n\n\nID\nlen\nsupp\ndose\n\n\n\n\n0\n1\n4.2\nVC\n0.5\n\n\n10\n11\n16.5\nVC\n1.0\n\n\n20\n21\n23.6\nVC\n2.0\n\n\n30\n31\n15.2\nOJ\n0.5\n\n\n40\n41\n19.7\nOJ\n1.0\n\n\n50\n51\n25.5\nOJ\n2.0\n\n\n\n\n\n\n\n\n \nDie Methode pd.DataFrame.info() erzeugt eine Beschreibung des Datensatzes.\n\nmeerschweinchen.info()\n\n&lt;class 'pandas.core.frame.DataFrame'&gt;\nRangeIndex: 60 entries, 0 to 59\nData columns (total 4 columns):\n #   Column  Non-Null Count  Dtype   \n---  ------  --------------  -----   \n 0   ID      60 non-null     int32   \n 1   len     60 non-null     float64 \n 2   supp    60 non-null     category\n 3   dose    60 non-null     float64 \ndtypes: category(1), float64(2), int32(1)\nmemory usage: 1.5 KB\n\n\nDie Dimensionen einer Series oder eines DataFrame können mit dem Attribut shape abgerufen werden.\n\nprint(meerschweinchen.shape)\n\n(60, 4)\n\n\nMit den Methoden .head(n=5) und .tail(n=5) können die ersten bzw. letzten n Zeilen eines DataFrame oder einer Series ausgegeben werden. Über den optionalen Paramenter n kann die Anzahl der angezeigten Zeilen gesteuert werden.\n\nprint(meerschweinchen.head(3), \"\\n\")\nprint(meerschweinchen.tail(3))\n\n   ID   len supp  dose\n0   1   4.2   VC   0.5\n1   2  11.5   VC   0.5\n2   3   7.3   VC   0.5 \n\n    ID   len supp  dose\n57  58  27.3   OJ   2.0\n58  59  29.4   OJ   2.0\n59  60  23.0   OJ   2.0\n\n\nDie Methode pd.DataFrame.describe() erzeugt eine beschreibende Statistik für einen DataFrame. Standardmäßig werden alle numerischen Spalten berücksichtigt. Mit dem Parameter include können die zu berücksichtigenden Spalten vorgegeben werden. include = all berücksichtigt alle Spalten, was nicht unbedingt sinnvoll ist, da auf diese Weise auch die Spalte mit den ID-Nummern der Meerschweinchen ausgewertet wird.\n\nprint(meerschweinchen.describe(include = 'all'))\n\n               ID        len supp       dose\ncount   60.000000  60.000000   60  60.000000\nunique        NaN        NaN    2        NaN\ntop           NaN        NaN   OJ        NaN\nfreq          NaN        NaN   30        NaN\nmean    30.500000  18.813333  NaN   1.166667\nstd     17.464249   7.649315  NaN   0.628872\nmin      1.000000   4.200000  NaN   0.500000\n25%     15.750000  13.075000  NaN   0.500000\n50%     30.500000  19.250000  NaN   1.000000\n75%     45.250000  25.275000  NaN   2.000000\nmax     60.000000  33.900000  NaN   2.000000\n\n\nMit dem Parameter include kann eine Liste zu berücksichtigender Datentypen übergeben werden. Der Parameter exclude schließt auf die gleiche Weise Datentypen von der Ausgabe aus.\n\nprint(meerschweinchen.describe(include = ['float']))\n\n             len       dose\ncount  60.000000  60.000000\nmean   18.813333   1.166667\nstd     7.649315   0.628872\nmin     4.200000   0.500000\n25%    13.075000   0.500000\n50%    19.250000   1.000000\n75%    25.275000   2.000000\nmax    33.900000   2.000000\n\n\n\nprint(meerschweinchen.describe(include = ['category']))\n\n       supp\ncount    60\nunique    2\ntop      OJ\nfreq     30\n\n\nDie Methode pd.DataFrame.count() zählt alle vorhandenen Werte in jeder Spalte oder mit pd.DataFrame.count(axis = 'columns') in jeder Zeile.\n\nmeerschweinchen.count(axis = 'rows') # der Standardwert von axis ist 'rows'\n\nID      60\nlen     60\nsupp    60\ndose    60\ndtype: int64\n\n\nDie Methode pd.unique() listet alle einzigartigen Werte einer Series auf.\n\nmeerschweinchen['dose'].unique()\n\narray([0.5, 1. , 2. ])",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Einleitung</span>"
    ]
  },
  {
    "objectID": "einleitung.html#slicing-1",
    "href": "einleitung.html#slicing-1",
    "title": "1  Einleitung",
    "section": "1.8 Slicing",
    "text": "1.8 Slicing\nSlicing mit dem Slice Operator []funktioniert ganz normal… die Auswahl einer Spalte oder einer Zeile (?!) aus einem df wird als Series zurückgegeben. (wie behält man die spaltenbeschriftung?). Verkettetes Slicing wird nicht mehr empfohlen - siehe m-EsD\nPerformanter, weil auf den tatsächlich enthaltenen Datentyp abgestimmt, sind die pandaseigenen Werkzeuge.\n\n.loc is primarily label based, but may also be used with a boolean array.\n.iloc is primarily integer position based (from 0 to length-1 of the axis), but may also be used with a boolean array.\n\nAttribt .at\nAttribut .axes In Python stellt das Modul Pandas die DataFrame-Struktur bereit.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Einleitung</span>"
    ]
  },
  {
    "objectID": "einleitung.html#section",
    "href": "einleitung.html#section",
    "title": "1  Einleitung: Datenstrukturen in Pandas",
    "section": "1.8 ",
    "text": "1.8 \nPandas: 2-dimensionale DataFrame-Struktur im long- und wide-Format. DataFrames können mehrere Datentypen enthalten und die Größe von DataFrames ist veränderlich. Unterstützung von alphanummerischen Spalten- und Indexbeschriftungen. Direktes Abrufen von Dateien aus dem Internet möglich.\n\numfangreiche Funktionen zur Verarbeitung von Datumsinformationen und Zeitreihen\n\n## Quellen https://pandas.pydata.org/docs/user_guide/dsintro.html https://pandas.pydata.org/docs/user_guide/basics.html",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Einleitung: Datenstrukturen in Pandas</span>"
    ]
  },
  {
    "objectID": "operationen.html",
    "href": "operationen.html",
    "title": "2  Operationen",
    "section": "",
    "text": "2.1 Zeilen- und spaltenweise Operationen\nPandas erlaubt wie NumPy vektorisierte Operationen, das heißt Berechnungen mit einer Series oder einem DataFrame werden auf jedes Element angewendet. So können die Rechenoperatoren direkt verwendet werden.\nAuch boolsche Operationen können direkt ausgeführt werden.\nPandas umfasst eine Vielzahl von Methoden, die arithmetische, summarische, boolsche und Indexfunktionen umsetzen. Eine vollständige Übersicht finden Sie hier: https://pandas.pydata.org/docs/reference/index.html.\nIn der Regel werden die Funktionen standardmäßig spaltenweise angewendet. Mit dem Argument axis = 1 wird die jeweilige Funktion zeilenweise ausgeführt. Die Funktionen sind auch für Series verfügbar.\nIm Folgenden werden einige Methoden exemplarisch vorgestellt.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Operationen</span>"
    ]
  },
  {
    "objectID": "einleitung.html#deskriptive-datenanalyse-mit-pandas",
    "href": "einleitung.html#deskriptive-datenanalyse-mit-pandas",
    "title": "1  Einleitung",
    "section": "1.2 Deskriptive Datenanalyse mit Pandas",
    "text": "1.2 Deskriptive Datenanalyse mit Pandas\nNotiz: Der Teil ist zu großen Teilen auch im m-EsD enthalten –&gt; eine Dopplung wäre okay, ein Querverweis kann aber auch ergänzt werden.\nPandas bietet einige praktische Funktionen, um den Aufbau eines Datensatzes und die enthaltenen Daten zu beschreiben. Als Beispieldatensatz dienen Daten zur Länge zahnbildender Zellen bei Meerschweinchen, die Vitamin C direkt (VC) oder in Form von Orangensaft (OJ) in unterschiedlichen Dosen erhielten.\n\n\n\n\n\ndateipfad = \"skript/01-daten/ToothGrowth.csv\"\nmeerschweinchen = pd.read_csv(filepath_or_buffer = dateipfad, sep = ',', header = 0, \\\n  names = ['ID', 'len', 'supp', 'dose'], dtype = {'ID': 'int', 'len': 'float', 'dose': 'float', 'supp': 'category'})\n\n\n\nCode-Block 1.1\n\n\n\nCrampton, E. W. 1947. „THE GROWTH OF THE ODONTOBLASTS OF THE INCISOR TOOTH AS A CRITERION OF THE VITAMIN C INTAKE OF THE GUINEA PIG“. The Journal of Nutrition 33 (5): 491–504. https://doi.org/10.1093/jn/33.5.491\n\n \nEin Aussschnitt des Datensatzes:\n\n\n\n\n\n\n\n\n\n\nID\nlen\nsupp\ndose\n\n\n\n\n0\n1\n4.2\nVC\n0.5\n\n\n10\n11\n16.5\nVC\n1.0\n\n\n20\n21\n23.6\nVC\n2.0\n\n\n30\n31\n15.2\nOJ\n0.5\n\n\n40\n41\n19.7\nOJ\n1.0\n\n\n50\n51\n25.5\nOJ\n2.0\n\n\n\n\n\n\n\n\n \nDie Methode pd.DataFrame.info() erzeugt eine Beschreibung des Datensatzes.\n\nmeerschweinchen.info()\n\n&lt;class 'pandas.core.frame.DataFrame'&gt;\nRangeIndex: 60 entries, 0 to 59\nData columns (total 4 columns):\n #   Column  Non-Null Count  Dtype   \n---  ------  --------------  -----   \n 0   ID      60 non-null     int32   \n 1   len     60 non-null     float64 \n 2   supp    60 non-null     category\n 3   dose    60 non-null     float64 \ndtypes: category(1), float64(2), int32(1)\nmemory usage: 1.5 KB\n\n\nDie Dimensionen einer Series oder eines DataFrame können mit dem Attribut shape abgerufen werden. Der DataFrame hat 60 Zeilen und 4 Spalten.\n\nprint(meerschweinchen.shape)\n\n(60, 4)\n\n\nDie Methode pd.DataFrame.describe() erzeugt eine beschreibende Statistik für einen DataFrame. Standardmäßig werden alle numerischen Spalten berücksichtigt. Mit dem Parameter include können die zu berücksichtigenden Spalten vorgegeben werden. include = all berücksichtigt alle Spalten, was nicht unbedingt sinnvoll ist, da auf diese Weise auch die Spalte mit den ID-Nummern der Meerschweinchen ausgewertet wird.\n\nprint(meerschweinchen.describe(include = 'all'))\n\n               ID        len supp       dose\ncount   60.000000  60.000000   60  60.000000\nunique        NaN        NaN    2        NaN\ntop           NaN        NaN   OJ        NaN\nfreq          NaN        NaN   30        NaN\nmean    30.500000  18.813333  NaN   1.166667\nstd     17.464249   7.649315  NaN   0.628872\nmin      1.000000   4.200000  NaN   0.500000\n25%     15.750000  13.075000  NaN   0.500000\n50%     30.500000  19.250000  NaN   1.000000\n75%     45.250000  25.275000  NaN   2.000000\nmax     60.000000  33.900000  NaN   2.000000\n\n\nMit dem Parameter include kann eine Liste zu berücksichtigender Datentypen übergeben werden. Der Parameter exclude schließt auf die gleiche Weise Datentypen von der Ausgabe aus.\n\nprint(meerschweinchen.describe(include = ['float']))\n\n             len       dose\ncount  60.000000  60.000000\nmean   18.813333   1.166667\nstd     7.649315   0.628872\nmin     4.200000   0.500000\n25%    13.075000   0.500000\n50%    19.250000   1.000000\n75%    25.275000   2.000000\nmax    33.900000   2.000000\n\n\n\nprint(meerschweinchen.describe(include = ['category']))\n\n       supp\ncount    60\nunique    2\ntop      OJ\nfreq     30\n\n\nDie Methode pd.DataFrame.count() zählt alle nicht fehlenden Werte in jeder Spalte oder mit pd.DataFrame.count(axis = 'columns') in jeder Zeile.\n\nmeerschweinchen.count(axis = 'rows') # der Standardwert von axis ist 'rows'\n\nID      60\nlen     60\nsupp    60\ndose    60\ndtype: int64\n\n\nDie Methode pd.Series.value_counts() zählt die Anzahl der Merkmalsausprägungen in einer Series. Die Methode kann auch auf einen DataFrame angewendet werden, dann wird die Häufigkeit jeder einzigartigen Zeile gezählt (was hier nicht sinnvoll ist).\n\nmeerschweinchen['dose'].value_counts()\n\ndose\n0.5    20\n1.0    20\n2.0    20\nName: count, dtype: int64\n\n\nDie Methode pd.unique() listet alle einzigartigen Werte einer Series auf.\n\nmeerschweinchen['dose'].unique()\n\narray([0.5, 1. , 2. ])",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Einleitung</span>"
    ]
  },
  {
    "objectID": "einleitung.html#slicing-mit-pandas-methoden",
    "href": "einleitung.html#slicing-mit-pandas-methoden",
    "title": "1  Einleitung",
    "section": "1.4 Slicing mit Pandas-Methoden",
    "text": "1.4 Slicing mit Pandas-Methoden\nNotiz: .loc, .iloc, and also [] indexing can accept a callable as indexer. See more at Selection By Callable.\n\niloc",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Einleitung</span>"
    ]
  },
  {
    "objectID": "einleitung.html#loc",
    "href": "einleitung.html#loc",
    "title": "1  Einleitung",
    "section": "1.4 loc",
    "text": "1.4 loc\nMit iloc können durch die Angabe der Indizes entlang der 0. (Zeilen) und der 1. Achse (Spalten) Ausschnitte aus einem DataFrame ausgewählt werden.\nSlicing mit Slice Operator []\nSlicing mit Slice Operator, iloc, loc\nMit den Methoden .head(n=5) und .tail(n=5) können die ersten bzw. letzten n Zeilen eines DataFrame oder einer Series ausgegeben werden. Über den optionalen Paramenter n kann die Anzahl der angezeigten Zeilen gesteuert werden.\n\nprint(meerschweinchen.head(3), \"\\n\")\nprint(meerschweinchen.tail(3))\n\n   ID   len supp  dose\n0   1   4.2   VC   0.5\n1   2  11.5   VC   0.5\n2   3   7.3   VC   0.5 \n\n    ID   len supp  dose\n57  58  27.3   OJ   2.0\n58  59  29.4   OJ   2.0\n59  60  23.0   OJ   2.0",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Einleitung</span>"
    ]
  },
  {
    "objectID": "einleitung.html#aufgaben-slicing",
    "href": "einleitung.html#aufgaben-slicing",
    "title": "1  Einleitung",
    "section": "1.4 Aufgaben Slicing",
    "text": "1.4 Aufgaben Slicing\n\nGegeben ist eine Pandas Series ‘temperaturen_2021’ mit den durchschnittlichen Monatstemperaturen.\n\n\ntemperaturen_2021 = pd.Series([2, 4, 7, 12, 19, 23, 25, 23, 18, 15, 9, 5],\n                         index = ['Jan', 'Feb', 'Mär', 'Apr', 'Mai', 'Jun', \n                         'Jul', 'Aug', 'Sep', 'Okt', 'Nov', 'Dez'])\n\nWählen Sie die Temperaturen für die Frühlingsmonate (März bis Mai) aus.\n\nWählen Sie die Temperaturen für die letzten drei Monate des Jahres einmal mit Hilfe des Slicing Operators und einmal mit Hilfe der Pandas-Methoden aus.\nWählen Sie mit der Methode .loc[] die Spalte ‘dose’ und ‘len’ des DataFrame meerschweinchen aus und geben Sie die ersten 4 und die letzten 3 Zeilen aus. (Code zum Einlesen der Datei siehe Code-Block 1.1)\nDie Methoden .loc[] und .iloc[] akzepzieren auch ein boolsches Array als Eingabe. Geben Sie aus der Spalte ‘dose’ des DataFrame meerschweinchen alle Zeilen mit dem Wert 2.0 aus.\n\n\n\n\n\n\n\nTipp 1.3: Musterlösung Slicing\n\n\n\n\n\nAufgabe 1\n\nprint(temperaturen_2021.loc[['Mär', 'Apr', 'Mai']])\n\nMär     7\nApr    12\nMai    19\ndtype: int64\n\n\nAufgabe 2\n\nprint(temperaturen_2021[len(temperaturen_2021)-3:], \"\\n\")\nprint(temperaturen_2021.iloc[len(temperaturen_2021)-3:])\n\nOkt    15\nNov     9\nDez     5\ndtype: int64 \n\nOkt    15\nNov     9\nDez     5\ndtype: int64\n\n\nAufgabe 3\n\nprint(meerschweinchen.loc[ :, ['dose', 'len']].head(n = 4), \"\\n\")\nprint(meerschweinchen.loc[ :, ['dose', 'len']].tail(n = 3))\n\n   dose   len\n0   0.5   4.2\n1   0.5  11.5\n2   0.5   7.3\n3   0.5   5.8 \n\n    dose   len\n57   2.0  27.3\n58   2.0  29.4\n59   2.0  23.0\n\n\nAufgabe 4\n\n# Slice aus Series\n# print(meerschweinchen['dose'].loc[meerschweinchen['dose'] == 2.0])\n\n# Slice aus DataFrame\nprint(meerschweinchen.loc[meerschweinchen['dose'] == 2.0, ['dose']])\n\n    dose\n20   2.0\n21   2.0\n22   2.0\n23   2.0\n24   2.0\n25   2.0\n26   2.0\n27   2.0\n28   2.0\n29   2.0\n50   2.0\n51   2.0\n52   2.0\n53   2.0\n54   2.0\n55   2.0\n56   2.0\n57   2.0\n58   2.0\n59   2.0",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Einleitung</span>"
    ]
  },
  {
    "objectID": "operationen.html#aufgaben-operationen",
    "href": "operationen.html#aufgaben-operationen",
    "title": "2  Operationen",
    "section": "2.6 Aufgaben Operationen",
    "text": "2.6 Aufgaben Operationen\n\nWählen Sie aus dem DataFrame meerschweinchen alle Zeilen der Spalte ‘dose’ mit den Werten 0.5 und 2.0 aus. Vergleichen Sie nun die durchschnittliche Länge der zahnbildenden Zellen (‘len’) nach der Dosis und der Art der Gabe von Vitamin C (VC) bzw. Orangensaft (OJ) (Spalte ‘supp’). (Code zum Einlesen der Datei siehe Code-Block 1.1)",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Operationen</span>"
    ]
  },
  {
    "objectID": "einleitung.html#datenstrukturen-verbinden-und-löschen",
    "href": "einleitung.html#datenstrukturen-verbinden-und-löschen",
    "title": "1  Einleitung",
    "section": "1.5 Datenstrukturen verbinden und löschen",
    "text": "1.5 Datenstrukturen verbinden und löschen\ndann pd.concat, pd.DataFrame.drop DataFrames sind flexible Datenspeicher. Mit der Funktion pd.concat() können Series und DataFrames zusammengeführt werden.\n\nMit dem Argument pd.concat(ignore_index = True) wird ein neuer Index generiert.\nMit dem Argument pd.concat(axis = 1) werden die übergebenen objekte spaltenweise zusammengeführt.\n\n\nseries_1 = pd.Series([1, 2])\nseries_2 = pd.Series([4, 5])\nprint(pd.concat([series_1, series_2]), \"\\n\")\nprint(pd.concat([series_1, series_2], ignore_index = True), \"\\n\")\nprint(pd.concat([series_1, series_2], ignore_index = True, axis = 1))\n\n0    1\n1    2\n0    4\n1    5\ndtype: int64 \n\n0    1\n1    2\n2    4\n3    5\ndtype: int64 \n\n   0  1\n0  1  4\n1  2  5\n\n\nGleichermaßen können DataFrames verbunden werden.\n\ntemperaturen_2022 = pd.Series([3, 6, 9, 13, 18, 21, 24, 23, 19, 14, 8, 4],\n                         index = ['Jan', 'Feb', 'Mär', 'Apr', 'Mai', 'Jun', \n                         'Jul', 'Aug', 'Sep', 'Okt', 'Nov', 'Dez'])\n\ntemperaturen_2023 = pd.Series([-3, -1, 4, 9, 15, 20, 20, 19, 16, 15, 7, 6],\n                         index = ['Jan', 'Feb', 'Mär', 'Apr', 'Mai', 'Jun', \n                         'Jul', 'Aug', 'Sep', 'Okt', 'Nov', 'Dez'])\n\ntemperaturen_2024 = pd.Series([-1, 2, 5, 8, 17, 24, 25, 20, 17, 14, 9, 2],\n                         index = ['Jan', 'Feb', 'Mär', 'Apr', 'Mai', 'Jun', \n                         'Jul', 'Aug', 'Sep', 'Okt', 'Nov', 'Dez'])\n\n# Series zu DataFrame verbinden\ndf1 = pd.concat([temperaturen_2021, temperaturen_2022], axis = 1)\ndf2 = pd.concat([temperaturen_2023, temperaturen_2024], axis = 1)\n\n# DataFrames verbinden\ntemperaturen = pd.concat([df1, df2], axis = 1)\ntemperaturen.columns = [2021, 2022, 2023, 2024]\nprint(temperaturen)\n\n     2021  2022  2023  2024\nJan     3     3    -3    -1\nFeb     6     6    -1     2\nMär     9     9     4     5\nApr    13    13     9     8\nMai    18    18    15    17\nJun    21    21    20    24\nJul    24    24    20    25\nAug    23    23    19    20\nSep    19    19    16    17\nOkt    14    14    15    14\nNov     8     8     7     9\nDez     4     4     6     2\n\n\nder del Operator geht auch: &gt;&gt;&gt; del test[‘numbers’] (löscht eine Spalte)\nZeilen / Spalten hinzufügen oder entfernen\n\npd.DataFrame.drop([labels, axis, index, columns, level, …])\npd.DataFrame.insert(loc, column, value[, allow_duplicates])\npd.DataFrame.Index.insert : Insert new item by index.\nwie fügt man eine Zeile an position x ein?\n\nDataFrames vereinen\n\npd.DataFrame.concat()\npd.DataFrame.merge(right[, how, on, left_on, right_on, …])\nMerge DataFrame or named Series objects with a database-style join.\n\n\nnützliche Attribute\nAttribut heißt dtypes (zusätzliches beachten) T –&gt; der transponierte DataFrame https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.html Besondere: beide bringen einen Index mit… der Index kann auch aus Buchstaben oder Datumsinformationen bestehen\nDatentyp via .dtype",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Einleitung</span>"
    ]
  },
  {
    "objectID": "einleitung.html#datenstrukturen-verbinden",
    "href": "einleitung.html#datenstrukturen-verbinden",
    "title": "1  Einleitung",
    "section": "1.5 Datenstrukturen verbinden",
    "text": "1.5 Datenstrukturen verbinden\nDataFrames sind flexible Datenspeicher. Mit der Funktion pd.concat() können Series und DataFrames zusammengeführt werden.\n\nMit dem Argument pd.concat(ignore_index = True) wird ein neuer Index generiert.\nMit dem Argument pd.concat(axis = 1) werden die übergebenen objekte spaltenweise zusammengeführt.\n\n\nseries_1 = pd.Series([1, 2])\nseries_2 = pd.Series([4, 5])\nprint(pd.concat([series_1, series_2]), \"\\n\")\nprint(pd.concat([series_1, series_2], ignore_index = True), \"\\n\")\nprint(pd.concat([series_1, series_2], ignore_index = True, axis = 1))\n\n0    1\n1    2\n0    4\n1    5\ndtype: int64 \n\n0    1\n1    2\n2    4\n3    5\ndtype: int64 \n\n   0  1\n0  1  4\n1  2  5\n\n\nGleichermaßen können DataFrames verbunden werden.\n\ntemperaturen_2022 = pd.Series([3, 6, 9, 13, 18, 21, 24, 23, 19, 14, 8, 4],\n                         index = ['Jan', 'Feb', 'Mär', 'Apr', 'Mai', 'Jun', \n                         'Jul', 'Aug', 'Sep', 'Okt', 'Nov', 'Dez'])\n\ntemperaturen_2023 = pd.Series([-3, -1, 4, 9, 15, 20, 20, 19, 16, 15, 7, 6],\n                         index = ['Jan', 'Feb', 'Mär', 'Apr', 'Mai', 'Jun', \n                         'Jul', 'Aug', 'Sep', 'Okt', 'Nov', 'Dez'])\n\ntemperaturen_2024 = pd.Series([-1, 2, 5, 8, 17, 24, 25, 20, 17, 14, 9, 2],\n                         index = ['Jan', 'Feb', 'Mär', 'Apr', 'Mai', 'Jun', \n                         'Jul', 'Aug', 'Sep', 'Okt', 'Nov', 'Dez'])\n\n# Series zu DataFrame verbinden\ndf1 = pd.concat([temperaturen_2021, temperaturen_2022], axis = 1)\ndf2 = pd.concat([temperaturen_2023, temperaturen_2024], axis = 1)\n\n# DataFrames verbinden\ntemperaturen = pd.concat([df1, df2], axis = 1)\ntemperaturen.columns = [2021, 2022, 2023, 2024]\nprint(temperaturen)\n\n     2021  2022  2023  2024\nJan     2     3    -3    -1\nFeb     4     6    -1     2\nMär     7     9     4     5\nApr    12    13     9     8\nMai    19    18    15    17\nJun    23    21    20    24\nJul    25    24    20    25\nAug    23    23    19    20\nSep    18    19    16    17\nOkt    15    14    15    14\nNov     9     8     7     9\nDez     5     4     6     2",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Einleitung</span>"
    ]
  },
  {
    "objectID": "einleitung.html#einfügen-und-löschen-in-datenstrukturen",
    "href": "einleitung.html#einfügen-und-löschen-in-datenstrukturen",
    "title": "1  Einleitung",
    "section": "1.6 Einfügen und löschen in Datenstrukturen",
    "text": "1.6 Einfügen und löschen in Datenstrukturen\nAuch um Einträge zeilen- / oder spaltenweise zu ergänzen und zu löschen bringt Pandas geeignete Methoden mit.\n\npd.DataFrame.drop(labels = None, axis = 0, index = None, columns = None, inplace = False) entfernt Zeilen oder Spalten nach den mit dem Parameter labels als Einzelwert (‘Spalte 1’) oder als Liste ([‘Spalte 1’, ‘Spalte 2’]) übergebenen Beschriftungen. Der Parameter axis = 0 steuert, ob Zeilen oder Spalten (axis = 1) entfernt werden sollen. Die Parameter index und columns sind alternative Möglichkeiten, Index- oder Spaltenbeschriftungen direkt zu übergeben und ersetzen die Parameter labels und axis.\nDer Operator del aus der Pythonbasis löscht Spalten aus einem DataFrame del DataFrame['Spaltenname'].\npd.DataFrame.insert(loc, column, value) fügt eine Spalte an Position loc mit dem Spaltennamen column und dem Inhalt value ein. Falls value eine Series mit abweichendem Index ist, kann über das Attribut value = Series.values auf die enthaltenen Werte der Series zugegriffen und diese in den bestehenden Index einfgefügt werden (andernfalls gleicht Pandas die Indizes der Series und des DataFrames ab und fügt nur die Werte übereinstimmender Indizes ein).\nWerte können zeilweise mit der Methode pd.DataFrame.loc[index] = value eingefügt werden. Falls value eine Series ist, muss über das Attribut value = Series.values auf die enthaltenen Werte der Series zugegriffen werden, da Pandas andernfalls versucht, den Index der Series mit den Spaltennamen des DataFrames abzugleichen. Wird als value ein Einzelwert übergeben, füllt dieser die gesamte Zeile aus.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Einleitung</span>"
    ]
  },
  {
    "objectID": "einleitung.html#aufgaben-verbinden-und-löschen",
    "href": "einleitung.html#aufgaben-verbinden-und-löschen",
    "title": "1  Einleitung",
    "section": "1.7 Aufgaben verbinden und löschen",
    "text": "1.7 Aufgaben verbinden und löschen\nLegen Sie einen leeren DataFrame df = pd.DataFrame() an.\n\nFügen Sie Spalten ‘len’ und ‘dose’ aus dem DataFrame ‘meerschweinchen’ ein.\nLöschen Sie alle ungeraden Zeilennummern aus dem DataFrame df.\nBenutzen Sie die Indexnummern des DataFrame df, um die entsprechenden Zeilen aus der Spalte ‘ID’ des DataFrame ‘meerschweinchen’ auszuwählen. Fügen Sie diese als Spalte an Indexposition 0 in den DataFrame df ein.\n\n\n\n\n\n\n\nTipp 1.4: Musterlösung verbinden und löschen\n\n\n\n\n\n\nAufgabe\n\n\ndf = pd.DataFrame()\n\n# Alternative 1\ndf['len'] = meerschweinchen['len']\n\n# Alternative 2\ndf.insert(loc = 1, column = 'dose', value = meerschweinchen['dose'])\n\nprint(df.head(), \"\\n\", df.shape)\n\n    len  dose\n0   4.2   0.5\n1  11.5   0.5\n2   7.3   0.5\n3   5.8   0.5\n4   6.4   0.5 \n (60, 2)\n\n\n\nAufgabe\n\n\ndf = df.drop(index = range(1, len(df), 2))\n\nprint(df.head(), \"\\n\", df.shape)\n\n    len  dose\n0   4.2   0.5\n2   7.3   0.5\n4   6.4   0.5\n6  11.2   0.5\n8   5.2   0.5 \n (30, 2)\n\n\n\nAufgabe\n\n\ndf.insert(loc = 0, column = 'ID', value = meerschweinchen.loc[df.index, 'ID'])\n\nprint(df.head(), \"\\n\")\nprint(df.tail(), \"\\n\")\nprint(\"df.shape:\", df.shape)\n\n   ID   len  dose\n0   1   4.2   0.5\n2   3   7.3   0.5\n4   5   6.4   0.5\n6   7  11.2   0.5\n8   9   5.2   0.5 \n\n    ID   len  dose\n50  51  25.5   2.0\n52  53  22.4   2.0\n54  55  24.8   2.0\n56  57  26.4   2.0\n58  59  29.4   2.0 \n\ndf.shape: (30, 3)",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Einleitung</span>"
    ]
  },
  {
    "objectID": "einleitung.html#quellen",
    "href": "einleitung.html#quellen",
    "title": "1  Einleitung",
    "section": "Quellen",
    "text": "Quellen\nhttps://pandas.pydata.org/docs/user_guide/dsintro.html https://pandas.pydata.org/docs/user_guide/basics.html",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Einleitung</span>"
    ]
  },
  {
    "objectID": "operationen.html#wohin-boolsche-operatoren",
    "href": "operationen.html#wohin-boolsche-operatoren",
    "title": "2  Operationen",
    "section": "2.4 wohin? boolsche Operatoren?!",
    "text": "2.4 wohin? boolsche Operatoren?!\ndf[df[“A”] &gt; 0] https://pandas.pydata.org/docs/user_guide/10min.html#boolean-indexing\nIndexing with isin https://pandas.pydata.org/docs/user_guide/indexing.html#indexing-with-isin\nThe where() Method and Masking https://pandas.pydata.org/docs/user_guide/indexing.html#the-where-method-and-masking",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Operationen</span>"
    ]
  },
  {
    "objectID": "operationen.html#zeilen--und-spaltenweise-operationen",
    "href": "operationen.html#zeilen--und-spaltenweise-operationen",
    "title": "2  Operationen",
    "section": "",
    "text": "arithmetische Funktionen\nDie Methoden pd.DataFrame.add(), pd.DataFrame.sub(), pd.DataFrame.mul(), pd.DataFrame.div(), pd.DataFrame.floordiv(), pd.DataFrame.mod() und pd.DataFrame.pow() entsprechen den Grundrechenarten mit den Operatoren +, -, *, /, //, %, **. Sie eignen sich gut für verkettete Operationen.\n\nprint(\"Temperaturen in Fahrenheit:\")\nprint(27 * \"=\")\nprint(temperaturen.mul(9).div(5).add(32))\n\nTemperaturen in Fahrenheit:\n===========================\n     2021  2022  2023  2024\nJan  35.6  37.4  26.6  30.2\nFeb  39.2  42.8  30.2  35.6\nMär  44.6  48.2  39.2  41.0\nApr  53.6  55.4  48.2  46.4\nMai  66.2  64.4  59.0  62.6\nJun  73.4  69.8  68.0  75.2\nJul  77.0  75.2  68.0  77.0\nAug  73.4  73.4  66.2  68.0\nSep  64.4  66.2  60.8  62.6\nOkt  59.0  57.2  59.0  57.2\nNov  48.2  46.4  44.6  48.2\nDez  41.0  39.2  42.8  35.6\n\n\nAußerdem kann mit dem Parameter fill_value ein Füllwert für fehlende Werte spezifiziert werden (dieser wird vor der Operation eingesetzt).\n\nmissing_value = pd.Series([1, pd.NA, 3])\nprint(missing_value.add(1, fill_value = -999))\n\n0      2\n1   -998\n2      4\ndtype: int64\n\n\nC:\\Users\\mapoe004\\AppData\\Local\\Temp\\ipykernel_21972\\1043596116.py:2: FutureWarning: Downcasting object dtype arrays on .fillna, .ffill, .bfill is deprecated and will change in a future version. Call result.infer_objects(copy=False) instead. To opt-in to the future behavior, set `pd.set_option('future.no_silent_downcasting', True)`\n  print(missing_value.add(1, fill_value = -999))\n\n\n\n\nsummarische Funktionen\n\npd.DataFrame.mean() ermittelt den Durchschnitt jeder Spalte / Zeile.\npd.DataFrame.median() ermittelt den Median jeder Spalte / Zeile.\npd.DataFrame.mode() ermittelt den Modus jeder Spalte / Zeile.\npd.DataFrame.sum() ermittelt die Summe jeder Spalte / Zeile. pd.DataFrame.cumsum() ermittelt die kummulierte Summe jeder Spalte / Zeile.\npd.DataFrame.min() und pd.DataFrame.max() ermitteln Minimum bzw. Maximum jeder Spalte / Zeile. pd.DataFrame.cummin() und pd.DataFrame.cummax() ermittelt den kummulierten Durchschnitt jeder Spalte / Zeile.\n\n\nprint(\"Mittlere Jahrestemperaturen\")\nprint(27 * \"=\")\nprint(temperaturen.mean(), \"\\n\")\n\nprint(\"Monatliche Mindesttemperatur\")\nprint(28 * \"=\")\nprint(temperaturen.min(axis = 1))\n\nMittlere Jahrestemperaturen\n===========================\n2021    13.500000\n2022    13.500000\n2023    10.583333\n2024    11.833333\ndtype: float64 \n\nMonatliche Mindesttemperatur\n============================\nJan    -3\nFeb    -1\nMär     4\nApr     8\nMai    15\nJun    20\nJul    20\nAug    19\nSep    16\nOkt    14\nNov     7\nDez     2\ndtype: int64\n\n\n\n\nboolsche Funktionen\nPandas bietet wie die Pythonbasis verschiedene boolsche Funktionen.\npd.DataFrame.isin(values) prüft für jedes Element des DataFrame, ob dieses in values enthalten ist. Mit dem Operator ~ kann geprüft werden, ob die Elemente eines DataFrame nicht in values enthalten sind: ~pd.DataFrame.isin(values).\nDie Funktionsausführung ist abhängig vom Datentyp des in values übergebenen Objekts. - Wenn values eine Liste oder ein NumPy-Array ist, ist das Ergebnis True, wenn es eine Übereinstimmung mit einem der enthaltenen Elemente gibt. - Ist value eine Series oder ein DataFrame, wird die Übereinstimmung positionsbasiert überprüft (siehe Beispiel).\n\n\n\n\n\n\nBeispiel 2.1: klassenabhängige Funktionsausführung\n\n\n\n\n\n\nEinzelwerte oder ListeNumPy-ArraySeriesDataFrame\n\n\nfür Einzelwerte oder eine Liste wird die Übereinstimmung elementweise überprüft.\n\nprint(temperaturen, \"\\n\")\n\nprint(temperaturen.isin([2, 3]))\n\n     2021  2022  2023  2024\nJan     2     3    -3    -1\nFeb     4     6    -1     2\nMär     7     9     4     5\nApr    12    13     9     8\nMai    19    18    15    17\nJun    23    21    20    24\nJul    25    24    20    25\nAug    23    23    19    20\nSep    18    19    16    17\nOkt    15    14    15    14\nNov     9     8     7     9\nDez     5     4     6     2 \n\n      2021   2022   2023   2024\nJan   True   True  False  False\nFeb  False  False  False   True\nMär  False  False  False  False\nApr  False  False  False  False\nMai  False  False  False  False\nJun  False  False  False  False\nJul  False  False  False  False\nAug  False  False  False  False\nSep  False  False  False  False\nOkt  False  False  False  False\nNov  False  False  False  False\nDez  False  False  False   True\n\n\n\n\nFür ein NumPy-Array wird die Übereinstimmung elementweise überprüft (vergleiche zum nächsten Reiter).\n\nprint(type(temperaturen[2021].values), \"\\n\")\n\nprint(temperaturen.isin(temperaturen[2021].values))\n\n&lt;class 'numpy.ndarray'&gt; \n\n     2021   2022   2023   2024\nJan  True  False  False  False\nFeb  True  False  False   True\nMär  True   True   True   True\nApr  True  False   True  False\nMai  True   True   True  False\nJun  True  False  False  False\nJul  True  False  False   True\nAug  True   True   True  False\nSep  True   True  False  False\nOkt  True  False   True  False\nNov  True  False   True   True\nDez  True   True  False   True\n\n\n\n\nFür eine Series wird die Übereinstimmung positionsweise geprüft (vergleiche zum vorherigen Reiter). Der Index muss übereinstimmen.\n\nprint(temperaturen.isin(temperaturen[2021]), \"\\n\")\n\ntemperaturen_2021_falscher_index = pd.Series([2, 4, 7, 12, 19, 23, 25, 23, 18, 15, 9, 5])\ntemperaturen_2021_falscher_index.index = ['A', 'B', 'C', 'D', 'E', 'F', 'Jul', 'Aug', 'Sep', 'Okt', 'Nov', 'Dez']\n\nprint(\"Der Index der Series lautet:\\n['A', 'B', 'C', 'D', 'E', 'F', 'Jul', 'Aug', 'Sep', 'Okt', 'Nov', 'Dez']. Das Ergebnis an den Indexpositionen A-F ist immer False.\")\nprint(temperaturen.isin(temperaturen_2021_falscher_index))\n\n     2021   2022   2023   2024\nJan  True  False  False  False\nFeb  True  False  False  False\nMär  True  False  False  False\nApr  True  False  False  False\nMai  True  False  False  False\nJun  True  False  False  False\nJul  True  False  False   True\nAug  True   True  False  False\nSep  True  False  False  False\nOkt  True  False   True  False\nNov  True  False  False   True\nDez  True  False  False  False \n\nDer Index der Series lautet:\n['A', 'B', 'C', 'D', 'E', 'F', 'Jul', 'Aug', 'Sep', 'Okt', 'Nov', 'Dez']. Das Ergebnis an den Indexpositionen A-F ist immer False.\n      2021   2022   2023   2024\nJan  False  False  False  False\nFeb  False  False  False  False\nMär  False  False  False  False\nApr  False  False  False  False\nMai  False  False  False  False\nJun  False  False  False  False\nJul   True  False  False   True\nAug   True   True  False  False\nSep   True  False  False  False\nOkt   True  False   True  False\nNov   True  False  False   True\nDez   True  False  False  False\n\n\n\n\nFür einen DataFrame wird die Übereinstimmung positionsweise geprüft. Index und Spaltennamen müssen übereinstimmen (Index siehe Reiter Series).\n\ntemperaturen_2021_df = pd.DataFrame(temperaturen[2021])\nprint(temperaturen.isin(temperaturen_2021_df), \"\\n\")\n\ntemperaturen_2021_df.columns = [2035]\nprint(temperaturen.isin(temperaturen_2021_df), \"\\n\")\n\n     2021   2022   2023   2024\nJan  True  False  False  False\nFeb  True  False  False  False\nMär  True  False  False  False\nApr  True  False  False  False\nMai  True  False  False  False\nJun  True  False  False  False\nJul  True  False  False  False\nAug  True  False  False  False\nSep  True  False  False  False\nOkt  True  False  False  False\nNov  True  False  False  False\nDez  True  False  False  False \n\n      2021   2022   2023   2024\nJan  False  False  False  False\nFeb  False  False  False  False\nMär  False  False  False  False\nApr  False  False  False  False\nMai  False  False  False  False\nJun  False  False  False  False\nJul  False  False  False  False\nAug  False  False  False  False\nSep  False  False  False  False\nOkt  False  False  False  False\nNov  False  False  False  False\nDez  False  False  False  False \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTipp 2.1: Überraschungen vermeiden\n\n\n\nEine klassenabhängige Funktionsausführung kann, wenn das Verhalten unbemerkt bleibt, die Ergebnisse einer Datenanalyse verfälschen. Um dies zu verhindern, sollten Sie 3 allgemeine Ratschläge befolgen:\n\nSchauen Sie in die Dokumentation der jeweiligen Funktion. Python und viele Module entwickeln sich dynamisch, sodass auch eine bereits bekannte Funktion ein neues Verhalten aufweisen kann.\nGehen Sie schrittweise vor und lassen sich die Zwischenergebnisse von Arbeitsschritten mit der Funktion print() ausgeben.\nBei großen Datenmengen ist es häufig einfacher, mit eigens erzeugten Testdaten zu arbeiten. Ein zehnzeiliger DataFrame mit den Datentypen und der Struktur der Arbeitsdaten, ist leichter zu überblicken. Nutzen Sie einen solchen Testdatensatz um die von Ihnen verwendeten Funktionen zu überprüfen.\n\n\n\nEine Gruppe von Funktionen setzt logische Vergleiche um.\n\n\n\nFunktion\nVergleich\n\n\n\n\npd.DataFrame.lt(other)\nkleiner\n\n\npd.DataFrame.le(other)\nkleiner gleich\n\n\npd.DataFrame.eq(other)\ngleich\n\n\npd.DataFrame.ne(other)\nungleich\n\n\npd.DataFrame.ge(other)\ngrößer gleich\n\n\npd.DataFrame.gt(other)\ngrößer",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Operationen</span>"
    ]
  },
  {
    "objectID": "operationen.html#groupby-sollte-in-diesem-kapitel-vorgestellt-werden",
    "href": "operationen.html#groupby-sollte-in-diesem-kapitel-vorgestellt-werden",
    "title": "2  Operationen",
    "section": "2.4 GroupBy sollte in diesem Kapitel vorgestellt werden",
    "text": "2.4 GroupBy sollte in diesem Kapitel vorgestellt werden\nhttps://pandas.pydata.org/docs/reference/groupby.html\n–&gt; das GroupBy-Objekt kann man sich leider nicht angucken oder geht das irgendwie?",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Operationen</span>"
    ]
  },
  {
    "objectID": "operationen.html#sortieren",
    "href": "operationen.html#sortieren",
    "title": "2  Operationen",
    "section": "2.3 Sortieren",
    "text": "2.3 Sortieren\nDataFrame.sort_index() sorts by an axis:\nDataFrame.sort_values() sorts by values:\nhttps://pandas.pydata.org/docs/user_guide/10min.html",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Operationen</span>"
    ]
  },
  {
    "objectID": "operationen.html#suchen-und-ersetzen",
    "href": "operationen.html#suchen-und-ersetzen",
    "title": "2  Operationen",
    "section": "2.2 Suchen und ersetzen",
    "text": "2.2 Suchen und ersetzen\nUm die Indexposition eines bestimmten Werts zu bestimmen, kann die Numpy-Funktion np.where() verwendet werden. Diese gibt zwei Arrays mit den jeweiligen Zeilen- und Spaltennummern zurück.\n\nprint(np.where(temperaturen == 4))\n\n(array([ 1,  2, 11], dtype=int64), array([0, 2, 1], dtype=int64))\n\n\nUnter anderem befindet sich der Wert 4 in Zeile 1 in Spalte 0.\n\nprint(temperaturen.iloc[1, 0])\n\n4\n\n\nPandas bietet zwei Methoden, um Werte zu ersetzen.\n\npd.DataFrame.replace(to_replace, value, *, inplace = False) ersetzt to_replace mit value. Mit dem Argument inplace = True erfolgt dies direkt im Objekt.\npd.where(cond, other, inplace = False) behält cond und ersetzt alle anderen Werte mit other. Mit dem Argument inplace = True erfolgt dies direkt im Objekt.\n\nDie Syntax beider Funktionen unterscheidet sich leicht, wie im folgenden Beispiel zu sehen ist.\n\nprint(temperaturen.replace(to_replace = 25, value = 1000), \"\\n\")\nprint(temperaturen.where(temperaturen == 25, other = 1000))\n\n     2021  2022  2023  2024\nJan     2     3    -3    -1\nFeb     4     6    -1     2\nMär     7     9     4     5\nApr    12    13     9     8\nMai    19    18    15    17\nJun    23    21    20    24\nJul  1000    24    20  1000\nAug    23    23    19    20\nSep    18    19    16    17\nOkt    15    14    15    14\nNov     9     8     7     9\nDez     5     4     6     2 \n\n     2021  2022  2023  2024\nJan  1000  1000  1000  1000\nFeb  1000  1000  1000  1000\nMär  1000  1000  1000  1000\nApr  1000  1000  1000  1000\nMai  1000  1000  1000  1000\nJun  1000  1000  1000  1000\nJul    25  1000  1000    25\nAug  1000  1000  1000  1000\nSep  1000  1000  1000  1000\nOkt  1000  1000  1000  1000\nNov  1000  1000  1000  1000\nDez  1000  1000  1000  1000",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Operationen</span>"
    ]
  },
  {
    "objectID": "operationen.html#funktionen-für-funktionen--",
    "href": "operationen.html#funktionen-für-funktionen--",
    "title": "2  Operationen",
    "section": "2.5 Funktionen für Funktionen :-)",
    "text": "2.5 Funktionen für Funktionen :-)\npipe, apply usw. https://pandas.pydata.org/docs/user_guide/basics.html#function-application\nFür die meisten Funktionen stehen Methoden zur Verfügung. –&gt; Sehr viele –&gt; Tipp: In der Dokumentation nachschlagen.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Operationen</span>"
    ]
  }
]